<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MdeModulePkg[all]: MdeModulePkg/Include/Protocol/NonDiscoverableDevice.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MdeModulePkg[all]
   &#160;<span id="projectnumber">0.98</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_protocol_2_non_discoverable_device_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">NonDiscoverableDevice.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___n_o_n___d_i_s_c_o_v_e_r_a_b_l_e___d_e_v_i_c_e.html">_NON_DISCOVERABLE_DEVICE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a370a953c1ed7d5bd8c32f55e63aa717e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_2_non_discoverable_device_8h.html#a370a953c1ed7d5bd8c32f55e63aa717e">EDKII_NON_DISCOVERABLE_DEVICE_PROTOCOL_GUID</a>&#160;&#160;&#160;{ 0x0d51905b, 0xb77e, 0x452a, {0xa2, 0xc0, 0xec, 0xa0, 0xcc, 0x8d, 0x51, 0x4a } }</td></tr>
<tr class="separator:a370a953c1ed7d5bd8c32f55e63aa717e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab28351791d49c02fe38389d39177bf37"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct___n_o_n___d_i_s_c_o_v_e_r_a_b_l_e___d_e_v_i_c_e.html">_NON_DISCOVERABLE_DEVICE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_2_non_discoverable_device_8h.html#ab28351791d49c02fe38389d39177bf37">NON_DISCOVERABLE_DEVICE</a></td></tr>
<tr class="separator:ab28351791d49c02fe38389d39177bf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a649cbf8527510d67e758268a899d3ea9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_2_non_discoverable_device_8h.html#a649cbf8527510d67e758268a899d3ea9">NON_DISCOVERABLE_DEVICE_DMA_TYPE</a> { <a class="el" href="_protocol_2_non_discoverable_device_8h.html#a649cbf8527510d67e758268a899d3ea9afe39d34186e6e93d1b390046381e1169">NonDiscoverableDeviceDmaTypeCoherent</a>, 
<a class="el" href="_protocol_2_non_discoverable_device_8h.html#a649cbf8527510d67e758268a899d3ea9afb2a4f47c231341589f950cf178e1a66">NonDiscoverableDeviceDmaTypeNonCoherent</a>, 
<a class="el" href="_protocol_2_non_discoverable_device_8h.html#a649cbf8527510d67e758268a899d3ea9a6b095265a10a5c9b13992954ac044b50">NonDiscoverableDeviceDmaTypeMax</a>
 }</td></tr>
<tr class="separator:a649cbf8527510d67e758268a899d3ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c20065c4c27f2482eacffe6262064ce"><td class="memItemLeft" align="right" valign="top">typedef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_2_non_discoverable_device_8h.html#a4c20065c4c27f2482eacffe6262064ce">EFI_STATUS</a> (EFIAPI *NON_DISCOVERABLE_DEVICE_INIT)(IN <a class="el" href="_protocol_2_non_discoverable_device_8h.html#ab28351791d49c02fe38389d39177bf37">NON_DISCOVERABLE_DEVICE</a> *<a class="el" href="_sec_performance_8h.html#a921ccfa7b828b95b9fc9b5d75c935767">This</a>)</td></tr>
<tr class="separator:a4c20065c4c27f2482eacffe6262064ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a172447eace216767e4763f5c1fdf7ce5"><td class="memItemLeft" align="right" valign="top">EFI_GUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_2_non_discoverable_device_8h.html#a172447eace216767e4763f5c1fdf7ce5">gEdkiiNonDiscoverableDeviceProtocolGuid</a></td></tr>
<tr class="separator:a172447eace216767e4763f5c1fdf7ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Protocol to describe devices that are not on a discoverable bus</p>
<p>Copyright (c) 2016, Linaro, Ltd. All rights reserved.<br/>
</p>
<p>SPDX-License-Identifier: BSD-2-Clause-Patent </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a370a953c1ed7d5bd8c32f55e63aa717e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EDKII_NON_DISCOVERABLE_DEVICE_PROTOCOL_GUID&#160;&#160;&#160;{ 0x0d51905b, 0xb77e, 0x452a, {0xa2, 0xc0, 0xec, 0xa0, 0xcc, 0x8d, 0x51, 0x4a } }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab28351791d49c02fe38389d39177bf37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___n_o_n___d_i_s_c_o_v_e_r_a_b_l_e___d_e_v_i_c_e.html">_NON_DISCOVERABLE_DEVICE</a> <a class="el" href="_protocol_2_non_discoverable_device_8h.html#ab28351791d49c02fe38389d39177bf37">NON_DISCOVERABLE_DEVICE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a649cbf8527510d67e758268a899d3ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_protocol_2_non_discoverable_device_8h.html#a649cbf8527510d67e758268a899d3ea9">NON_DISCOVERABLE_DEVICE_DMA_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a649cbf8527510d67e758268a899d3ea9afe39d34186e6e93d1b390046381e1169"></a>NonDiscoverableDeviceDmaTypeCoherent</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a649cbf8527510d67e758268a899d3ea9afb2a4f47c231341589f950cf178e1a66"></a>NonDiscoverableDeviceDmaTypeNonCoherent</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a649cbf8527510d67e758268a899d3ea9a6b095265a10a5c9b13992954ac044b50"></a>NonDiscoverableDeviceDmaTypeMax</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4c20065c4c27f2482eacffe6262064ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EFI_STATUS </td>
          <td>(</td>
          <td class="paramtype">EFIAPI *&#160;</td>
          <td class="paramname"><em>PASSWORD_CHECK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform device specific initialization before the device is started</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>The non-discoverable device protocol pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Initialization successful, the device may be used </td></tr>
    <tr><td class="paramname">Other</td><td>Initialization failed, device should not be started</td></tr>
  </table>
  </dd>
</dl>
<p>The security handler is used to abstracts security-specific functions from the DXE Foundation of UEFI Image Verification, Trusted Computing Group (TCG) measured boot, User Identity policy for image loading and consoles, and for purposes of handling GUIDed section encapsulations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthenticationStatus</td><td>The authentication status for the input file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">File</td><td>The pointer to the device path of the file that is being dispatched. This will optionally be used for logging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileBuffer</td><td>A pointer to the buffer with the UEFI file image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileSize</td><td>The size of File buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BootPolicy</td><td>A boot policy that was used to call LoadImage() UEFI service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The file specified by DevicePath and non-NULL FileBuffer did authenticate, and the platform policy dictates that the DXE Foundation may use the file. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path specified by NULL device path DevicePath and non-NULL FileBuffer did authenticate, and the platform policy dictates that the DXE Foundation may execute the image in FileBuffer. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>FileBuffer is NULL and current user has permission to start UEFI device drivers on the device path specified by DevicePath. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The file specified by DevicePath and FileBuffer did not authenticate, and the platform policy dictates that the file should be placed in the untrusted state. The image has been added to the file execution table. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file specified by File and FileBuffer did not authenticate, and the platform policy dictates that the DXE Foundation may not use File. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>FileBuffer is NULL and the user has no permission to start UEFI device drivers on the device path specified by DevicePath. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>FileBuffer is not NULL and the user has no permission to load drivers from the device path specified by DevicePath. The image has been added into the list of the deferred images.</td></tr>
  </table>
  </dd>
</dl>
<p>Finds next variable in storage blocks of volatile and non-volatile storage areas.</p>
<p>This code finds next variable in storage blocks of volatile and non-volatile storage areas. If VariableName is an empty string, then we just return the first qualified variable without comparing VariableName and VendorGuid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableName</td><td>Name of the variable to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VendorGuid</td><td>Variable vendor GUID to be found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AuthVariableInfo</td><td>Pointer to <a class="el" href="struct_a_u_t_h___v_a_r_i_a_b_l_e___i_n_f_o.html">AUTH_VARIABLE_INFO</a> structure for output of the next variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>If VariableName is not an empty string, while VendorGuid is NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Variable successfully found. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Variable not found</td></tr>
  </table>
  </dd>
</dl>
<p>Update the variable region with Variable information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthVariableInfo</td><td>Pointer <a class="el" href="struct_a_u_t_h___v_a_r_i_a_b_l_e___i_n_f_o.html">AUTH_VARIABLE_INFO</a> structure for input of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The update operation is success. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Invalid parameter. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>Variable is write-protected. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough resource.</td></tr>
  </table>
  </dd>
</dl>
<p>Get scratch buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScratchBufferSize</td><td>Scratch buffer size. If input size is greater than the maximum supported buffer size, this value contains the maximum supported buffer size as output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ScratchBuffer</td><td>Pointer to scratch buffer address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Get scratch buffer successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>If input size is greater than the maximum supported buffer size.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends an NVM Express Command Packet to an NVM Express controller or namespace. This function only supports blocking execution of the command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NamespaceId</td><td>Is a 32 bit Namespace ID to which the Nvm Express command packet will be sent. A Value of 0 denotes the NVM Express controller, a Value of all 0FFh in the namespace ID specifies that the command packet should be sent to all valid namespaces. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Packet</td><td>A pointer to the EDKII PEI NVM Express PassThru Command Packet to send to the NVMe namespace specified by NamespaceId.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The EDKII PEI NVM Express Command Packet was sent by the host. TransferLength bytes were transferred to, or from DataBuffer. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The EDKII PEI NVM Express Command Packet could not be sent because the controller is not ready. The caller may retry again later. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A device error occurred while attempting to send the EDKII PEI NVM Express Command Packet. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Namespace, or the contents of EDKII_PEI_NVM_EXPRESS_PASS_THRU_COMMAND_PACKET are invalid. The EDKII PEI NVM Express Command Packet was not sent, so no additional status information is available. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The command described by the EDKII PEI NVM Express Command Packet is not supported by the host adapter. The EDKII PEI NVM Express Command Packet was not sent, so no additional status information is available. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the EDKII PEI NVM Express Command Packet to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the device path of NVM Express host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerId</td><td>The ID of the NVM Express host controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of NVM Express host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified NVM Express host controller not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the device path of ATA AHCI host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerId</td><td>The ID of the ATA AHCI host controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of ATA AHCI host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified ATA AHCI host controller not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Used to retrieve the list of legal port numbers for ATA devices on an ATA controller. These can either be the list of ports where ATA devices are actually present or the list of legal port numbers for the ATA controller. Regardless, the caller of this function must probe the port number returned to see if an ATA device is actually present at that location on the ATA controller.</p>
<p>The GetNextPort() function retrieves the port number on an ATA controller. If on input Port is 0xFFFF, then the port number of the first port on the ATA controller is returned in Port and EFI_SUCCESS is returned.</p>
<p>If Port is a port number that was returned on a previous call to GetNextPort(), then the port number of the next port on the ATA controller is returned in Port, and EFI_SUCCESS is returned. If Port is not 0xFFFF and Port was not returned on a previous call to GetNextPort(), then EFI_INVALID_PARAMETER is returned.</p>
<p>If Port is the port number of the last port on the ATA controller, then EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Port</td><td>On input, a pointer to the port number on the ATA controller. On output, a pointer to the next port number on the ATA controller. An input value of 0xFFFF retrieves the first port number on the ATA controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The next port number on the ATA controller was returned in Port. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There are no more ports on this ATA controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Port is not 0xFFFF and Port was not returned on a previous call to GetNextPort().</td></tr>
  </table>
  </dd>
</dl>
<p>Used to retrieve the list of legal port multiplier port numbers for ATA devices on a port of an ATA controller. These can either be the list of port multiplier ports where ATA devices are actually present on port or the list of legal port multiplier ports on that port. Regardless, the caller of this function must probe the port number and port multiplier port number returned to see if an ATA device is actually present.</p>
<p>The GetNextDevice() function retrieves the port multiplier port number of an ATA device present on a port of an ATA controller.</p>
<p>If PortMultiplierPort points to a port multiplier port number value that was returned on a previous call to GetNextDevice(), then the port multiplier port number of the next ATA device on the port of the ATA controller is returned in PortMultiplierPort, and EFI_SUCCESS is returned.</p>
<p>If PortMultiplierPort points to 0xFFFF, then the port multiplier port number of the first ATA device on port of the ATA controller is returned in PortMultiplierPort and EFI_SUCCESS is returned.</p>
<p>If PortMultiplierPort is not 0xFFFF and the value pointed to by PortMultiplierPort was not returned on a previous call to GetNextDevice(), then EFI_INVALID_PARAMETER is returned.</p>
<p>If PortMultiplierPort is the port multiplier port number of the last ATA device on the port of the ATA controller, then EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>The port number present on the ATA controller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PortMultiplierPort</td><td>On input, a pointer to the port multiplier port number of an ATA device present on the ATA controller. If on input a PortMultiplierPort of 0xFFFF is specified, then the port multiplier port number of the first ATA device is returned. On output, a pointer to the port multiplier port number of the next ATA device present on an ATA controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The port multiplier port number of the next ATA device on the port of the ATA controller was returned in PortMultiplierPort. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There are no more ATA devices on this port of the ATA controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PortMultiplierPort is not 0xFFFF, and PortMultiplierPort was not returned on a previous call to GetNextDevice().</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the device path information of the underlying ATA host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of the underlying ATA host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path of the ATA host controller has been successfully returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePathLength or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Not enough resource to return the device path.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the device path of a specific storage security device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>Specifies the storage security device to which the function wants to talk. Because the driver that implements Storage Security Command PPIs will manage multiple storage devices, the PPIs that want to talk to a single device must specify the device index that was assigned during the enumeration process. This index is a number from one to NumberofDevices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of storage security device. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePathLength or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified storage security device not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Send a security protocol command to a device that receives data and/or the result of one or more commands sent by SendData.</p>
<p>The ReceiveData function sends a security protocol command to the given DeviceIndex. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. The function returns the data from the security protocol command in PayloadBuffer.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL IN command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED RECEIVE commands defined in ATA8-ACS if PayloadBufferSize is non-zero.</p>
<p>If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBufferSize is too small to store the available data from the security protocol command, the function shall copy PayloadBufferSize bytes into the PayloadBuffer and return EFI_WARN_BUFFER_TOO_SMALL.</p>
<p>If PayloadBuffer or PayloadTransferSize is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given DeviceIndex does not support security protocol commands, the function shall return EFI_UNSUPPORTED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the function shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>Specifies the storage security device to which the function wants to talk. Because the driver that implements Storage Security Command PPIs will manage multiple storage devices, the PPIs that want to talk to a single device must specify the device index that was assigned during the enumeration process. This index is a number from one to NumberofDevices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command. The caller is responsible for having either implicit or explicit ownership of the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PayloadTransferSize</td><td>A pointer to a buffer to store the size in bytes of the data written to the payload data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_WARN_BUFFER_TOO_SMALL</td><td>The PayloadBufferSize was too small to store the available data from the device. The PayloadBuffer contains the truncated data. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given DeviceIndex does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer or PayloadTransferSize is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Send a security protocol command to a device.</p>
<p>The SendData function sends a security protocol command containing the payload PayloadBuffer to the given DeviceIndex. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. If the underlying protocol command requires a specific padding for the command payload, the SendData function shall add padding bytes to the command payload to satisfy the padding requirements.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL OUT command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED SEND commands defined in ATA8-ACS if PayloadBufferSize is non-zero. If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBuffer is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given DeviceIndex does not support security protocol commands, the function shall return EFI_UNSUPPORTED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the functio shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>The ID of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given DeviceIndex does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Clears any system state that was created in response to the Active call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeiServices</td><td>General purpose services available to every PEIM. </td></tr>
    <tr><td class="paramname">This</td><td>The PEI_SMM_CONTROL_PPI instance. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Optional parameter to repeat at this period one time or, if the Periodic Boolean is set, periodically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMI/PMI has been engendered. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The source could not be cleared. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The service did not support the Periodic input argument.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called by SmmChildDispatcher module to report an existing SMI handler is unregistered, to SmmCore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>The protocol instance </td></tr>
    <tr><td class="paramname">HandlerGuid</td><td>The GUID to identify the type of the handler. For the SmmChildDispatch protocol, the HandlerGuid must be the GUID of SmmChildDispatch protocol. </td></tr>
    <tr><td class="paramname">Handler</td><td>The SMI handler. </td></tr>
    <tr><td class="paramname">Context</td><td>The context of the SMI handler. If it is NOT NULL, it will be used to check what is registered. </td></tr>
    <tr><td class="paramname">ContextSize</td><td>The size of the context in bytes. If Context is NOT NULL, it will be used to check what is registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The original record is removed. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There is no record for the HandlerGuid and handler.</td></tr>
  </table>
  </dd>
</dl>
<p>Set memory profile recording state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EDKII_MEMORY_PROFILE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RecordingState</td><td>Recording state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EFI_SUCCESS Set memory profile recording state successfully. </dd>
<dd>
EFI_UNSUPPORTED Memory profile is unsupported.</dd></dl>
<p>Record memory profile of multilevel caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EDKII_MEMORY_PROFILE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallerAddress</td><td>Address of caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Action</td><td>Memory profile action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MemoryType</td><td>Memory type. EfiMaxMemoryType means the MemoryType is unknown. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Buffer address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Size</td><td>Buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ActionString</td><td>String for memory profile action. Only needed for user defined allocate action.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EFI_SUCCESS Memory profile is updated. </dd>
<dd>
EFI_UNSUPPORTED Memory profile is unsupported, or memory profile for the image is not required, or memory profile for the memory type is not required. </dd>
<dd>
EFI_ACCESS_DENIED It is during memory profile data getting. </dd>
<dd>
EFI_ABORTED Memory profile recording is not enabled. </dd>
<dd>
EFI_OUT_OF_RESOURCES No enough resource to update memory profile for allocate action. </dd>
<dd>
EFI_NOT_FOUND No matched allocate info found for free action.</dd></dl>
<p>Variable property set. Variable driver will do check according to the VariableProperty before really setting the variable into variable storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Name</td><td>Pointer to the variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>Pointer to the vendor GUID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableProperty</td><td>Pointer to the input variable property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The property of variable specified by the Name and Guid was set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Name, Guid or VariableProperty is NULL, or Name is an empty string, or the fields of VariableProperty are not valid. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>EFI_END_OF_DXE_EVENT_GROUP_GUID or EFI_EVENT_GROUP_READY_TO_BOOT has already been signaled. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough resource for the variable property set request.</td></tr>
  </table>
  </dd>
</dl>
<p>Variable property get.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Name</td><td>Pointer to the variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>Pointer to the vendor GUID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VariableProperty</td><td>Pointer to the output variable property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The property of variable specified by the Name and Guid was got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Name, Guid or VariableProperty is NULL, or Name is an empty string. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The property of variable specified by the Name and Guid was not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Allows platform protocol to override host controller information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>Handle of the UFS controller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">HcInfo</td><td>Pointer <a class="el" href="struct_e_d_k_i_i___u_f_s___h_c___i_n_f_o.html">EDKII_UFS_HC_INFO</a> associated with host controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HcInfo is NULL. </td></tr>
    <tr><td class="paramname">Others</td><td>Function failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function for platform driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>Handle of the UFS controller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallbackPhase</td><td>Specifies when the platform protocol is called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CallbackData</td><td>Data specific to the callback phase. For PreHce and PostHce - EDKII_UFS_HC_DRIVER_INTERFACE. For PreLinkStartup and PostLinkStartup - EDKII_UFS_HC_DRIVER_INTERFACE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Override function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CallbackPhase is invalid or CallbackData is NULL when phase expects valid data. </td></tr>
    <tr><td class="paramname">Others</td><td>Function failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Unregister a PE/COFF image that has been registered with the emulator. This should be done before the image is unloaded from memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>This pointer for EDKII_PECOFF_IMAGE_EMULATOR_PROTOCOL structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ImageBase</td><td>The base address in memory of the PE/COFF image</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The image was unregistered with the emulator. </td></tr>
    <tr><td class="paramname">other</td><td>Image could not be unloaded.</td></tr>
  </table>
  </dd>
</dl>
<p>This interface allows you to configure the EBC debug support driver. For example, turn on or off saving and printing of delta VM even if called. Or to even disable the entire interface, in which case all functions become no-ops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_SIMPLE_DEBUGGER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigId</td><td>ID to be configured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigValue</td><td>Value to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>No support for it. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Configure EBC debug.</td></tr>
  </table>
  </dd>
</dl>
<p>Override function for SDHCI controller operations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>The EFI_HANDLE of the controller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>The 0 based slot index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PhaseType</td><td>The type of operation and whether the hook is invoked right before (pre) or right after (post) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PhaseData</td><td>The pointer to a phase-specific data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The override function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified controller or slot does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PhaseType is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Register the hot key with its browser action, or unregistered the hot key. If the action value is zero, the hot key will be unregistered if it has been registered. If the same hot key has been registered, the new action and help string will override the previous ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyData</td><td>A pointer to a buffer that describes the keystroke information for the hot key. Its type is EFI_INPUT_KEY to be supported by all ConsoleIn devices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Action</td><td>Action value that describes what action will be trigged when the hot key is pressed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DefaultId</td><td>Specifies the type of defaults to retrieve, which is only for DEFAULT action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HelpString</td><td>Help string that describes the hot key information. Its value may be NULL for the unregistered hot key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Hot key is registered or unregistered. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyData is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert AsmText to the instruction. This function is only used for test purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_VM_TEST_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AsmText</td><td>A pointer to EBC ASM text code. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Buffer to store the instruction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BufferLen</td><td>Size of buffer that is required to store data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This functionality is unsupported. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully convert AsmText to the instruction.</td></tr>
  </table>
  </dd>
</dl>
<p>Dump the executed instruction. This function is only used for test purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_VM_TEST_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AsmText</td><td>Contain the disasm text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Buffer to store the instruction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BufferLen</td><td>Size of buffer that is required to store data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This functionality is unsupported. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully dump the executed instruction.</td></tr>
  </table>
  </dd>
</dl>
<p>Display one form, and return user input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FormData</td><td>Form Data to be shown. </td></tr>
    <tr><td class="paramname">UserInputData</td><td>User input data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Form Data is shown, and user input is got.</td></tr>
  </table>
  </dd>
</dl>
<p>Finds variable in storage blocks of volatile and non-volatile storage areas.</p>
<p>This code finds variable in storage blocks of volatile and non-volatile storage areas. If VariableName is an empty string, then we just return the first qualified variable without comparing VariableName and VendorGuid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableName</td><td>Name of the variable to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VendorGuid</td><td>Variable vendor GUID to be found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AuthVariableInfo</td><td>Pointer to <a class="el" href="struct_a_u_t_h___v_a_r_i_a_b_l_e___i_n_f_o.html">AUTH_VARIABLE_INFO</a> structure for output of the variable found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>If VariableName is not an empty string, while VendorGuid is NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Variable successfully found. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Variable not found</td></tr>
  </table>
  </dd>
</dl>
<p>Finds next variable in storage blocks of volatile and non-volatile storage areas.</p>
<p>This code finds next variable in storage blocks of volatile and non-volatile storage areas. If VariableName is an empty string, then we just return the first qualified variable without comparing VariableName and VendorGuid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableName</td><td>Name of the variable to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VendorGuid</td><td>Variable vendor GUID to be found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AuthVariableInfo</td><td>Pointer to <a class="el" href="struct_a_u_t_h___v_a_r_i_a_b_l_e___i_n_f_o.html">AUTH_VARIABLE_INFO</a> structure for output of the next variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>If VariableName is not an empty string, while VendorGuid is NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Variable successfully found. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Variable not found</td></tr>
  </table>
  </dd>
</dl>
<p>Update the variable region with Variable information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthVariableInfo</td><td>Pointer <a class="el" href="struct_a_u_t_h___v_a_r_i_a_b_l_e___i_n_f_o.html">AUTH_VARIABLE_INFO</a> structure for input of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The update operation is success. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Invalid parameter. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>Variable is write-protected. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough resource.</td></tr>
  </table>
  </dd>
</dl>
<p>Get scratch buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScratchBufferSize</td><td>Scratch buffer size. If input size is greater than the maximum supported buffer size, this value contains the maximum supported buffer size as output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ScratchBuffer</td><td>Pointer to scratch buffer address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Get scratch buffer successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>If input size is greater than the maximum supported buffer size.</td></tr>
  </table>
  </dd>
</dl>
<p>This interface conveys performance information out of the Security (SEC) phase into PEI.</p>
<p>This service is published by the SEC phase. The SEC phase handoff has an optional EFI_PEI_PPI_DESCRIPTOR list as its final argument when control is passed from SEC into the PEI Foundation. As such, if the platform supports collecting performance data in SEC, this information is encapsulated into the data structure abstracted by this service. This information is collected for the boot-strap processor (BSP) on IA-32.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>The pointer to the PEI Services Table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to this instance of the PEI_SEC_PERFORMANCE_PPI. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Performance</td><td>The pointer to performance data collected in SEC phase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The performance data was successfully returned.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the device path information of the underlying NVM Express host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of the underlying NVM Express host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePathLength or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends an NVM Express Command Packet to an NVM Express controller or namespace. This function only supports blocking execution of the command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NamespaceId</td><td>Is a 32 bit Namespace ID to which the Nvm Express command packet will be sent. A Value of 0 denotes the NVM Express controller, a Value of all 0FFh in the namespace ID specifies that the command packet should be sent to all valid namespaces. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Packet</td><td>A pointer to the EDKII PEI NVM Express PassThru Command Packet to send to the NVMe namespace specified by NamespaceId.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The EDKII PEI NVM Express Command Packet was sent by the host. TransferLength bytes were transferred to, or from DataBuffer. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The EDKII PEI NVM Express Command Packet could not be sent because the controller is not ready. The caller may retry again later. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A device error occurred while attempting to send the EDKII PEI NVM Express Command Packet. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Namespace, or the contents of EDKII_PEI_NVM_EXPRESS_PASS_THRU_COMMAND_PACKET are invalid. The EDKII PEI NVM Express Command Packet was not sent, so no additional status information is available. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The command described by the EDKII PEI NVM Express Command Packet is not supported by the host adapter. The EDKII PEI NVM Express Command Packet was not sent, so no additional status information is available. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the EDKII PEI NVM Express Command Packet to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the MMIO base address of NVM Express host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerId</td><td>The ID of the NVM Express host controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MmioBar</td><td>The MMIO base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified NVM Express host controller not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the device path of NVM Express host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerId</td><td>The ID of the NVM Express host controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of NVM Express host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified NVM Express host controller not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the MMIO base address of ATA AHCI host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerId</td><td>The ID of the ATA AHCI host controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MmioBar</td><td>The MMIO base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified ATA AHCI host controller not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the device path of ATA AHCI host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerId</td><td>The ID of the ATA AHCI host controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of ATA AHCI host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified ATA AHCI host controller not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends an ATA command to an ATA device that is attached to the ATA controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>The port number of the ATA device to send the command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PortMultiplierPort</td><td>The port multiplier port number of the ATA device to send the command. If there is no port multiplier, then specify 0xFFFF. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Packet</td><td>A pointer to the ATA command to send to the ATA device specified by Port and PortMultiplierPort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The ATA command was sent by the host. For bi-directional commands, InTransferLength bytes were transferred from InDataBuffer. For write and bi-directional commands, OutTransferLength bytes were transferred by OutDataBuffer. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified ATA device is not found. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The contents of Acb are invalid. The ATA command was not sent, so no additional status information is available. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The ATA command was not executed. The number of bytes that could be transferred is returned in InTransferLength. For write and bi-directional commands, OutTransferLength bytes were transferred by OutDataBuffer. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The ATA command could not be sent because there are too many ATA commands already queued. The caller may retry again later. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A device error occurred while attempting to send the ATA command.</td></tr>
  </table>
  </dd>
</dl>
<p>Used to retrieve the list of legal port numbers for ATA devices on an ATA controller. These can either be the list of ports where ATA devices are actually present or the list of legal port numbers for the ATA controller. Regardless, the caller of this function must probe the port number returned to see if an ATA device is actually present at that location on the ATA controller.</p>
<p>The GetNextPort() function retrieves the port number on an ATA controller. If on input Port is 0xFFFF, then the port number of the first port on the ATA controller is returned in Port and EFI_SUCCESS is returned.</p>
<p>If Port is a port number that was returned on a previous call to GetNextPort(), then the port number of the next port on the ATA controller is returned in Port, and EFI_SUCCESS is returned. If Port is not 0xFFFF and Port was not returned on a previous call to GetNextPort(), then EFI_INVALID_PARAMETER is returned.</p>
<p>If Port is the port number of the last port on the ATA controller, then EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Port</td><td>On input, a pointer to the port number on the ATA controller. On output, a pointer to the next port number on the ATA controller. An input value of 0xFFFF retrieves the first port number on the ATA controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The next port number on the ATA controller was returned in Port. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There are no more ports on this ATA controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Port is not 0xFFFF and Port was not returned on a previous call to GetNextPort().</td></tr>
  </table>
  </dd>
</dl>
<p>Used to retrieve the list of legal port multiplier port numbers for ATA devices on a port of an ATA controller. These can either be the list of port multiplier ports where ATA devices are actually present on port or the list of legal port multiplier ports on that port. Regardless, the caller of this function must probe the port number and port multiplier port number returned to see if an ATA device is actually present.</p>
<p>The GetNextDevice() function retrieves the port multiplier port number of an ATA device present on a port of an ATA controller.</p>
<p>If PortMultiplierPort points to a port multiplier port number value that was returned on a previous call to GetNextDevice(), then the port multiplier port number of the next ATA device on the port of the ATA controller is returned in PortMultiplierPort, and EFI_SUCCESS is returned.</p>
<p>If PortMultiplierPort points to 0xFFFF, then the port multiplier port number of the first ATA device on port of the ATA controller is returned in PortMultiplierPort and EFI_SUCCESS is returned.</p>
<p>If PortMultiplierPort is not 0xFFFF and the value pointed to by PortMultiplierPort was not returned on a previous call to GetNextDevice(), then EFI_INVALID_PARAMETER is returned.</p>
<p>If PortMultiplierPort is the port multiplier port number of the last ATA device on the port of the ATA controller, then EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>The port number present on the ATA controller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PortMultiplierPort</td><td>On input, a pointer to the port multiplier port number of an ATA device present on the ATA controller. If on input a PortMultiplierPort of 0xFFFF is specified, then the port multiplier port number of the first ATA device is returned. On output, a pointer to the port multiplier port number of the next ATA device present on an ATA controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The port multiplier port number of the next ATA device on the port of the ATA controller was returned in PortMultiplierPort. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There are no more ATA devices on this port of the ATA controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PortMultiplierPort is not 0xFFFF, and PortMultiplierPort was not returned on a previous call to GetNextDevice().</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the device path information of the underlying ATA host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of the underlying ATA host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path of the ATA host controller has been successfully returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePathLength or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Not enough resource to return the device path.</td></tr>
  </table>
  </dd>
</dl>
<p>This service enables submitting commands via Ipmi.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>This point for PEI_IPMI_PPI structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NetFunction</td><td>Net function of the command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Command</td><td>IPMI Command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestData</td><td>Command Request Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestDataSize</td><td>Size of Command Request Data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ResponseData</td><td>Command Response Data. The completion code is the first byte of response data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ResponseDataSize</td><td>Size of Command Response Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The command byte stream was successfully submit to the device and a response was successfully received. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The command was not successfully sent to the device or a response was not successfully received from the device. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Ipmi Device is not ready for Ipmi command access. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Ipmi Device hardware error. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>The command time out. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The command was not successfully sent to the device. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The resource allcation is out of resource or data size error.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the count of storage security devices that one specific driver detects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NumberofDevices</td><td>The number of storage security devices discovered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation performed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the device path of a specific storage security device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>Specifies the storage security device to which the function wants to talk. Because the driver that implements Storage Security Command PPIs will manage multiple storage devices, the PPIs that want to talk to a single device must specify the device index that was assigned during the enumeration process. This index is a number from one to NumberofDevices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of storage security device. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePathLength or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified storage security device not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Send a security protocol command to a device that receives data and/or the result of one or more commands sent by SendData.</p>
<p>The ReceiveData function sends a security protocol command to the given DeviceIndex. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. The function returns the data from the security protocol command in PayloadBuffer.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL IN command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED RECEIVE commands defined in ATA8-ACS if PayloadBufferSize is non-zero.</p>
<p>If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBufferSize is too small to store the available data from the security protocol command, the function shall copy PayloadBufferSize bytes into the PayloadBuffer and return EFI_WARN_BUFFER_TOO_SMALL.</p>
<p>If PayloadBuffer or PayloadTransferSize is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given DeviceIndex does not support security protocol commands, the function shall return EFI_UNSUPPORTED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the function shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>Specifies the storage security device to which the function wants to talk. Because the driver that implements Storage Security Command PPIs will manage multiple storage devices, the PPIs that want to talk to a single device must specify the device index that was assigned during the enumeration process. This index is a number from one to NumberofDevices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command. The caller is responsible for having either implicit or explicit ownership of the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PayloadTransferSize</td><td>A pointer to a buffer to store the size in bytes of the data written to the payload data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_WARN_BUFFER_TOO_SMALL</td><td>The PayloadBufferSize was too small to store the available data from the device. The PayloadBuffer contains the truncated data. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given DeviceIndex does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer or PayloadTransferSize is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Send a security protocol command to a device.</p>
<p>The SendData function sends a security protocol command containing the payload PayloadBuffer to the given DeviceIndex. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. If the underlying protocol command requires a specific padding for the command payload, the SendData function shall add padding bytes to the command payload to satisfy the padding requirements.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL OUT command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED SEND commands defined in ATA8-ACS if PayloadBufferSize is non-zero. If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBuffer is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given DeviceIndex does not support security protocol commands, the function shall return EFI_UNSUPPORTED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the functio shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>The ID of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given DeviceIndex does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Invokes SMI activation from either the preboot or runtime environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeiServices</td><td>General purpose services available to every PEIM. </td></tr>
    <tr><td class="paramname">This</td><td>The PEI_SMM_CONTROL_PPI instance. </td></tr>
    <tr><td class="paramname">ArgumentBuffer</td><td>The optional sized data to pass into the protocol activation. </td></tr>
    <tr><td class="paramname">ArgumentBufferSize</td><td>The optional size of the data. </td></tr>
    <tr><td class="paramname">Periodic</td><td>An optional mechanism to periodically repeat activation. </td></tr>
    <tr><td class="paramname">ActivationInterval</td><td>An optional parameter to repeat at this period one time or, if the Periodic Boolean is set, periodically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMI/PMI has been engendered. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The timing is unsupported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The activation period is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>The SMM base service has not been initialized.</td></tr>
  </table>
  </dd>
</dl>
<p>Clears any system state that was created in response to the Active call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeiServices</td><td>General purpose services available to every PEIM. </td></tr>
    <tr><td class="paramname">This</td><td>The PEI_SMM_CONTROL_PPI instance. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Optional parameter to repeat at this period one time or, if the Periodic Boolean is set, periodically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMI/PMI has been engendered. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The source could not be cleared. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The service did not support the Periodic input argument.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called by SmmChildDispatcher module to report a new SMI handler is registered, to SmmCore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>The protocol instance </td></tr>
    <tr><td class="paramname">HandlerGuid</td><td>The GUID to identify the type of the handler. For the SmmChildDispatch protocol, the HandlerGuid must be the GUID of SmmChildDispatch protocol. </td></tr>
    <tr><td class="paramname">Handler</td><td>The SMI handler. </td></tr>
    <tr><td class="paramname">CallerAddress</td><td>The address of the module who registers the SMI handler. </td></tr>
    <tr><td class="paramname">Context</td><td>The context of the SMI handler. For the SmmChildDispatch protocol, the Context must match the one defined for SmmChildDispatch protocol. </td></tr>
    <tr><td class="paramname">ContextSize</td><td>The size of the context in bytes. For the SmmChildDispatch protocol, the Context must match the one defined for SmmChildDispatch protocol.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The information is recorded. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is no enough resource to record the information.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called by SmmChildDispatcher module to report an existing SMI handler is unregistered, to SmmCore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>The protocol instance </td></tr>
    <tr><td class="paramname">HandlerGuid</td><td>The GUID to identify the type of the handler. For the SmmChildDispatch protocol, the HandlerGuid must be the GUID of SmmChildDispatch protocol. </td></tr>
    <tr><td class="paramname">Handler</td><td>The SMI handler. </td></tr>
    <tr><td class="paramname">Context</td><td>The context of the SMI handler. If it is NOT NULL, it will be used to check what is registered. </td></tr>
    <tr><td class="paramname">ContextSize</td><td>The size of the context in bytes. If Context is NOT NULL, it will be used to check what is registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The original record is removed. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There is no record for the HandlerGuid and handler.</td></tr>
  </table>
  </dd>
</dl>
<p>Get memory profile recording state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EDKII_MEMORY_PROFILE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RecordingState</td><td>Recording state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EFI_SUCCESS Memory profile recording state is returned. </dd>
<dd>
EFI_UNSUPPORTED Memory profile is unsupported. </dd>
<dd>
EFI_INVALID_PARAMETER RecordingState is NULL.</dd></dl>
<p>Set memory profile recording state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EDKII_MEMORY_PROFILE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RecordingState</td><td>Recording state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EFI_SUCCESS Set memory profile recording state successfully. </dd>
<dd>
EFI_UNSUPPORTED Memory profile is unsupported.</dd></dl>
<p>Record memory profile of multilevel caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EDKII_MEMORY_PROFILE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallerAddress</td><td>Address of caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Action</td><td>Memory profile action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MemoryType</td><td>Memory type. EfiMaxMemoryType means the MemoryType is unknown. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Buffer address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Size</td><td>Buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ActionString</td><td>String for memory profile action. Only needed for user defined allocate action.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EFI_SUCCESS Memory profile is updated. </dd>
<dd>
EFI_UNSUPPORTED Memory profile is unsupported, or memory profile for the image is not required, or memory profile for the memory type is not required. </dd>
<dd>
EFI_ACCESS_DENIED It is during memory profile data getting. </dd>
<dd>
EFI_ABORTED Memory profile recording is not enabled. </dd>
<dd>
EFI_OUT_OF_RESOURCES No enough resource to update memory profile for allocate action. </dd>
<dd>
EFI_NOT_FOUND No matched allocate info found for free action.</dd></dl>
<p>Register SetVariable check handler. Variable driver will call the handler to do check before really setting the variable into variable storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Handler</td><td>Pointer to the check handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SetVariable check handler was registered successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Handler is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>EFI_END_OF_DXE_EVENT_GROUP_GUID or EFI_EVENT_GROUP_READY_TO_BOOT has already been signaled. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough resource for the SetVariable check handler register request. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This interface is not implemented. For example, it is unsupported in VarCheck protocol if both VarCheck and SmmVarCheck protocols are present.</td></tr>
  </table>
  </dd>
</dl>
<p>Variable property set. Variable driver will do check according to the VariableProperty before really setting the variable into variable storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Name</td><td>Pointer to the variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>Pointer to the vendor GUID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableProperty</td><td>Pointer to the input variable property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The property of variable specified by the Name and Guid was set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Name, Guid or VariableProperty is NULL, or Name is an empty string, or the fields of VariableProperty are not valid. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>EFI_END_OF_DXE_EVENT_GROUP_GUID or EFI_EVENT_GROUP_READY_TO_BOOT has already been signaled. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough resource for the variable property set request.</td></tr>
  </table>
  </dd>
</dl>
<p>Variable property get.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Name</td><td>Pointer to the variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>Pointer to the vendor GUID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VariableProperty</td><td>Pointer to the output variable property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The property of variable specified by the Name and Guid was got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Name, Guid or VariableProperty is NULL, or Name is an empty string. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The property of variable specified by the Name and Guid was not found.</td></tr>
  </table>
  </dd>
</dl>
<p>This service enables submitting commands via Ipmi.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>This point for IPMI_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NetFunction</td><td>Net function of the command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Command</td><td>IPMI Command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestData</td><td>Command Request Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestDataSize</td><td>Size of Command Request Data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ResponseData</td><td>Command Response Data. The completion code is the first byte of response data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ResponseDataSize</td><td>Size of Command Response Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The command byte stream was successfully submit to the device and a response was successfully received. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The command was not successfully sent to the device or a response was not successfully received from the device. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Ipmi Device is not ready for Ipmi command access. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Ipmi Device hardware error. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>The command time out. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The command was not successfully sent to the device. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The resource allcation is out of resource or data size error.</td></tr>
  </table>
  </dd>
</dl>
<p>Execute UIC command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to driver interface produced by the UFS controller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">UicCommand</td><td>Descriptor of the command that will be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Command executed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This or UicCommand is NULL. </td></tr>
    <tr><td class="paramname">Others</td><td>Command failed to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Allows platform protocol to override host controller information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>Handle of the UFS controller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">HcInfo</td><td>Pointer <a class="el" href="struct_e_d_k_i_i___u_f_s___h_c___i_n_f_o.html">EDKII_UFS_HC_INFO</a> associated with host controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HcInfo is NULL. </td></tr>
    <tr><td class="paramname">Others</td><td>Function failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function for platform driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>Handle of the UFS controller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallbackPhase</td><td>Specifies when the platform protocol is called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CallbackData</td><td>Data specific to the callback phase. For PreHce and PostHce - EDKII_UFS_HC_DRIVER_INTERFACE. For PreLinkStartup and PostLinkStartup - EDKII_UFS_HC_DRIVER_INTERFACE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Override function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CallbackPhase is invalid or CallbackData is NULL when phase expects valid data. </td></tr>
    <tr><td class="paramname">Others</td><td>Function failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a supported PE/COFF image with the emulator. After this call completes successfully, the PE/COFF image may be started as usual, and it is the responsibility of the emulator implementation that any branch into the code section of the image (including returns from functions called from the foreign code) is executed as if it were running on the machine type it was built for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>This pointer for EDKII_PECOFF_IMAGE_EMULATOR_PROTOCOL structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ImageBase</td><td>The base address in memory of the PE/COFF image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ImageSize</td><td>The size in memory of the PE/COFF image </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EntryPoint</td><td>The entry point of the PE/COFF image. Passed by reference so that the emulator may modify it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The image was registered with the emulator and can be started as usual. </td></tr>
    <tr><td class="paramname">other</td><td>The image could not be registered.</td></tr>
  </table>
  </dd>
</dl>
<p>If the PE/COFF machine type or image type are not supported by the emulator, then ASSERT().</p>
<p>Unregister a PE/COFF image that has been registered with the emulator. This should be done before the image is unloaded from memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>This pointer for EDKII_PECOFF_IMAGE_EMULATOR_PROTOCOL structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ImageBase</td><td>The base address in memory of the PE/COFF image</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The image was unregistered with the emulator. </td></tr>
    <tr><td class="paramname">other</td><td>Image could not be unloaded.</td></tr>
  </table>
  </dd>
</dl>
<p>Trig Exception on EBC VM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_SIMPLE_DEBUGGER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VmPtr</td><td>A pointer to a VM context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ExceptionType</td><td>Exception to be trigged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>No support for it. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Exception is trigged.</td></tr>
  </table>
  </dd>
</dl>
<p>This interface allows you to configure the EBC debug support driver. For example, turn on or off saving and printing of delta VM even if called. Or to even disable the entire interface, in which case all functions become no-ops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_SIMPLE_DEBUGGER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigId</td><td>ID to be configured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigValue</td><td>Value to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>No support for it. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Configure EBC debug.</td></tr>
  </table>
  </dd>
</dl>
<p>Choose a file in the specified directory.</p>
<p>If user input NULL for the RootDirectory, will choose file in the system.</p>
<p>If user input *File != NULL, function will return the allocate device path info for the choosed file, caller has to free the memory after use it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RootDirectory</td><td>Pointer to the root directory. </td></tr>
    <tr><td class="paramname">FileType</td><td>The file type need to choose. </td></tr>
    <tr><td class="paramname">ChooseHandler</td><td>Function pointer to the extra task need to do after choose one file. </td></tr>
    <tr><td class="paramname">File</td><td>Return the device path for the last time chosed file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCESS</td><td>Choose the file success. </td></tr>
    <tr><td class="paramname">Other</td><td>errors Choose the file failed.</td></tr>
  </table>
  </dd>
</dl>
<p>Execute the action requested by the Action parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Action</td><td>Execute the request action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DefaultId</td><td>The default Id info when need to load default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Execute the request action succss.</td></tr>
  </table>
  </dd>
</dl>
<p>Override function for SDHCI capability bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>The EFI_HANDLE of the controller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>The 0 based slot index. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">SdMmcHcSlotCapability</td><td>The SDHCI capability structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BaseClkFreq</td><td>The base clock frequency value that optionally can be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The override function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified controller or slot does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SdMmcHcSlotCapability is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Override function for SDHCI controller operations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>The EFI_HANDLE of the controller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>The 0 based slot index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PhaseType</td><td>The type of operation and whether the hook is invoked right before (pre) or right after (post) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PhaseData</td><td>The pointer to a phase-specific data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The override function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified controller or slot does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PhaseType is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Mark a variable that will become read-only after leaving the DXE phase of execution. Write request coming from SMM environment through EFI_SMM_VARIABLE_PROTOCOL is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EDKII_VARIABLE_LOCK_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableName</td><td>A pointer to the variable name that will be made read-only subsequently. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VendorGuid</td><td>A pointer to the vendor GUID that will be made read-only subsequently.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The variable specified by the VariableName and the VendorGuid was marked as pending to be read-only. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>VariableName or VendorGuid is NULL. Or VariableName is an empty string. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>EFI_END_OF_DXE_EVENT_GROUP_GUID or EFI_EVENT_GROUP_READY_TO_BOOT has already been signaled. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough resource to hold the lock request.</td></tr>
  </table>
  </dd>
</dl>
<p>Configure what scope the hot key will impact. All hot keys have the same scope. The mixed hot keys with the different level are not supported. If no scope is set, the default scope will be FormSet level. After all registered hot keys are removed, previous Scope can reset to another level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scope</td><td>Scope level to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Scope is set correctly. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Scope is not the valid value specified in BROWSER_SETTING_SCOPE. </td></tr>
    <tr><td class="paramname">EFI_UNSPPORTED</td><td>Scope level is different from current one that the registered hot keys have.</td></tr>
  </table>
  </dd>
</dl>
<p>Register the hot key with its browser action, or unregistered the hot key. If the action value is zero, the hot key will be unregistered if it has been registered. If the same hot key has been registered, the new action and help string will override the previous ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyData</td><td>A pointer to a buffer that describes the keystroke information for the hot key. Its type is EFI_INPUT_KEY to be supported by all ConsoleIn devices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Action</td><td>Action value that describes what action will be trigged when the hot key is pressed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DefaultId</td><td>Specifies the type of defaults to retrieve, which is only for DEFAULT action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HelpString</td><td>Help string that describes the hot key information. Its value may be NULL for the unregistered hot key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Hot key is registered or unregistered. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyData is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Given a pointer to a new VM context, execute one or more instructions. This function is only used for test purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_VM_TEST_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VmPtr</td><td>A pointer to a VM context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">InstructionCount</td><td>A pointer to a UINTN value holding the number of instructions to execute. If it holds value of 0, then the instruction to be executed is 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>At least one of the opcodes is not supported. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>All of the instructions are executed successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert AsmText to the instruction. This function is only used for test purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_VM_TEST_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AsmText</td><td>A pointer to EBC ASM text code. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Buffer to store the instruction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BufferLen</td><td>Size of buffer that is required to store data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This functionality is unsupported. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully convert AsmText to the instruction.</td></tr>
  </table>
  </dd>
</dl>
<p>Dump the executed instruction. This function is only used for test purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_VM_TEST_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AsmText</td><td>Contain the disasm text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Buffer to store the instruction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BufferLen</td><td>Size of buffer that is required to store data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This functionality is unsupported. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully dump the executed instruction.</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Password check. Passwork may be encrypted by driver that requires the specific check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Form</td><td>Form where Password Statement is in. </td></tr>
    <tr><td class="paramname">Statement</td><td>Password statement </td></tr>
    <tr><td class="paramname">PasswordString</td><td>Password string to be checked. It may be NULL. NULL means to restore password. "" string can be used to checked whether old password does exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Status of Password check.</dd></dl>
<p>Display one form, and return user input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FormData</td><td>Form Data to be shown. </td></tr>
    <tr><td class="paramname">UserInputData</td><td>User input data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Form Data is shown, and user input is got. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a172447eace216767e4763f5c1fdf7ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EFI_GUID gEdkiiNonDiscoverableDeviceProtocolGuid</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_54cb27adfbe3c9131eabcdf8b02d1207.html">MdeModulePkg</a></li><li class="navelem"><a class="el" href="dir_18ec75d2ad33879c083782e393e99453.html">Include</a></li><li class="navelem"><a class="el" href="dir_c94902c572d0fa9f9eb7e8f9bbb107ef.html">Protocol</a></li><li class="navelem"><a class="el" href="_protocol_2_non_discoverable_device_8h.html">NonDiscoverableDevice.h</a></li>
    <li class="footer">Generated on Sun Dec 5 2021 00:24:08 for MdeModulePkg[all] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
