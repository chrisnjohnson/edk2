<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MdeModulePkg[all]: MdeModulePkg/Include/Library/SecurityManagementLib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MdeModulePkg[all]
   &#160;<span id="projectnumber">0.98</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_security_management_lib_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SecurityManagementLib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad7c17f43c5ce40572b6e32ed14f09df3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#ad7c17f43c5ce40572b6e32ed14f09df3">EFI_AUTH_OPERATION_NONE</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ad7c17f43c5ce40572b6e32ed14f09df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5897ecbbb9f0bf27a92fb92c95d1baff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a5897ecbbb9f0bf27a92fb92c95d1baff">EFI_AUTH_OPERATION_VERIFY_IMAGE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a5897ecbbb9f0bf27a92fb92c95d1baff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab975aca23912cacce3932e3f4ba3dc75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#ab975aca23912cacce3932e3f4ba3dc75">EFI_AUTH_OPERATION_DEFER_IMAGE_LOAD</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ab975aca23912cacce3932e3f4ba3dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7d5f78530f6b72ccfa7e426cc9f793"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a4f7d5f78530f6b72ccfa7e426cc9f793">EFI_AUTH_OPERATION_MEASURE_IMAGE</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a4f7d5f78530f6b72ccfa7e426cc9f793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a566dc8e7f05ea8ddec7110365de6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a33a566dc8e7f05ea8ddec7110365de6a">EFI_AUTH_OPERATION_CONNECT_POLICY</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:a33a566dc8e7f05ea8ddec7110365de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad378e5f310349e0cb97619320c904280"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#ad378e5f310349e0cb97619320c904280">EFI_AUTH_OPERATION_AUTHENTICATION_STATE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:ad378e5f310349e0cb97619320c904280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329aae7249a3ea711ad3b6c1eb8f233a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a329aae7249a3ea711ad3b6c1eb8f233a">EFI_AUTH_OPERATION_IMAGE_REQUIRED</a>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="separator:a329aae7249a3ea711ad3b6c1eb8f233a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0645b6ed4d0b609299c95f70ec8651f2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a>(EFIAPI *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a0645b6ed4d0b609299c95f70ec8651f2">SECURITY_FILE_AUTHENTICATION_STATE_HANDLER</a> )(IN OUT <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a> AuthenticationStatus, IN CONST EFI_DEVICE_PATH_PROTOCOL *<a class="el" href="_security_management_lib_8h.html#a638995d4ddeb76c172a977359938e72e">File</a>, IN <a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> *<a class="el" href="_security_management_lib_8h.html#ab937e49f0ef94889fd690594bda378a4">FileBuffer</a>, IN <a class="el" href="_display_protocol_8h.html#a2181335bcdc6b2c3b39d1fc778d77a2e">UINTN</a> <a class="el" href="_security_management_lib_8h.html#a595720cf3b52a0f71a29556b658d5b77">FileSize</a>)</td></tr>
<tr class="separator:a0645b6ed4d0b609299c95f70ec8651f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638995d4ddeb76c172a977359938e72e"><td class="memItemLeft" align="right" valign="top">typedef IN CONST <br class="typebreak"/>
EFI_DEVICE_PATH_PROTOCOL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a638995d4ddeb76c172a977359938e72e">File</a></td></tr>
<tr class="separator:a638995d4ddeb76c172a977359938e72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab937e49f0ef94889fd690594bda378a4"><td class="memItemLeft" align="right" valign="top">typedef IN CONST <br class="typebreak"/>
EFI_DEVICE_PATH_PROTOCOL IN <br class="typebreak"/>
<a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#ab937e49f0ef94889fd690594bda378a4">FileBuffer</a></td></tr>
<tr class="separator:ab937e49f0ef94889fd690594bda378a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595720cf3b52a0f71a29556b658d5b77"><td class="memItemLeft" align="right" valign="top">typedef IN CONST <br class="typebreak"/>
EFI_DEVICE_PATH_PROTOCOL IN <br class="typebreak"/>
<a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> IN <a class="el" href="_display_protocol_8h.html#a2181335bcdc6b2c3b39d1fc778d77a2e">UINTN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a595720cf3b52a0f71a29556b658d5b77">FileSize</a></td></tr>
<tr class="separator:a595720cf3b52a0f71a29556b658d5b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f9cb3ee90968d53417c3323730a353"><td class="memItemLeft" align="right" valign="top">typedef IN CONST <br class="typebreak"/>
EFI_DEVICE_PATH_PROTOCOL IN <br class="typebreak"/>
<a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> IN <a class="el" href="_display_protocol_8h.html#a2181335bcdc6b2c3b39d1fc778d77a2e">UINTN</a> IN <a class="el" href="_form_browser_ex2_8h.html#a314372a42b06efd845536fb2058e3345">BOOLEAN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#ae5f9cb3ee90968d53417c3323730a353">BootPolicy</a></td></tr>
<tr class="separator:ae5f9cb3ee90968d53417c3323730a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a59f804fc6e880cc9d030e55c1f9e5bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a> EFIAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a59f804fc6e880cc9d030e55c1f9e5bb6">RegisterSecurityHandler</a> (IN <a class="el" href="_security_management_lib_8h.html#a0645b6ed4d0b609299c95f70ec8651f2">SECURITY_FILE_AUTHENTICATION_STATE_HANDLER</a> SecurityHandler, IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a> AuthenticationOperation)</td></tr>
<tr class="separator:a59f804fc6e880cc9d030e55c1f9e5bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5b8616689078d6d0f678420b49a03e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a> EFIAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#afb5b8616689078d6d0f678420b49a03e">ExecuteSecurityHandlers</a> (IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a> AuthenticationStatus, IN CONST EFI_DEVICE_PATH_PROTOCOL *FilePath)</td></tr>
<tr class="separator:afb5b8616689078d6d0f678420b49a03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95757ea1af0016adfad184a9f52cce24"><td class="memItemLeft" align="right" valign="top">typedef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a95757ea1af0016adfad184a9f52cce24">EFI_STATUS</a> (EFIAPI *SECURITY2_FILE_AUTHENTICATION_HANDLER)(IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a> AuthenticationStatus</td></tr>
<tr class="separator:a95757ea1af0016adfad184a9f52cce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46e52dcae9b9eb03951aec7c61f5991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a> EFIAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#ae46e52dcae9b9eb03951aec7c61f5991">RegisterSecurity2Handler</a> (IN SECURITY2_FILE_AUTHENTICATION_HANDLER Security2Handler, IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a> AuthenticationOperation)</td></tr>
<tr class="separator:ae46e52dcae9b9eb03951aec7c61f5991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9475934851a7c7264f2d4fd6382d1f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a> EFIAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_security_management_lib_8h.html#a9475934851a7c7264f2d4fd6382d1f26">ExecuteSecurity2Handlers</a> (IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a> AuthenticationOperation, IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a> AuthenticationStatus, IN CONST EFI_DEVICE_PATH_PROTOCOL *<a class="el" href="_security_management_lib_8h.html#a638995d4ddeb76c172a977359938e72e">File</a>, IN <a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> *<a class="el" href="_security_management_lib_8h.html#ab937e49f0ef94889fd690594bda378a4">FileBuffer</a>, IN <a class="el" href="_display_protocol_8h.html#a2181335bcdc6b2c3b39d1fc778d77a2e">UINTN</a> <a class="el" href="_security_management_lib_8h.html#a595720cf3b52a0f71a29556b658d5b77">FileSize</a>, IN <a class="el" href="_form_browser_ex2_8h.html#a314372a42b06efd845536fb2058e3345">BOOLEAN</a> <a class="el" href="_security_management_lib_8h.html#ae5f9cb3ee90968d53417c3323730a353">BootPolicy</a>)</td></tr>
<tr class="separator:a9475934851a7c7264f2d4fd6382d1f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library class defines a set of interfaces to abstract the policy of security measurement by managing the different security measurement services. The library instances can be implemented according to the different security policy.</p>
<p>Copyright (c) 2009 - 2018, Intel Corporation. All rights reserved.<br/>
 SPDX-License-Identifier: BSD-2-Clause-Patent </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ad378e5f310349e0cb97619320c904280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_AUTH_OPERATION_AUTHENTICATION_STATE&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a33a566dc8e7f05ea8ddec7110365de6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_AUTH_OPERATION_CONNECT_POLICY&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab975aca23912cacce3932e3f4ba3dc75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_AUTH_OPERATION_DEFER_IMAGE_LOAD&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a329aae7249a3ea711ad3b6c1eb8f233a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_AUTH_OPERATION_IMAGE_REQUIRED&#160;&#160;&#160;0x80000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Image buffer is required by the security handler. </p>

</div>
</div>
<a class="anchor" id="a4f7d5f78530f6b72ccfa7e426cc9f793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_AUTH_OPERATION_MEASURE_IMAGE&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7c17f43c5ce40572b6e32ed14f09df3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_AUTH_OPERATION_NONE&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5897ecbbb9f0bf27a92fb92c95d1baff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_AUTH_OPERATION_VERIFY_IMAGE&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ae5f9cb3ee90968d53417c3323730a353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IN CONST EFI_DEVICE_PATH_PROTOCOL IN <a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> IN <a class="el" href="_display_protocol_8h.html#a2181335bcdc6b2c3b39d1fc778d77a2e">UINTN</a> IN <a class="el" href="_form_browser_ex2_8h.html#a314372a42b06efd845536fb2058e3345">BOOLEAN</a> <a class="el" href="_security_management_lib_8h.html#ae5f9cb3ee90968d53417c3323730a353">BootPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a638995d4ddeb76c172a977359938e72e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IN CONST EFI_DEVICE_PATH_PROTOCOL* <a class="el" href="_security_management_lib_8h.html#a638995d4ddeb76c172a977359938e72e">File</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab937e49f0ef94889fd690594bda378a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IN CONST EFI_DEVICE_PATH_PROTOCOL IN <a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a>* <a class="el" href="_security_management_lib_8h.html#ab937e49f0ef94889fd690594bda378a4">FileBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a595720cf3b52a0f71a29556b658d5b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IN CONST EFI_DEVICE_PATH_PROTOCOL IN <a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> IN <a class="el" href="_display_protocol_8h.html#a2181335bcdc6b2c3b39d1fc778d77a2e">UINTN</a> <a class="el" href="_security_management_lib_8h.html#a595720cf3b52a0f71a29556b658d5b77">FileSize</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0645b6ed4d0b609299c95f70ec8651f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a>(EFIAPI * SECURITY_FILE_AUTHENTICATION_STATE_HANDLER)(IN OUT <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a> AuthenticationStatus, IN CONST EFI_DEVICE_PATH_PROTOCOL *<a class="el" href="_security_management_lib_8h.html#a638995d4ddeb76c172a977359938e72e">File</a>, IN <a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> *<a class="el" href="_security_management_lib_8h.html#ab937e49f0ef94889fd690594bda378a4">FileBuffer</a>, IN <a class="el" href="_display_protocol_8h.html#a2181335bcdc6b2c3b39d1fc778d77a2e">UINTN</a> <a class="el" href="_security_management_lib_8h.html#a595720cf3b52a0f71a29556b658d5b77">FileSize</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The security handler is used to abstract platform-specific policy from the DXE core response to an attempt to use a file that returns a given status for the authentication check from the section extraction protocol.</p>
<p>The possible responses in a given SAP implementation may include locking flash upon failure to authenticate, attestation logging for all signed drivers, and other exception operations. The File parameter allows for possible logging within the SAP of the driver.</p>
<p>If File is NULL, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file specified by File with an authentication status specified by AuthenticationStatus is safe for the DXE Core to use, then EFI_SUCCESS is returned.</p>
<p>If the file specified by File with an authentication status specified by AuthenticationStatus is not safe for the DXE Core to use under any circumstances, then EFI_ACCESS_DENIED is returned.</p>
<p>If the file specified by File with an authentication status specified by AuthenticationStatus is not safe for the DXE Core to use at the time, but it might be possible to use it at a future time, then EFI_SECURITY_VIOLATION is returned.</p>
<p>FileBuffer will be NULL and FileSize will be 0 if the handler being called did not set EFI_AUTH_OPERATION_IMAGE_REQUIRED when it was registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthenticationStatus</td><td>The authentication status returned from the security measurement services for the input file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">File</td><td>The pointer to the device path of the file that is being dispatched. This will optionally be used for logging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileBuffer</td><td>The file buffer matches the input file device path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileSize</td><td>The size of File buffer matches the input file device path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The file specified by File did authenticate, and the platform policy dictates that the DXE Core may use File. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The file is NULL. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The file specified by File did not authenticate, and the platform policy dictates that File should be placed in the untrusted state. A file may be promoted from the untrusted to the trusted state at a future time with a call to the Trust() DXE Service. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file specified by File did not authenticate, and the platform policy dictates that File should not be used for any purpose. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a95757ea1af0016adfad184a9f52cce24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EFI_STATUS </td>
          <td>(</td>
          <td class="paramtype">EFIAPI *&#160;</td>
          <td class="paramname"><em>FORM_DISPLAY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The security handler is used to abstracts security-specific functions from the DXE Foundation of UEFI Image Verification, Trusted Computing Group (TCG) measured boot, User Identity policy for image loading and consoles, and for purposes of handling GUIDed section encapsulations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthenticationStatus</td><td>The authentication status for the input file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">File</td><td>The pointer to the device path of the file that is being dispatched. This will optionally be used for logging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileBuffer</td><td>A pointer to the buffer with the UEFI file image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileSize</td><td>The size of File buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BootPolicy</td><td>A boot policy that was used to call LoadImage() UEFI service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The file specified by DevicePath and non-NULL FileBuffer did authenticate, and the platform policy dictates that the DXE Foundation may use the file. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path specified by NULL device path DevicePath and non-NULL FileBuffer did authenticate, and the platform policy dictates that the DXE Foundation may execute the image in FileBuffer. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>FileBuffer is NULL and current user has permission to start UEFI device drivers on the device path specified by DevicePath. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The file specified by DevicePath and FileBuffer did not authenticate, and the platform policy dictates that the file should be placed in the untrusted state. The image has been added to the file execution table. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file specified by File and FileBuffer did not authenticate, and the platform policy dictates that the DXE Foundation may not use File. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>FileBuffer is NULL and the user has no permission to start UEFI device drivers on the device path specified by DevicePath. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>FileBuffer is not NULL and the user has no permission to load drivers from the device path specified by DevicePath. The image has been added into the list of the deferred images.</td></tr>
  </table>
  </dd>
</dl>
<p>Finds next variable in storage blocks of volatile and non-volatile storage areas.</p>
<p>This code finds next variable in storage blocks of volatile and non-volatile storage areas. If VariableName is an empty string, then we just return the first qualified variable without comparing VariableName and VendorGuid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableName</td><td>Name of the variable to be found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VendorGuid</td><td>Variable vendor GUID to be found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AuthVariableInfo</td><td>Pointer to <a class="el" href="struct_a_u_t_h___v_a_r_i_a_b_l_e___i_n_f_o.html">AUTH_VARIABLE_INFO</a> structure for output of the next variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>If VariableName is not an empty string, while VendorGuid is NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Variable successfully found. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Variable not found</td></tr>
  </table>
  </dd>
</dl>
<p>Update the variable region with Variable information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthVariableInfo</td><td>Pointer <a class="el" href="struct_a_u_t_h___v_a_r_i_a_b_l_e___i_n_f_o.html">AUTH_VARIABLE_INFO</a> structure for input of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The update operation is success. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Invalid parameter. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>Variable is write-protected. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough resource.</td></tr>
  </table>
  </dd>
</dl>
<p>Get scratch buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScratchBufferSize</td><td>Scratch buffer size. If input size is greater than the maximum supported buffer size, this value contains the maximum supported buffer size as output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ScratchBuffer</td><td>Pointer to scratch buffer address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Get scratch buffer successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>If input size is greater than the maximum supported buffer size.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends an NVM Express Command Packet to an NVM Express controller or namespace. This function only supports blocking execution of the command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NamespaceId</td><td>Is a 32 bit Namespace ID to which the Nvm Express command packet will be sent. A Value of 0 denotes the NVM Express controller, a Value of all 0FFh in the namespace ID specifies that the command packet should be sent to all valid namespaces. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Packet</td><td>A pointer to the EDKII PEI NVM Express PassThru Command Packet to send to the NVMe namespace specified by NamespaceId.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The EDKII PEI NVM Express Command Packet was sent by the host. TransferLength bytes were transferred to, or from DataBuffer. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The EDKII PEI NVM Express Command Packet could not be sent because the controller is not ready. The caller may retry again later. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A device error occurred while attempting to send the EDKII PEI NVM Express Command Packet. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Namespace, or the contents of EDKII_PEI_NVM_EXPRESS_PASS_THRU_COMMAND_PACKET are invalid. The EDKII PEI NVM Express Command Packet was not sent, so no additional status information is available. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The command described by the EDKII PEI NVM Express Command Packet is not supported by the host adapter. The EDKII PEI NVM Express Command Packet was not sent, so no additional status information is available. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the EDKII PEI NVM Express Command Packet to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the device path of NVM Express host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerId</td><td>The ID of the NVM Express host controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of NVM Express host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified NVM Express host controller not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the device path of ATA AHCI host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerId</td><td>The ID of the ATA AHCI host controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of ATA AHCI host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified ATA AHCI host controller not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Used to retrieve the list of legal port numbers for ATA devices on an ATA controller. These can either be the list of ports where ATA devices are actually present or the list of legal port numbers for the ATA controller. Regardless, the caller of this function must probe the port number returned to see if an ATA device is actually present at that location on the ATA controller.</p>
<p>The GetNextPort() function retrieves the port number on an ATA controller. If on input Port is 0xFFFF, then the port number of the first port on the ATA controller is returned in Port and EFI_SUCCESS is returned.</p>
<p>If Port is a port number that was returned on a previous call to GetNextPort(), then the port number of the next port on the ATA controller is returned in Port, and EFI_SUCCESS is returned. If Port is not 0xFFFF and Port was not returned on a previous call to GetNextPort(), then EFI_INVALID_PARAMETER is returned.</p>
<p>If Port is the port number of the last port on the ATA controller, then EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Port</td><td>On input, a pointer to the port number on the ATA controller. On output, a pointer to the next port number on the ATA controller. An input value of 0xFFFF retrieves the first port number on the ATA controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The next port number on the ATA controller was returned in Port. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There are no more ports on this ATA controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Port is not 0xFFFF and Port was not returned on a previous call to GetNextPort().</td></tr>
  </table>
  </dd>
</dl>
<p>Used to retrieve the list of legal port multiplier port numbers for ATA devices on a port of an ATA controller. These can either be the list of port multiplier ports where ATA devices are actually present on port or the list of legal port multiplier ports on that port. Regardless, the caller of this function must probe the port number and port multiplier port number returned to see if an ATA device is actually present.</p>
<p>The GetNextDevice() function retrieves the port multiplier port number of an ATA device present on a port of an ATA controller.</p>
<p>If PortMultiplierPort points to a port multiplier port number value that was returned on a previous call to GetNextDevice(), then the port multiplier port number of the next ATA device on the port of the ATA controller is returned in PortMultiplierPort, and EFI_SUCCESS is returned.</p>
<p>If PortMultiplierPort points to 0xFFFF, then the port multiplier port number of the first ATA device on port of the ATA controller is returned in PortMultiplierPort and EFI_SUCCESS is returned.</p>
<p>If PortMultiplierPort is not 0xFFFF and the value pointed to by PortMultiplierPort was not returned on a previous call to GetNextDevice(), then EFI_INVALID_PARAMETER is returned.</p>
<p>If PortMultiplierPort is the port multiplier port number of the last ATA device on the port of the ATA controller, then EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>The port number present on the ATA controller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PortMultiplierPort</td><td>On input, a pointer to the port multiplier port number of an ATA device present on the ATA controller. If on input a PortMultiplierPort of 0xFFFF is specified, then the port multiplier port number of the first ATA device is returned. On output, a pointer to the port multiplier port number of the next ATA device present on an ATA controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The port multiplier port number of the next ATA device on the port of the ATA controller was returned in PortMultiplierPort. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There are no more ATA devices on this port of the ATA controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PortMultiplierPort is not 0xFFFF, and PortMultiplierPort was not returned on a previous call to GetNextDevice().</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the device path information of the underlying ATA host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of the underlying ATA host controller. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path of the ATA host controller has been successfully returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePathLength or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Not enough resource to return the device path.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the device path of a specific storage security device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>Specifies the storage security device to which the function wants to talk. Because the driver that implements Storage Security Command PPIs will manage multiple storage devices, the PPIs that want to talk to a single device must specify the device index that was assigned during the enumeration process. This index is a number from one to NumberofDevices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePathLength</td><td>The length of the device path in bytes specified by DevicePath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>The device path of storage security device. This field re-uses EFI Device Path Protocol as defined by Section 10.2 EFI Device Path Protocol of UEFI 2.7 Specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation succeeds. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePathLength or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified storage security device not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Send a security protocol command to a device that receives data and/or the result of one or more commands sent by SendData.</p>
<p>The ReceiveData function sends a security protocol command to the given DeviceIndex. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. The function returns the data from the security protocol command in PayloadBuffer.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL IN command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED RECEIVE commands defined in ATA8-ACS if PayloadBufferSize is non-zero.</p>
<p>If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBufferSize is too small to store the available data from the security protocol command, the function shall copy PayloadBufferSize bytes into the PayloadBuffer and return EFI_WARN_BUFFER_TOO_SMALL.</p>
<p>If PayloadBuffer or PayloadTransferSize is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given DeviceIndex does not support security protocol commands, the function shall return EFI_UNSUPPORTED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the function shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>Specifies the storage security device to which the function wants to talk. Because the driver that implements Storage Security Command PPIs will manage multiple storage devices, the PPIs that want to talk to a single device must specify the device index that was assigned during the enumeration process. This index is a number from one to NumberofDevices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command. The caller is responsible for having either implicit or explicit ownership of the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PayloadTransferSize</td><td>A pointer to a buffer to store the size in bytes of the data written to the payload data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_WARN_BUFFER_TOO_SMALL</td><td>The PayloadBufferSize was too small to store the available data from the device. The PayloadBuffer contains the truncated data. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given DeviceIndex does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer or PayloadTransferSize is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Send a security protocol command to a device.</p>
<p>The SendData function sends a security protocol command containing the payload PayloadBuffer to the given DeviceIndex. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. If the underlying protocol command requires a specific padding for the command payload, the SendData function shall add padding bytes to the command payload to satisfy the padding requirements.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL OUT command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED SEND commands defined in ATA8-ACS if PayloadBufferSize is non-zero. If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBuffer is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given DeviceIndex does not support security protocol commands, the function shall return EFI_UNSUPPORTED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the functio shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceIndex</td><td>The ID of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given DeviceIndex does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Clears any system state that was created in response to the Active call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeiServices</td><td>General purpose services available to every PEIM. </td></tr>
    <tr><td class="paramname">This</td><td>The PEI_SMM_CONTROL_PPI instance. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Optional parameter to repeat at this period one time or, if the Periodic Boolean is set, periodically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMI/PMI has been engendered. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The source could not be cleared. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The service did not support the Periodic input argument.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called by SmmChildDispatcher module to report an existing SMI handler is unregistered, to SmmCore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>The protocol instance </td></tr>
    <tr><td class="paramname">HandlerGuid</td><td>The GUID to identify the type of the handler. For the SmmChildDispatch protocol, the HandlerGuid must be the GUID of SmmChildDispatch protocol. </td></tr>
    <tr><td class="paramname">Handler</td><td>The SMI handler. </td></tr>
    <tr><td class="paramname">Context</td><td>The context of the SMI handler. If it is NOT NULL, it will be used to check what is registered. </td></tr>
    <tr><td class="paramname">ContextSize</td><td>The size of the context in bytes. If Context is NOT NULL, it will be used to check what is registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The original record is removed. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There is no record for the HandlerGuid and handler.</td></tr>
  </table>
  </dd>
</dl>
<p>Set memory profile recording state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EDKII_MEMORY_PROFILE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RecordingState</td><td>Recording state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EFI_SUCCESS Set memory profile recording state successfully. </dd>
<dd>
EFI_UNSUPPORTED Memory profile is unsupported.</dd></dl>
<p>Record memory profile of multilevel caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EDKII_MEMORY_PROFILE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallerAddress</td><td>Address of caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Action</td><td>Memory profile action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MemoryType</td><td>Memory type. EfiMaxMemoryType means the MemoryType is unknown. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Buffer address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Size</td><td>Buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ActionString</td><td>String for memory profile action. Only needed for user defined allocate action.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EFI_SUCCESS Memory profile is updated. </dd>
<dd>
EFI_UNSUPPORTED Memory profile is unsupported, or memory profile for the image is not required, or memory profile for the memory type is not required. </dd>
<dd>
EFI_ACCESS_DENIED It is during memory profile data getting. </dd>
<dd>
EFI_ABORTED Memory profile recording is not enabled. </dd>
<dd>
EFI_OUT_OF_RESOURCES No enough resource to update memory profile for allocate action. </dd>
<dd>
EFI_NOT_FOUND No matched allocate info found for free action.</dd></dl>
<p>Variable property set. Variable driver will do check according to the VariableProperty before really setting the variable into variable storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Name</td><td>Pointer to the variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>Pointer to the vendor GUID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableProperty</td><td>Pointer to the input variable property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The property of variable specified by the Name and Guid was set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Name, Guid or VariableProperty is NULL, or Name is an empty string, or the fields of VariableProperty are not valid. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>EFI_END_OF_DXE_EVENT_GROUP_GUID or EFI_EVENT_GROUP_READY_TO_BOOT has already been signaled. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough resource for the variable property set request.</td></tr>
  </table>
  </dd>
</dl>
<p>Variable property get.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Name</td><td>Pointer to the variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>Pointer to the vendor GUID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VariableProperty</td><td>Pointer to the output variable property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The property of variable specified by the Name and Guid was got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Name, Guid or VariableProperty is NULL, or Name is an empty string. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The property of variable specified by the Name and Guid was not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Allows platform protocol to override host controller information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>Handle of the UFS controller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">HcInfo</td><td>Pointer <a class="el" href="struct_e_d_k_i_i___u_f_s___h_c___i_n_f_o.html">EDKII_UFS_HC_INFO</a> associated with host controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HcInfo is NULL. </td></tr>
    <tr><td class="paramname">Others</td><td>Function failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function for platform driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>Handle of the UFS controller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallbackPhase</td><td>Specifies when the platform protocol is called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CallbackData</td><td>Data specific to the callback phase. For PreHce and PostHce - EDKII_UFS_HC_DRIVER_INTERFACE. For PreLinkStartup and PostLinkStartup - EDKII_UFS_HC_DRIVER_INTERFACE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Override function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CallbackPhase is invalid or CallbackData is NULL when phase expects valid data. </td></tr>
    <tr><td class="paramname">Others</td><td>Function failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Unregister a PE/COFF image that has been registered with the emulator. This should be done before the image is unloaded from memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>This pointer for EDKII_PECOFF_IMAGE_EMULATOR_PROTOCOL structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ImageBase</td><td>The base address in memory of the PE/COFF image</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The image was unregistered with the emulator. </td></tr>
    <tr><td class="paramname">other</td><td>Image could not be unloaded.</td></tr>
  </table>
  </dd>
</dl>
<p>This interface allows you to configure the EBC debug support driver. For example, turn on or off saving and printing of delta VM even if called. Or to even disable the entire interface, in which case all functions become no-ops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_SIMPLE_DEBUGGER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigId</td><td>ID to be configured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigValue</td><td>Value to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>No support for it. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Configure EBC debug.</td></tr>
  </table>
  </dd>
</dl>
<p>Override function for SDHCI controller operations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>The EFI_HANDLE of the controller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>The 0 based slot index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PhaseType</td><td>The type of operation and whether the hook is invoked right before (pre) or right after (post) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PhaseData</td><td>The pointer to a phase-specific data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The override function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified controller or slot does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PhaseType is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Register the hot key with its browser action, or unregistered the hot key. If the action value is zero, the hot key will be unregistered if it has been registered. If the same hot key has been registered, the new action and help string will override the previous ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyData</td><td>A pointer to a buffer that describes the keystroke information for the hot key. Its type is EFI_INPUT_KEY to be supported by all ConsoleIn devices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Action</td><td>Action value that describes what action will be trigged when the hot key is pressed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DefaultId</td><td>Specifies the type of defaults to retrieve, which is only for DEFAULT action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HelpString</td><td>Help string that describes the hot key information. Its value may be NULL for the unregistered hot key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Hot key is registered or unregistered. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyData is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert AsmText to the instruction. This function is only used for test purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_VM_TEST_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AsmText</td><td>A pointer to EBC ASM text code. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Buffer to store the instruction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BufferLen</td><td>Size of buffer that is required to store data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This functionality is unsupported. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully convert AsmText to the instruction.</td></tr>
  </table>
  </dd>
</dl>
<p>Dump the executed instruction. This function is only used for test purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_EBC_VM_TEST_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AsmText</td><td>Contain the disasm text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Buffer to store the instruction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BufferLen</td><td>Size of buffer that is required to store data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This functionality is unsupported. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully dump the executed instruction.</td></tr>
  </table>
  </dd>
</dl>
<p>Display one form, and return user input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FormData</td><td>Form Data to be shown. </td></tr>
    <tr><td class="paramname">UserInputData</td><td>User input data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Form Data is shown, and user input is got. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9475934851a7c7264f2d4fd6382d1f26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a> EFIAPI ExecuteSecurity2Handlers </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a>&#160;</td>
          <td class="paramname"><em>AuthenticationOperation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a>&#160;</td>
          <td class="paramname"><em>AuthenticationStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN CONST EFI_DEVICE_PATH_PROTOCOL *&#160;</td>
          <td class="paramname"><em>File</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="_display_protocol_8h.html#ae9c54c060568c862c771ad80bb63bf48">VOID</a> *&#160;</td>
          <td class="paramname"><em>FileBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="_display_protocol_8h.html#a2181335bcdc6b2c3b39d1fc778d77a2e">UINTN</a>&#160;</td>
          <td class="paramname"><em>FileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="_form_browser_ex2_8h.html#a314372a42b06efd845536fb2058e3345">BOOLEAN</a>&#160;</td>
          <td class="paramname"><em>BootPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute registered handlers based on input AuthenticationOperation until one returns an error and that error is returned.</p>
<p>If none of the handlers return an error, then EFI_SUCCESS is returned. The handlers those satisfy AuthenticationOperation will only be executed. The handlers are executed in same order to their registered order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthenticationOperation</td><td>The operation type specifies which handlers will be executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthenticationStatus</td><td>The authentication status for the input file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">File</td><td>This is a pointer to the device path of the file that is being dispatched. This will optionally be used for logging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileBuffer</td><td>A pointer to the buffer with the UEFI file image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileSize</td><td>The size of File buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BootPolicy</td><td>A boot policy that was used to call LoadImage() UEFI service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The file specified by DevicePath and non-NULL FileBuffer did authenticate, and the platform policy dictates that the DXE Foundation may use the file. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path specified by NULL device path DevicePath and non-NULL FileBuffer did authenticate, and the platform policy dictates that the DXE Foundation may execute the image in FileBuffer. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>FileBuffer is NULL and current user has permission to start UEFI device drivers on the device path specified by DevicePath. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The file specified by DevicePath and FileBuffer did not authenticate, and the platform policy dictates that the file should be placed in the untrusted state. The image has been added to the file execution table. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file specified by File and FileBuffer did not authenticate, and the platform policy dictates that the DXE Foundation may not use File. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>FileBuffer is NULL and the user has no permission to start UEFI device drivers on the device path specified by DevicePath. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>FileBuffer is not NULL and the user has no permission to load drivers from the device path specified by DevicePath. The image has been added into the list of the deferred images. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>File and FileBuffer are both NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb5b8616689078d6d0f678420b49a03e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a> EFIAPI ExecuteSecurityHandlers </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a>&#160;</td>
          <td class="paramname"><em>AuthenticationStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN CONST EFI_DEVICE_PATH_PROTOCOL *&#160;</td>
          <td class="paramname"><em>FilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute registered handlers until one returns an error and that error is returned. If none of the handlers return an error, then EFI_SUCCESS is returned.</p>
<p>Before exectue handler, get the image buffer by file device path if a handler requires the image file. And return the image buffer to each handler when exectue handler.</p>
<p>The handlers are executed in same order to their registered order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthenticationStatus</td><td>This is the authentication type returned from the Section Extraction protocol. See the Section Extraction Protocol Specification for details on this type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FilePath</td><td>This is a pointer to the device path of the file that is being dispatched. This will optionally be used for logging.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The file specified by File authenticated when more than one security handler services were registered, or the file did not authenticate when no security handler service was registered. And the platform policy dictates that the DXE Core may use File. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>File is NULL. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The file specified by File did not authenticate, and the platform policy dictates that File should be placed in the untrusted state. A file may be promoted from the untrusted to the trusted state at a future time with a call to the Trust() DXE Service. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file specified by File did not authenticate, and the platform policy dictates that File should not be used for any purpose. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae46e52dcae9b9eb03951aec7c61f5991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a> EFIAPI RegisterSecurity2Handler </td>
          <td>(</td>
          <td class="paramtype">IN SECURITY2_FILE_AUTHENTICATION_HANDLER&#160;</td>
          <td class="paramname"><em>Security2Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a>&#160;</td>
          <td class="paramname"><em>AuthenticationOperation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register security measurement handler with its operation type. Different handlers with the same operation can all be registered.</p>
<p>If SecurityHandler is NULL, then ASSERT(). If no enough resources available to register new handler, then ASSERT(). If AuthenticationOperation is not recongnized, then ASSERT(). If AuthenticationOperation is EFI_AUTH_OPERATION_NONE, then ASSERT(). If the previous register handler can't be executed before the later register handler, then ASSERT().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Security2Handler</td><td>The security measurement service handler to be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthenticationOperation</td><td>The operation type is specified for the registered handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The handlers were registered successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59f804fc6e880cc9d030e55c1f9e5bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_platform_boot_manager_8h.html#aaed96bd0619ee6b8526d64337e745391">EFI_STATUS</a> EFIAPI RegisterSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="_security_management_lib_8h.html#a0645b6ed4d0b609299c95f70ec8651f2">SECURITY_FILE_AUTHENTICATION_STATE_HANDLER</a>&#160;</td>
          <td class="paramname"><em>SecurityHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="_display_protocol_8h.html#aea9bc1ed0eac0151abf13bb156f5be17">UINT32</a>&#160;</td>
          <td class="paramname"><em>AuthenticationOperation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register security measurement handler with its operation type. Different handlers with the same operation can all be registered.</p>
<p>If SecurityHandler is NULL, then ASSERT(). If no enough resources available to register new handler, then ASSERT(). If AuthenticationOperation is not recongnized, then ASSERT(). If the previous register handler can't be executed before the later register handler, then ASSERT().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SecurityHandler</td><td>The security measurement service handler to be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AuthenticationOperation</td><td>Theoperation type is specified for the registered handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The handlers were registered successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_54cb27adfbe3c9131eabcdf8b02d1207.html">MdeModulePkg</a></li><li class="navelem"><a class="el" href="dir_18ec75d2ad33879c083782e393e99453.html">Include</a></li><li class="navelem"><a class="el" href="dir_c84d4490a6a57540c54360a283dbe1bf.html">Library</a></li><li class="navelem"><a class="el" href="_security_management_lib_8h.html">SecurityManagementLib.h</a></li>
    <li class="footer">Generated on Sun Dec 5 2021 00:43:21 for MdeModulePkg[all] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
