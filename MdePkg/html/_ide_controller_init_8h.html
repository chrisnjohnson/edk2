<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MdePkg[all]: MdePkg/Include/Protocol/IdeControllerInit.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MdePkg[all]
   &#160;<span id="projectnumber">1.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_ide_controller_init_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">IdeControllerInit.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___a_t_a___m_o_d_e.html">EFI_ATA_MODE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___a_t_a___e_x_t_e_n_d_e_d___m_o_d_e.html">EFI_ATA_EXTENDED_MODE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_e_f_i___i_d_e_n_t_i_f_y___d_a_t_a.html">EFI_IDENTIFY_DATA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html">_EFI_IDE_CONTROLLER_INIT_PROTOCOL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6dcac123af4f24d12ec35ce9a81127d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a6dcac123af4f24d12ec35ce9a81127d4">EFI_IDE_CONTROLLER_INIT_PROTOCOL_GUID</a></td></tr>
<tr class="separator:a6dcac123af4f24d12ec35ce9a81127d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1d79b7560a2a66a935ba9035508be9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a0c1d79b7560a2a66a935ba9035508be9">EFI_SATA_AUTO_SPEED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a0c1d79b7560a2a66a935ba9035508be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f22d1aadb92252b79222e684111acb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a73f22d1aadb92252b79222e684111acb">EFI_SATA_GEN1_SPEED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a73f22d1aadb92252b79222e684111acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d9e0a2c68b91808283eb11f568ee20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#af9d9e0a2c68b91808283eb11f568ee20">EFI_SATA_GEN2_SPEED</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:af9d9e0a2c68b91808283eb11f568ee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadc20d57d1e3ef9239b638f5806df26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#acadc20d57d1e3ef9239b638f5806df26">EFI_ATAPI_DEVICE_IDENTIFY_DATA</a>&#160;&#160;&#160;0x8000</td></tr>
<tr class="separator:acadc20d57d1e3ef9239b638f5806df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9e2f103e9b1fb7ef16dd94cb4f87d254"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html">_EFI_IDE_CONTROLLER_INIT_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a></td></tr>
<tr class="separator:a9e2f103e9b1fb7ef16dd94cb4f87d254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cac03bee27a65ccf33a78732d7f9107"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_a_t_a___i_d_e_n_t_i_f_y___d_a_t_a.html">ATA_IDENTIFY_DATA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a6cac03bee27a65ccf33a78732d7f9107">EFI_ATA_IDENTIFY_DATA</a></td></tr>
<tr class="separator:a6cac03bee27a65ccf33a78732d7f9107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d88d05ad6d933082f3a2e84658b364"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_a_t_a_p_i___i_d_e_n_t_i_f_y___d_a_t_a.html">ATAPI_IDENTIFY_DATA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#aa2d88d05ad6d933082f3a2e84658b364">EFI_ATAPI_IDENTIFY_DATA</a></td></tr>
<tr class="separator:aa2d88d05ad6d933082f3a2e84658b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09efcf515e231638d03032d764501b76"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a09efcf515e231638d03032d764501b76">EFI_IDE_CONTROLLER_GET_CHANNEL_INFO</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#a241cb7969626e26a0961a75645528770">BOOLEAN</a> *Enabled, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *MaxDevices)</td></tr>
<tr class="separator:a09efcf515e231638d03032d764501b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bae4c5d6f0a6898deabd83d603136d8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a1bae4c5d6f0a6898deabd83d603136d8">EFI_IDE_CONTROLLER_NOTIFY_PHASE</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9d">EFI_IDE_CONTROLLER_ENUM_PHASE</a> <a class="el" href="_acpi50_8h.html#a0552690222427be671ab64fea764f0c3">Phase</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel)</td></tr>
<tr class="separator:a1bae4c5d6f0a6898deabd83d603136d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc761c8b6dfb7900cdc6950c3147049c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#acc761c8b6dfb7900cdc6950c3147049c">EFI_IDE_CONTROLLER_SUBMIT_DATA</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> <a class="el" href="_i2c_enumerate_8h.html#a72aa8392440f35be3ae18cccf2cccb1a">Device</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="union_e_f_i___i_d_e_n_t_i_f_y___d_a_t_a.html">EFI_IDENTIFY_DATA</a> *IdentifyData)</td></tr>
<tr class="separator:acc761c8b6dfb7900cdc6950c3147049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7256700e7309ed519334c4a4a4bc576"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#ac7256700e7309ed519334c4a4a4bc576">EFI_IDE_CONTROLLER_DISQUALIFY_MODE</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> <a class="el" href="_i2c_enumerate_8h.html#a72aa8392440f35be3ae18cccf2cccb1a">Device</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a> *BadModes)</td></tr>
<tr class="separator:ac7256700e7309ed519334c4a4a4bc576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a90d188c9832eda8b169c3033ca42b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a6a90d188c9832eda8b169c3033ca42b7">EFI_IDE_CONTROLLER_CALCULATE_MODE</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> <a class="el" href="_i2c_enumerate_8h.html#a72aa8392440f35be3ae18cccf2cccb1a">Device</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a> **SupportedModes)</td></tr>
<tr class="separator:a6a90d188c9832eda8b169c3033ca42b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcbcd24d57de97f153839f82fb423c1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a8fcbcd24d57de97f153839f82fb423c1">EFI_IDE_CONTROLLER_SET_TIMING</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> <a class="el" href="_i2c_enumerate_8h.html#a72aa8392440f35be3ae18cccf2cccb1a">Device</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a> *Modes)</td></tr>
<tr class="separator:a8fcbcd24d57de97f153839f82fb423c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa9bc12da7fb368b47c2442a681719b9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9d">EFI_IDE_CONTROLLER_ENUM_PHASE</a> { <br/>
&#160;&#160;<a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9da5c8073b4c5cbd2115c4fead08834305c">EfiIdeBeforeChannelEnumeration</a>, 
<a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9da1f9d33d4866c9f75ef5afed1e4f8039f">EfiIdeAfterChannelEnumeration</a>, 
<a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9da0df8568e9f0c8abf980a2f8fda1be812">EfiIdeBeforeChannelReset</a>, 
<a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9da413c08f9e8e85637a135eecd723b0dd2">EfiIdeAfterChannelReset</a>, 
<br/>
&#160;&#160;<a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9dac002276806d97fe7fe172660faa01a57">EfiIdeBusBeforeDevicePresenceDetection</a>, 
<a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9daaec5f574b57201df7abd85899e9394ac">EfiIdeBusAfterDevicePresenceDetection</a>, 
<a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9da7800222ee32743c3c66423f5955677c1">EfiIdeResetMode</a>, 
<a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9da69da9a2ec9de6d4945a3a52ecd11a930">EfiIdeBusPhaseMaximum</a>
<br/>
 }</td></tr>
<tr class="separator:aa9bc12da7fb368b47c2442a681719b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcbf33f997bae9ec71fd424bf5ef7c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#afbcbf33f997bae9ec71fd424bf5ef7c5">EFI_ATA_EXT_TRANSFER_PROTOCOL</a> { <a class="el" href="_ide_controller_init_8h.html#afbcbf33f997bae9ec71fd424bf5ef7c5a7b47451618b5cb5b389dc11a004fb48c">EfiAtaSataTransferProtocol</a>
 }</td></tr>
<tr class="separator:afbcbf33f997bae9ec71fd424bf5ef7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a13604a98e1e2618484c9ee2f6e1a0005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ide_controller_init_8h.html#a13604a98e1e2618484c9ee2f6e1a0005">gEfiIdeControllerInitProtocolGuid</a></td></tr>
<tr class="separator:a13604a98e1e2618484c9ee2f6e1a0005"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file declares EFI IDE Controller Init Protocol</p>
<p>The EFI_IDE_CONTROLLER_INIT_PROTOCOL provides the chipset-specific information to the driver entity. This protocol is mandatory for IDE controllers if the IDE devices behind the controller are to be enumerated by a driver entity.</p>
<p>There can only be one instance of EFI_IDE_CONTROLLER_INIT_PROTOCOL for each IDE controller in a system. It is installed on the handle that corresponds to the IDE controller. A driver entity that wishes to manage an IDE bus and possibly IDE devices in a system will have to retrieve the EFI_IDE_CONTROLLER_INIT_PROTOCOL instance that is associated with the controller to be managed.</p>
<p>A device handle for an IDE controller must contain an <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a>.</p>
<p>Copyright (c) 2007 - 2018, Intel Corporation. All rights reserved.<br/>
 SPDX-License-Identifier: BSD-2-Clause-Patent</p>
<dl class="section user"><dt>Revision Reference:</dt><dd>This Protocol is defined in UEFI Platform Initialization Specification 1.2 Volume 5: Standards. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="acadc20d57d1e3ef9239b638f5806df26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_ATAPI_DEVICE_IDENTIFY_DATA&#160;&#160;&#160;0x8000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag indicates whether the IDENTIFY data is a response from an ATA device (EFI_ATA_IDENTIFY_DATA) or response from an ATAPI device (EFI_ATAPI_IDENTIFY_DATA). According to the ATA/ATAPI specification, <a class="el" href="union_e_f_i___i_d_e_n_t_i_f_y___d_a_t_a.html">EFI_IDENTIFY_DATA</a> is for an ATA device if bit 15 of the Config field is zero. The Config field is common to both EFI_ATA_IDENTIFY_DATA and EFI_ATAPI_IDENTIFY_DATA. </p>

</div>
</div>
<a class="anchor" id="a6dcac123af4f24d12ec35ce9a81127d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IDE_CONTROLLER_INIT_PROTOCOL_GUID</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">    0xa1e37052, 0x80d9, 0x4e65, {0xa3, 0x17, 0x3e, 0x9a, 0x55, 0xc4, 0x3e, 0xc9 } \</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Global ID for the EFI_IDE_CONTROLLER_INIT_PROTOCOL. </p>

</div>
</div>
<a class="anchor" id="a0c1d79b7560a2a66a935ba9035508be9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_SATA_AUTO_SPEED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Automatically detects the optimum SATA speed. </p>

</div>
</div>
<a class="anchor" id="a73f22d1aadb92252b79222e684111acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_SATA_GEN1_SPEED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates a first-generation (Gen1) SATA speed. </p>

</div>
</div>
<a class="anchor" id="af9d9e0a2c68b91808283eb11f568ee20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_SATA_GEN2_SPEED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates a second-generation (Gen2) SATA speed. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a6cac03bee27a65ccf33a78732d7f9107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_a_t_a___i_d_e_n_t_i_f_y___d_a_t_a.html">ATA_IDENTIFY_DATA</a> <a class="el" href="_ide_controller_init_8h.html#a6cac03bee27a65ccf33a78732d7f9107">EFI_ATA_IDENTIFY_DATA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EFI_ATA_IDENTIFY_DATA &amp; EFI_ATAPI_IDENTIFY_DATA structure</p>
<p>The definition of these two structures is not part of the protocol definition because the ATA/ATAPI Specification controls the definition of all the fields. The ATA/ATAPI Specification can obsolete old fields or redefine existing fields. </p>

</div>
</div>
<a class="anchor" id="aa2d88d05ad6d933082f3a2e84658b364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_a_t_a_p_i___i_d_e_n_t_i_f_y___d_a_t_a.html">ATAPI_IDENTIFY_DATA</a> <a class="el" href="_ide_controller_init_8h.html#aa2d88d05ad6d933082f3a2e84658b364">EFI_ATAPI_IDENTIFY_DATA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a90d188c9832eda8b169c3033ca42b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IDE_CONTROLLER_CALCULATE_MODE)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> <a class="el" href="_i2c_enumerate_8h.html#a72aa8392440f35be3ae18cccf2cccb1a">Device</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a> **SupportedModes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the information about the optimum modes for the specified IDE device.</p>
<p>This function is used by the driver entity to obtain the optimum ATA modes for a specific device. The IDE controller driver takes into account the following while calculating the mode:</p>
<ul>
<li>The IdentifyData inputs to <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a2b483ebe833979f6bb14dd9f9bf5f337">EFI_IDE_CONTROLLER_INIT_PROTOCOL.SubmitData()</a></li>
<li>The BadModes inputs to <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a441f4bcffd7630eaa077527d9c125cfa">EFI_IDE_CONTROLLER_INIT_PROTOCOL.DisqualifyMode()</a></li>
</ul>
<p>The driver entity is required to call <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a2b483ebe833979f6bb14dd9f9bf5f337">EFI_IDE_CONTROLLER_INIT_PROTOCOL.SubmitData()</a> for all the devices that belong to an enumeration group before calling <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a67c63b2ffb1b93f153e4d76f64d1c343">EFI_IDE_CONTROLLER_INIT_PROTOCOL.CalculateMode()</a> for any device in the same group.</p>
<p>The IDE controller driver will use controller- and possibly platform-specific algorithms to arrive at SupportedModes. The IDE controller may base its decision on user preferences and other considerations as well. This function may be called multiple times because the driver entity may renegotiate the mode with the IDE controller driver using <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a441f4bcffd7630eaa077527d9c125cfa">EFI_IDE_CONTROLLER_INIT_PROTOCOL.DisqualifyMode()</a>.</p>
<p>The driver entity may collect timing information for various devices in any order. The driver entity is responsible for making sure that all the dependencies are satisfied. For example, the SupportedModes information for device A that was previously returned may become stale after a call to <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a441f4bcffd7630eaa077527d9c125cfa">EFI_IDE_CONTROLLER_INIT_PROTOCOL.DisqualifyMode()</a> for device B.</p>
<p>The buffer SupportedModes is allocated by the callee because the caller does not necessarily know the size of the buffer. The type <a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a> is defined in a way that allows for future extensibility and can be of variable length. This memory pool should be deallocated by the caller when it is no longer necessary.</p>
<p>The IDE controller driver for a Serial ATA (SATA) controller can use this member function to force a lower speed (first-generation [Gen1] speeds on a second-generation [Gen2]-capable hardware). The IDE controller driver can also allow the driver entity to stay with the speed that has been negotiated by the physical layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_IDE_CONTROLLER_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Channel</td><td>A zero-based channel number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Device</td><td>A zero-based device number on the Channel. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SupportedModes</td><td>The optimum modes for the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>SupportedModes was returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Channel is invalid (Channel &gt;= ChannelCount). </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Device is invalid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SupportedModes is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Modes cannot be calculated due to a lack of data. This error may happen if <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a2b483ebe833979f6bb14dd9f9bf5f337">EFI_IDE_CONTROLLER_INIT_PROTOCOL.SubmitData()</a> and EFI_IDE_CONTROLLER_INIT_PROTOCOL.DisqualifyData() were not called for at least one drive in the same enumeration group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7256700e7309ed519334c4a4a4bc576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IDE_CONTROLLER_DISQUALIFY_MODE)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> <a class="el" href="_i2c_enumerate_8h.html#a72aa8392440f35be3ae18cccf2cccb1a">Device</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a> *BadModes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disqualifies specific modes for an IDE device.</p>
<p>This function allows the driver entity or other drivers (such as platform drivers) to reject certain timing modes and request the IDE controller driver to recalculate modes. This function allows the driver entity and the IDE controller driver to negotiate the timings on a per-device basis. This function is useful in the case of drives that lie about their capabilities. An example is when the IDE device fails to accept the timing modes that are calculated by the IDE controller driver based on the response to the Identify Drive command.</p>
<p>If the driver entity does not want to limit the ATA timing modes and leave that decision to the IDE controller driver, it can either not call this function for the given device or call this function and set the Valid flag to FALSE for all modes that are listed in <a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a>.</p>
<p>The driver entity may disqualify modes for a device in any order and any number of times.</p>
<p>This function can be called multiple times to invalidate multiple modes of the same type (e.g., Programmed Input/Output [PIO] modes 3 and 4). See the ATA/ATAPI specification for more information on PIO modes.</p>
<p>For Serial ATA (SATA) controllers, this member function can be used to disqualify a higher transfer rate mode on a given channel. For example, a platform driver may inform the IDE controller driver to not use second-generation (Gen2) speeds for a certain SATA drive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_IDE_CONTROLLER_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Channel</td><td>The zero-based channel number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Device</td><td>The zero-based device number on the Channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BadModes</td><td>The modes that the device does not support and that should be disqualified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The modes were accepted without any errors. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Channel is invalid (Channel &gt;= ChannelCount). </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Device is invalid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>IdentifyData is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09efcf515e231638d03032d764501b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IDE_CONTROLLER_GET_CHANNEL_INFO)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#a241cb7969626e26a0961a75645528770">BOOLEAN</a> *Enabled, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *MaxDevices)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the information about the specified IDE channel.</p>
<p>This function can be used to obtain information about a particular IDE channel. The driver entity uses this information during the enumeration process.</p>
<p>If Enabled is set to FALSE, the driver entity will not scan the channel. Note that it will not prevent an operating system driver from scanning the channel.</p>
<p>For most of today's controllers, MaxDevices will either be 1 or 2. For SATA controllers, this value will always be 1. SATA configurations can contain SATA port multipliers. SATA port multipliers behave like SATA bridges and can support up to 16 devices on the other side. If a SATA port out of the IDE controller is connected to a port multiplier, MaxDevices will be set to the number of SATA devices that the port multiplier supports. Because today's port multipliers support up to fifteen SATA devices, this number can be as large as fifteen. The IDE bus driver is required to scan for the presence of port multipliers behind an SATA controller and enumerate up to MaxDevices number of devices behind the port multiplier.</p>
<p>In this context, the devices behind a port multiplier constitute a channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_IDE_CONTROLLER_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Channel</td><td>Zero-based channel number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Enabled</td><td>TRUE if this channel is enabled. Disabled channels are not scanned to see if any devices are present. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MaxDevices</td><td>The maximum number of IDE devices that the bus driver can expect on this channel. For the ATA/ATAPI specification, version 6, this number will either be one or two. For Serial ATA (SATA) configurations with a port multiplier, this number can be as large as fifteen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Information was returned without any errors. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Channel is invalid (Channel &gt;= ChannelCount). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e2f103e9b1fb7ef16dd94cb4f87d254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html">_EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forward declaration for EFI_IDE_CONTROLLER_INIT_PROTOCOL. </p>

</div>
</div>
<a class="anchor" id="a1bae4c5d6f0a6898deabd83d603136d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IDE_CONTROLLER_NOTIFY_PHASE)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9d">EFI_IDE_CONTROLLER_ENUM_PHASE</a> <a class="el" href="_acpi50_8h.html#a0552690222427be671ab64fea764f0c3">Phase</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The notifications from the driver entity that it is about to enter a certain phase of the IDE channel enumeration process.</p>
<p>This function can be used to notify the IDE controller driver to perform specific actions, including any chipset-specific initialization, so that the chipset is ready to enter the next phase. Seven notification points are defined at this time.</p>
<p>More synchronization points may be added as required in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_IDE_CONTROLLER_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Phase</td><td>The phase during enumeration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Channel</td><td>Zero-based channel number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The notification was accepted without any errors. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Phase is not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Channel is invalid (Channel &gt;= ChannelCount). </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>This phase cannot be entered at this time; for example, an attempt was made to enter a Phase without having entered one or more previous Phase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fcbcd24d57de97f153839f82fb423c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IDE_CONTROLLER_SET_TIMING)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> <a class="el" href="_i2c_enumerate_8h.html#a72aa8392440f35be3ae18cccf2cccb1a">Device</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="struct_e_f_i___a_t_a___c_o_l_l_e_c_t_i_v_e___m_o_d_e.html">EFI_ATA_COLLECTIVE_MODE</a> *Modes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commands the IDE controller driver to program the IDE controller hardware so that the specified device can operate at the specified mode.</p>
<p>This function is used by the driver entity to instruct the IDE controller driver to program the IDE controller hardware to the specified modes. This function can be called only once for a particular device. For a Serial ATA (SATA) Advanced Host Controller Interface (AHCI) controller, no controller- specific programming may be required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IDE_CONTROLLER_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Channel</td><td>Zero-based channel number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Device</td><td>Zero-based device number on the Channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Modes</td><td>The modes to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The command was accepted without any errors. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Channel is invalid (Channel &gt;= ChannelCount). </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Device is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Modes cannot be set at this time due to lack of data. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Modes cannot be set due to hardware failure. The driver entity should not use this device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc761c8b6dfb7900cdc6950c3147049c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IDE_CONTROLLER_SUBMIT_DATA)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ide_controller_init_8h.html#a9e2f103e9b1fb7ef16dd94cb4f87d254">EFI_IDE_CONTROLLER_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Channel, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> <a class="el" href="_i2c_enumerate_8h.html#a72aa8392440f35be3ae18cccf2cccb1a">Device</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="union_e_f_i___i_d_e_n_t_i_f_y___d_a_t_a.html">EFI_IDENTIFY_DATA</a> *IdentifyData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Submits the device information to the IDE controller driver.</p>
<p>This function is used by the driver entity to pass detailed information about a particular device to the IDE controller driver. The driver entity obtains this information by issuing an ATA or ATAPI IDENTIFY_DEVICE command. IdentifyData is the pointer to the response data buffer. The IdentifyData buffer is owned by the driver entity, and the IDE controller driver must make a local copy of the entire buffer or parts of the buffer as needed. The original IdentifyData buffer pointer may not be valid when</p>
<ul>
<li><a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a67c63b2ffb1b93f153e4d76f64d1c343">EFI_IDE_CONTROLLER_INIT_PROTOCOL.CalculateMode()</a> or</li>
<li><a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a441f4bcffd7630eaa077527d9c125cfa">EFI_IDE_CONTROLLER_INIT_PROTOCOL.DisqualifyMode()</a> is called at a later point.</li>
</ul>
<p>The IDE controller driver may consult various fields of <a class="el" href="union_e_f_i___i_d_e_n_t_i_f_y___d_a_t_a.html">EFI_IDENTIFY_DATA</a> to compute the optimum mode for the device. These fields are not limited to the timing information. For example, an implementation of the IDE controller driver may examine the vendor and type/mode field to match known bad drives.</p>
<p>The driver entity may submit drive information in any order, as long as it submits information for all the devices belonging to the enumeration group before <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a67c63b2ffb1b93f153e4d76f64d1c343">EFI_IDE_CONTROLLER_INIT_PROTOCOL.CalculateMode()</a> is called for any device in that enumeration group. If a device is absent, <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a2b483ebe833979f6bb14dd9f9bf5f337">EFI_IDE_CONTROLLER_INIT_PROTOCOL.SubmitData()</a> should be called with IdentifyData set to NULL. The IDE controller driver may not have any other mechanism to know whether a device is present or not. Therefore, setting IdentifyData to NULL does not constitute an error condition. <a class="el" href="struct___e_f_i___i_d_e___c_o_n_t_r_o_l_l_e_r___i_n_i_t___p_r_o_t_o_c_o_l.html#a2b483ebe833979f6bb14dd9f9bf5f337">EFI_IDE_CONTROLLER_INIT_PROTOCOL.SubmitData()</a> can be called only once for a given (Channel, Device) pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_IDE_CONTROLLER_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Channel</td><td>Zero-based channel number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Device</td><td>Zero-based device number on the Channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IdentifyData</td><td>The device's response to the ATA IDENTIFY_DEVICE command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The information was accepted without any errors. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Channel is invalid (Channel &gt;= ChannelCount). </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Device is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="afbcbf33f997bae9ec71fd424bf5ef7c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_ide_controller_init_8h.html#afbcbf33f997bae9ec71fd424bf5ef7c5">EFI_ATA_EXT_TRANSFER_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This extended mode describes the SATA physical protocol. SATA physical layers can operate at different speeds. These speeds are defined below. Various PATA protocols and associated modes are not applicable to SATA devices. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="afbcbf33f997bae9ec71fd424bf5ef7c5a7b47451618b5cb5b389dc11a004fb48c"></a>EfiAtaSataTransferProtocol</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_ide_controller_init_8h.html#aa9bc12da7fb368b47c2442a681719b9d">EFI_IDE_CONTROLLER_ENUM_PHASE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The phase of the IDE Controller enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9da5c8073b4c5cbd2115c4fead08834305c"></a>EfiIdeBeforeChannelEnumeration</em>&#160;</td><td class="fielddoc">
<p>The driver entity is about to begin enumerating the devices behind the specified channel. This notification can be used to perform any chipset-specific programming. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9da1f9d33d4866c9f75ef5afed1e4f8039f"></a>EfiIdeAfterChannelEnumeration</em>&#160;</td><td class="fielddoc">
<p>The driver entity has completed enumerating the devices behind the specified channel. This notification can be used to perform any chipset-specific programming. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9da0df8568e9f0c8abf980a2f8fda1be812"></a>EfiIdeBeforeChannelReset</em>&#160;</td><td class="fielddoc">
<p>The driver entity is about to reset the devices behind the specified channel. This notification can be used to perform any chipset-specific programming. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9da413c08f9e8e85637a135eecd723b0dd2"></a>EfiIdeAfterChannelReset</em>&#160;</td><td class="fielddoc">
<p>The driver entity has completed resetting the devices behind the specified channel. This notification can be used to perform any chipset-specific programming. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9dac002276806d97fe7fe172660faa01a57"></a>EfiIdeBusBeforeDevicePresenceDetection</em>&#160;</td><td class="fielddoc">
<p>The driver entity is about to detect the presence of devices behind the specified channel. This notification can be used to set up the bus signals to default levels or for implementing predelays. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9daaec5f574b57201df7abd85899e9394ac"></a>EfiIdeBusAfterDevicePresenceDetection</em>&#160;</td><td class="fielddoc">
<p>The driver entity is done with detecting the presence of devices behind the specified channel. This notification can be used to perform any chipset-specific programming. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9da7800222ee32743c3c66423f5955677c1"></a>EfiIdeResetMode</em>&#160;</td><td class="fielddoc">
<p>The IDE bus is requesting the IDE controller driver to reprogram the IDE controller hardware and thereby reset all the mode and timing settings to default settings. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9bc12da7fb368b47c2442a681719b9da69da9a2ec9de6d4945a3a52ecd11a930"></a>EfiIdeBusPhaseMaximum</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a13604a98e1e2618484c9ee2f6e1a0005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiIdeControllerInitProtocolGuid</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_c048fdeadf06364e9318d2cbb3390051.html">MdePkg</a></li><li class="navelem"><a class="el" href="dir_525332e2e2b2ed96fb8f8316b580bf1e.html">Include</a></li><li class="navelem"><a class="el" href="dir_c891243080d8325efd53abbaaf181a0e.html">Protocol</a></li><li class="navelem"><a class="el" href="_ide_controller_init_8h.html">IdeControllerInit.h</a></li>
    <li class="footer">Generated on Sun Dec 5 2021 00:12:47 for MdePkg[all] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
