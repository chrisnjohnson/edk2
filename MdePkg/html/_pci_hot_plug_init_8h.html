<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MdePkg[all]: MdePkg/Include/Protocol/PciHotPlugInit.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MdePkg[all]
   &#160;<span id="projectnumber">1.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_pci_hot_plug_init_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">PciHotPlugInit.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___h_p_c___l_o_c_a_t_i_o_n.html">EFI_HPC_LOCATION</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___e_f_i___p_c_i___h_o_t___p_l_u_g___i_n_i_t___p_r_o_t_o_c_o_l.html">_EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a850fc5fab2dd2c8a4b5973e4a27d15bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a850fc5fab2dd2c8a4b5973e4a27d15bf">EFI_PCI_HOT_PLUG_INIT_PROTOCOL_GUID</a></td></tr>
<tr class="separator:a850fc5fab2dd2c8a4b5973e4a27d15bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4466564ce8bc2e1bd78a032d593dca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a9c4466564ce8bc2e1bd78a032d593dca">EFI_HPC_STATE_INITIALIZED</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a9c4466564ce8bc2e1bd78a032d593dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2d8aa4f0c7f9429c6b87d3b05498ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a1a2d8aa4f0c7f9429c6b87d3b05498ff">EFI_HPC_STATE_ENABLED</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a1a2d8aa4f0c7f9429c6b87d3b05498ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8853b7766eb840318a6f8f86a8b879c8"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct___e_f_i___p_c_i___h_o_t___p_l_u_g___i_n_i_t___p_r_o_t_o_c_o_l.html">_EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a8853b7766eb840318a6f8f86a8b879c8">EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a></td></tr>
<tr class="separator:a8853b7766eb840318a6f8f86a8b879c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cd382b19c598c4cbd6f7b55dad35c1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#a09f1a1fb2293e33483cc8d44aefb1eb1">UINT16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a93cd382b19c598c4cbd6f7b55dad35c1">EFI_HPC_STATE</a></td></tr>
<tr class="separator:a93cd382b19c598c4cbd6f7b55dad35c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332bbee9eb0ed8f8543bb594c93b5c8d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a332bbee9eb0ed8f8543bb594c93b5c8d">EFI_GET_ROOT_HPC_LIST</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_pci_hot_plug_init_8h.html#a8853b7766eb840318a6f8f86a8b879c8">EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *HpcCount, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="struct_e_f_i___h_p_c___l_o_c_a_t_i_o_n.html">EFI_HPC_LOCATION</a> **HpcList)</td></tr>
<tr class="separator:a332bbee9eb0ed8f8543bb594c93b5c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1038c0667319274655db108531a17731"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a1038c0667319274655db108531a17731">EFI_INITIALIZE_ROOT_HPC</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_pci_hot_plug_init_8h.html#a8853b7766eb840318a6f8f86a8b879c8">EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> *HpcDevicePath, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> HpcPciAddress, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="_i2c_bus_configuration_management_8h.html#acde3dc9d327242f1985ac623debfc55c">Event</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pci_hot_plug_init_8h.html#a93cd382b19c598c4cbd6f7b55dad35c1">EFI_HPC_STATE</a> *HpcState)</td></tr>
<tr class="separator:a1038c0667319274655db108531a17731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fb5cfce7654bd11e4fee5c4cf07bf0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a12fb5cfce7654bd11e4fee5c4cf07bf0">EFI_GET_HOT_PLUG_PADDING</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_pci_hot_plug_init_8h.html#a8853b7766eb840318a6f8f86a8b879c8">EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> *HpcDevicePath, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> HpcPciAddress, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pci_hot_plug_init_8h.html#a93cd382b19c598c4cbd6f7b55dad35c1">EFI_HPC_STATE</a> *HpcState, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_shell_8h.html#aa8ff5bd3c2d6cb377b1dd3bbe3e0cfa8">VOID</a> **Padding, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pci_hot_plug_init_8h.html#a3c6b37feda9f3d13f7ecfa116ee6711d">EFI_HPC_PADDING_ATTRIBUTES</a> *Attributes)</td></tr>
<tr class="separator:a12fb5cfce7654bd11e4fee5c4cf07bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3c6b37feda9f3d13f7ecfa116ee6711d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a3c6b37feda9f3d13f7ecfa116ee6711d">EFI_HPC_PADDING_ATTRIBUTES</a> { <a class="el" href="_pci_hot_plug_init_8h.html#a3c6b37feda9f3d13f7ecfa116ee6711dabe24839756d8eae37cda69f4cef3a993">EfiPaddingPciBus</a>, 
<a class="el" href="_pci_hot_plug_init_8h.html#a3c6b37feda9f3d13f7ecfa116ee6711dac5de9d00b5d5adfbd7bafd08539461e5">EfiPaddingPciRootBridge</a>
 }</td></tr>
<tr class="separator:a3c6b37feda9f3d13f7ecfa116ee6711d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a98fff0af742cafe4a2ea808a09ae4f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pci_hot_plug_init_8h.html#a98fff0af742cafe4a2ea808a09ae4f33">gEfiPciHotPlugInitProtocolGuid</a></td></tr>
<tr class="separator:a98fff0af742cafe4a2ea808a09ae4f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file declares EFI PCI Hot Plug Init Protocol.</p>
<p>This protocol provides the necessary functionality to initialize the Hot Plug Controllers (HPCs) and the buses that they control. This protocol also provides information regarding resource padding.</p>
<dl class="section user"><dt>Note:</dt><dd>This protocol is required only on platforms that support one or more PCI Hot Plug* slots or CardBus sockets.</dd></dl>
<p>The EFI_PCI_HOT_PLUG_INIT_PROTOCOL provides a mechanism for the PCI bus enumerator to properly initialize the HPCs and CardBus sockets that require initialization. The HPC initialization takes place before the PCI enumeration process is complete. There cannot be more than one instance of this protocol in a system. This protocol is installed on its own separate handle.</p>
<p>Because the system may include multiple HPCs, one instance of this protocol should represent all of them. The protocol functions use the device path of the HPC to identify the HPC. When the PCI bus enumerator finds a root HPC, it will call <a class="el" href="struct___e_f_i___p_c_i___h_o_t___p_l_u_g___i_n_i_t___p_r_o_t_o_c_o_l.html#a5533c227c9e21a50db40d4c479df5a55">EFI_PCI_HOT_PLUG_INIT_PROTOCOL.InitializeRootHpc()</a>. If InitializeRootHpc() is unable to initialize a root HPC, the PCI enumerator will ignore that root HPC and continue the enumeration process. If the HPC is not initialized, the devices that it controls may not be initialized, and no resource padding will be provided.</p>
<p>From the standpoint of the PCI bus enumerator, HPCs are divided into the following two classes:</p>
<ul>
<li>Root HPC: These HPCs must be initialized by calling InitializeRootHpc() during the enumeration process. These HPCs will also require resource padding. The platform code must have a priori knowledge of these devices and must know how to initialize them. There may not be any way to access their PCI configuration space before the PCI enumerator programs all the upstream bridges and thus enables the path to these devices. The PCI bus enumerator is responsible for determining the PCI bus address of the HPC before it calls InitializeRootHpc().</li>
<li>Nonroot HPC: These HPCs will not need explicit initialization during enumeration process. These HPCs will require resource padding. The platform code does not have to have a priori knowledge of these devices.</li>
</ul>
<p>Copyright (c) 2007 - 2018, Intel Corporation. All rights reserved.<br/>
 SPDX-License-Identifier: BSD-2-Clause-Patent</p>
<dl class="section user"><dt>Revision Reference:</dt><dd>This Protocol is defined in UEFI Platform Initialization Specification 1.2 Volume 5: Standards </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a1a2d8aa4f0c7f9429c6b87d3b05498ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_HPC_STATE_ENABLED&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The HPC initialization function was called, the HPC completed initialization, and it was enabled. Resource padding is required. </p>

</div>
</div>
<a class="anchor" id="a9c4466564ce8bc2e1bd78a032d593dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_HPC_STATE_INITIALIZED&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The HPC initialization function was called and the HPC completed initialization, but it was not enabled for some reason. The HPC may be disabled in hardware, or it may be disabled due to user preferences, hardware failure, or other reasons. No resource padding is required. </p>

</div>
</div>
<a class="anchor" id="a850fc5fab2dd2c8a4b5973e4a27d15bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PCI_HOT_PLUG_INIT_PROTOCOL_GUID</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">    0xaa0e8bc1, 0xdabc, 0x46b0, {0xa8, 0x44, 0x37, 0xb8, 0x16, 0x9b, 0x2b, 0xea } \</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Global ID for the EFI_PCI_HOT_PLUG_INIT_PROTOCOL </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a12fb5cfce7654bd11e4fee5c4cf07bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_HOT_PLUG_PADDING)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_pci_hot_plug_init_8h.html#a8853b7766eb840318a6f8f86a8b879c8">EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> *HpcDevicePath, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> HpcPciAddress, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pci_hot_plug_init_8h.html#a93cd382b19c598c4cbd6f7b55dad35c1">EFI_HPC_STATE</a> *HpcState, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_shell_8h.html#aa8ff5bd3c2d6cb377b1dd3bbe3e0cfa8">VOID</a> **Padding, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pci_hot_plug_init_8h.html#a3c6b37feda9f3d13f7ecfa116ee6711d">EFI_HPC_PADDING_ATTRIBUTES</a> *Attributes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the resource padding that is required by the PCI bus that is controlled by the specified Hot Plug Controller (HPC).</p>
<p>This function returns the resource padding that is required by the PCI bus that is controlled by the specified HPC. This member function is called for all the root HPCs and nonroot HPCs that are detected by the PCI bus enumerator. This function will be called before PCI resource allocation is completed. This function must be called after all the root HPCs, with the possible exception of a PCI-to-CardBus bridge, have completed initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_PCI_HOT_PLUG_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HpcDevicePath</td><td>The device path to the HPC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HpcPciAddress</td><td>The address of the HPC function on the PCI bus. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HpcState</td><td>The state of the HPC hardware. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Padding</td><td>The amount of resource padding that is required by the PCI bus under the control of the specified HPC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Attributes</td><td>Describes how padding is accounted for. The padding is returned in the form of ACPI 2.0 resource descriptors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The resource padding was successfully returned. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This instance of the EFI_PCI_HOT_PLUG_INIT_PROTOCOL does not support the specified HPC. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>This function was called before HPC initialization is complete. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HpcState or Padding or Attributes is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>ACPI 2.0 resource descriptors for Padding cannot be allocated due to insufficient resources. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a332bbee9eb0ed8f8543bb594c93b5c8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_ROOT_HPC_LIST)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_pci_hot_plug_init_8h.html#a8853b7766eb840318a6f8f86a8b879c8">EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *HpcCount, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="struct_e_f_i___h_p_c___l_o_c_a_t_i_o_n.html">EFI_HPC_LOCATION</a> **HpcList)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of root Hot Plug Controllers (HPCs) that require initialization during the boot process.</p>
<p>This procedure returns a list of root HPCs. The PCI bus driver must initialize these controllers during the boot process. The PCI bus driver may or may not be able to detect these HPCs. If the platform includes a PCI-to-CardBus bridge, it can be included in this list if it requires initialization. The HpcList must be self consistent. An HPC cannot control any of its parent buses. Only one HPC can control a PCI bus. Because this list includes only root HPCs, no HPC in the list can be a child of another HPC. This policy must be enforced by the EFI_PCI_HOT_PLUG_INIT_PROTOCOL. The PCI bus driver may not check for such invalid conditions. The callee allocates the buffer HpcList</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_PCI_HOT_PLUG_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HpcCount</td><td>The number of root HPCs that were returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HpcList</td><td>The list of root HPCs. HpcCount defines the number of elements in this list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>HpcList was returned. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>HpcList was not returned due to insufficient resources. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HpcCount is NULL or HpcList is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93cd382b19c598c4cbd6f7b55dad35c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#a09f1a1fb2293e33483cc8d44aefb1eb1">UINT16</a> <a class="el" href="_pci_hot_plug_init_8h.html#a93cd382b19c598c4cbd6f7b55dad35c1">EFI_HPC_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describes the current state of an HPC </p>

</div>
</div>
<a class="anchor" id="a1038c0667319274655db108531a17731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_INITIALIZE_ROOT_HPC)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_pci_hot_plug_init_8h.html#a8853b7766eb840318a6f8f86a8b879c8">EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> *HpcDevicePath, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> HpcPciAddress, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="_i2c_bus_configuration_management_8h.html#acde3dc9d327242f1985ac623debfc55c">Event</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pci_hot_plug_init_8h.html#a93cd382b19c598c4cbd6f7b55dad35c1">EFI_HPC_STATE</a> *HpcState)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes one root Hot Plug Controller (HPC). This process may causes initialization of its subordinate buses.</p>
<p>This function initializes the specified HPC. At the end of initialization, the hot-plug slots or sockets (controlled by this HPC) are powered and are connected to the bus. All the necessary registers in the HPC are set up. For a Standard (PCI) Hot Plug Controller (SHPC), the registers that must be set up are defined in the PCI Standard Hot Plug Controller and Subsystem Specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_PCI_HOT_PLUG_INIT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HpcDevicePath</td><td>The device path to the HPC that is being initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HpcPciAddress</td><td>The address of the HPC function on the PCI bus. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>The event that should be signaled when the HPC initialization is complete. Set to NULL if the caller wants to wait until the entire initialization process is complete. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HpcState</td><td>The state of the HPC hardware. The state is EFI_HPC_STATE_INITIALIZED or EFI_HPC_STATE_ENABLED.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL, the specific HPC was successfully initialized. If Event is not NULL, Event will be signaled at a later time when initialization is complete. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This instance of EFI_PCI_HOT_PLUG_INIT_PROTOCOL does not support the specified HPC. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Initialization failed due to insufficient resources. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HpcState is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8853b7766eb840318a6f8f86a8b879c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___e_f_i___p_c_i___h_o_t___p_l_u_g___i_n_i_t___p_r_o_t_o_c_o_l.html">_EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a> <a class="el" href="_pci_hot_plug_init_8h.html#a8853b7766eb840318a6f8f86a8b879c8">EFI_PCI_HOT_PLUG_INIT_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forward declaration for EFI_PCI_HOT_PLUG_INIT_PROTOCOL </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a3c6b37feda9f3d13f7ecfa116ee6711d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_pci_hot_plug_init_8h.html#a3c6b37feda9f3d13f7ecfa116ee6711d">EFI_HPC_PADDING_ATTRIBUTES</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describes how resource padding should be applied </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a3c6b37feda9f3d13f7ecfa116ee6711dabe24839756d8eae37cda69f4cef3a993"></a>EfiPaddingPciBus</em>&#160;</td><td class="fielddoc">
<p>Apply the padding at a PCI bus level. In other words, the resources that are allocated to the bus containing hot-plug slots are padded by the specified amount. If the hot-plug bus is behind a PCI-to-PCI bridge, the PCI-to-PCI bridge apertures will indicate the padding </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3c6b37feda9f3d13f7ecfa116ee6711dac5de9d00b5d5adfbd7bafd08539461e5"></a>EfiPaddingPciRootBridge</em>&#160;</td><td class="fielddoc">
<p>Apply the padding at a PCI root bridge level. If a PCI root bridge includes more than one hot-plug bus, the resource padding requests for these buses are added together and the resources that are allocated to the root bridge are padded by the specified amount. This strategy may reduce the total amount of padding, but requires reprogramming of PCI-to-PCI bridges in a hot-add event. If the hotplug bus is behind a PCI-to-PCI bridge, the PCI-to-PCI bridge apertures do not indicate the padding for that bus. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a98fff0af742cafe4a2ea808a09ae4f33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiPciHotPlugInitProtocolGuid</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ee16cea0340e4558b8b17c3b12ae3d0b.html">MdePkg</a></li><li class="navelem"><a class="el" href="dir_43dbc6def9233b1fec759bd8d9ab8e67.html">Include</a></li><li class="navelem"><a class="el" href="dir_9f6c7d0dc4f1fca0fd79ad2d14808d02.html">Protocol</a></li><li class="navelem"><a class="el" href="_pci_hot_plug_init_8h.html">PciHotPlugInit.h</a></li>
    <li class="footer">Generated on Sun Dec 5 2021 03:41:13 for MdePkg[all] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
