<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MdePkg[all]: MdePkg/Include/Ppi/Graphics.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MdePkg[all]
   &#160;<span id="projectnumber">1.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_graphics_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Graphics.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___e_f_i___p_e_i___g_r_a_p_h_i_c_s___p_p_i.html">_EFI_PEI_GRAPHICS_PPI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3f29fc41930aeba5b56b48362398f121"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_graphics_8h.html#a3f29fc41930aeba5b56b48362398f121">EFI_PEI_GRAPHICS_PPI_GUID</a></td></tr>
<tr class="separator:a3f29fc41930aeba5b56b48362398f121"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8847ef1ad39cf6f57559ad48aa07a374"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct___e_f_i___p_e_i___g_r_a_p_h_i_c_s___p_p_i.html">_EFI_PEI_GRAPHICS_PPI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_graphics_8h.html#a8847ef1ad39cf6f57559ad48aa07a374">EFI_PEI_GRAPHICS_PPI</a></td></tr>
<tr class="separator:a8847ef1ad39cf6f57559ad48aa07a374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acbcd3e1c23d2c2ef43ea46d0ba2899a3"><td class="memItemLeft" align="right" valign="top">typedef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_graphics_8h.html#acbcd3e1c23d2c2ef43ea46d0ba2899a3">EFI_STATUS</a> (<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *EFI_PEI_GRAPHICS_INIT)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_shell_8h.html#aa8ff5bd3c2d6cb377b1dd3bbe3e0cfa8">VOID</a> *GraphicsPolicyPtr)</td></tr>
<tr class="separator:acbcd3e1c23d2c2ef43ea46d0ba2899a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aced10be2c8aeb0a1f5fbe55879e3b524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_graphics_8h.html#aced10be2c8aeb0a1f5fbe55879e3b524">gEfiPeiGraphicsPpiGuid</a></td></tr>
<tr class="separator:aced10be2c8aeb0a1f5fbe55879e3b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file declares Graphics PPI. This PPI is the main interface exposed by the Graphics PEIM to be used by the other firmware modules.</p>
<p>Copyright (c) 2015, Intel Corporation. All rights reserved.<br/>
 SPDX-License-Identifier: BSD-2-Clause-Patent</p>
<dl class="section user"><dt>Revision Reference:</dt><dd>This PPI is introduced in PI Version 1.4. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3f29fc41930aeba5b56b48362398f121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PEI_GRAPHICS_PPI_GUID</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">    0x6ecd1463, 0x4a4a, 0x461b, { 0xaf, 0x5f, 0x5a, 0x33, 0xe3, 0xb2, 0x16, 0x2b } \</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a8847ef1ad39cf6f57559ad48aa07a374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___e_f_i___p_e_i___g_r_a_p_h_i_c_s___p_p_i.html">_EFI_PEI_GRAPHICS_PPI</a> <a class="el" href="_graphics_8h.html#a8847ef1ad39cf6f57559ad48aa07a374">EFI_PEI_GRAPHICS_PPI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acbcd3e1c23d2c2ef43ea46d0ba2899a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td>
          <td class="paramname"><em>EFI_HII_CREATE_POPUP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GraphicsPpiInit initializes the graphics subsystem in phases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">GraphicsPolicyPtr</td><td>GraphicsPolicyPtr points to a configuration data block of policy settings required by Graphics PEIM.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The invocation was successful. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The phase parameter is not valid. </td></tr>
    <tr><td class="paramname">EFI_NOT_ABORTED</td><td>The stages was not called in the proper order. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The PeiGraphicsPlatformPolicyPpi is not located. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The initialization failed due to device error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The previous init stage is still in progress and not ready for the current initialization phase yet. The platform code should call this again sometime later.</td></tr>
  </table>
  </dd>
</dl>
<p>The GraphicsPpiGetMode returns the mode information supported by the Graphics PEI Module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Mode</td><td>Pointer to <a class="el" href="struct_e_f_i___g_r_a_p_h_i_c_s___o_u_t_p_u_t___p_r_o_t_o_c_o_l___m_o_d_e.html">EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE</a> data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Valid mode information was returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The Mode parameter is not valid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A hardware error occurred trying to retrieve the video mode. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The Graphics Initialization is not competed and Mode information is not yet available.The platform code should call this again after the Graphics initialization is done.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees memory pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Memory</td><td>The base physical address of the pages to be freed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pages</td><td>The number of contiguous 4 KB pages to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested pages were freed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Memory is not a page-aligned address or Pages is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The requested memory pages were not allocated with <a class="el" href="_memory_allocation_lib_8h.html#a48d461654ab0264be90527d408ee231e">AllocatePages()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Modifies the capabilities for a memory region in the global coherency domain of the processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>The physical address that is the start address of a memory region. </td></tr>
    <tr><td class="paramname">Length</td><td>The size in bytes of the memory region. </td></tr>
    <tr><td class="paramname">Capabilities</td><td>The bit mask of capabilities that the memory region supports.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The capabilities were set for the memory region. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Length is zero. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The capabilities specified by Capabilities do not include the memory region attributes currently in use. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The capabilities for the memory resource range specified by BaseAddress and Length cannot be modified. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There are not enough system resources to modify the capabilities of the memory resource range.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a pointer to a buffer containing zero or more HOBs that will be installed into the PEI HOB List.</p>
<p>This function returns a pointer to a pointer to zero or more HOBs, terminated with a HOB of type EFI_HOB_TYPE_END_OF_HOB_LIST. Note: The HobList must not contain a <a class="el" href="struct_e_f_i___h_o_b___h_a_n_d_o_f_f___i_n_f_o___t_a_b_l_e.html">EFI_HOB_HANDOFF_INFO_TABLE</a> HOB (PHIT) HOB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to this PPI structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HobList</td><td>A pointer to a returned pointer to zero or more HOBs. If no HOBs are to be returned, then the returned pointer is a pointer to a HOB of type EFI_HOB_TYPE_END_OF_HOB_LIST.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>This function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>No HOBS are available.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve additional information associated with a PCD token in the default token space.</p>
<p>This includes information such as the type of value the TokenNumber is associated with as well as possible human readable name that is associated with the token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TokenNumber</td><td>The PCD token number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PcdInfo</td><td>The returned information associated with the requested TokenNumber.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The PCD information was returned successfully </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The PCD service could not find the requested token number.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve additional information associated with a PCD token.</p>
<p>This includes information such as the type of value the TokenNumber is associated with as well as possible human readable name that is associated with the token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>The 128-bit unique value that designates the namespace from which to extract the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TokenNumber</td><td>The PCD token number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PcdInfo</td><td>The returned information associated with the requested TokenNumber.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The PCD information was returned successfully </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The PCD service could not find the requested token number.</td></tr>
  </table>
  </dd>
</dl>
<p>Open I/O aperture.</p>
<p>This function opens an I/O aperture in a ISA Host Controller for the I/O addresses specified by IoAddress to IoAddress + IoLength - 1. It is possible that more than one caller may be assigned to the same aperture. It may be possible that a single hardware aperture may be used for more than one device. This function tracks the number of times that each aperture is referenced, and does not close the hardware aperture (via CloseIoAperture()) until there are no more references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to this instance of the EFI_ISA_HC_PPI. </td></tr>
    <tr><td class="paramname">IoAddress</td><td>An unsigned integer that specifies the first byte of the I/O space required. </td></tr>
    <tr><td class="paramname">IoLength</td><td>An unsigned integer that specifies the number of bytes of the I/O space required. </td></tr>
    <tr><td class="paramname">IoApertureHandle</td><td>A pointer to the returned I/O aperture handle. This value can be used on subsequent calls to CloseIoAperture().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The I/O aperture was opened successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The ISA Host Controller is a subtractive-decode controller. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is no available I/O aperture.</td></tr>
  </table>
  </dd>
</dl>
<p>Close I/O aperture.</p>
<p>This function closes a previously opened I/O aperture handle. If there are no more I/O aperture handles that refer to the hardware I/O aperture resource, then the hardware I/O aperture is closed. It may be possible that a single hardware aperture may be used for more than one device. This function tracks the number of times that each aperture is referenced, and does not close the hardware aperture (via CloseIoAperture()) until there are no more references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to this instance of the EFI_ISA_HC_PPI. </td></tr>
    <tr><td class="paramname">IoApertureHandle</td><td>The I/O aperture handle previously returned from a call to OpenIoAperture().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The I/O aperture was closed successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Invokes PPI activation from the PI PEI environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramname">This</td><td>The PEI_MM_CONTROL_PPI instance. </td></tr>
    <tr><td class="paramname">ArgumentBuffer</td><td>The value passed to the MMI handler. This value corresponds to the SwMmiInputValue in the RegisterContext parameter for the Register() function in the EFI_MM_SW_DISPATCH_PROTOCOL and in the Context parameter in the call to the DispatchFunction </td></tr>
    <tr><td class="paramname">ArgumentBufferSize</td><td>The size of the data passed in ArgumentBuffer or NULL if ArgumentBuffer is NULL. </td></tr>
    <tr><td class="paramname">Periodic</td><td>An optional mechanism to periodically repeat activation. </td></tr>
    <tr><td class="paramname">ActivationInterval</td><td>An optional parameter to repeat at this period one time or, if the Periodic Boolean is set, periodically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The MMI has been engendered. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The timing is unsupported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The activation period is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>The MM base service has not been initialized.</td></tr>
  </table>
  </dd>
</dl>
<p>Clears any system state that was created in response to the Trigger() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeiServices</td><td>General purpose services available to every PEIM. </td></tr>
    <tr><td class="paramname">This</td><td>The PEI_MM_CONTROL_PPI instance. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Optional parameter to repeat at this period one time or, if the Periodic Boolean is set, periodically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The MMI has been engendered. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The source could not be cleared. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The service did not support the Periodic input argument.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the number of CPU's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to this instance of the PPI. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NumberOfProcessors</td><td>Pointer to the total number of logical processors in the system, including the BSP and disabled APs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NumberOfEnabledProcessors</td><td>Number of processors in the system that are enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The number of logical processors and enabled logical processors was retrieved. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>NumberOfProcessors is NULL. NumberOfEnabledProcessors is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Get information on a specific CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to this instance of the PPI. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>Pointer to the total number of logical processors in the system, including the BSP and disabled APs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ProcessorInfoBuffer</td><td>Number of processors in the system that are enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Processor information was returned. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorInfoBuffer is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist in the platform.</td></tr>
  </table>
  </dd>
</dl>
<p>Activate all of the application processors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on enabled APs of the system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SingleThread</td><td>If TRUE, then all the enabled APs execute the function specified by Procedure one by one, in ascending order of processor handle number. If FALSE, then all the enabled APs execute the function specified by Procedure simultaneously. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroSeconds</td><td>Indicates the time limit in microseconds for APs to return from Procedure, for blocking mode only. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. All enabled APs are available for next function assigned by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a5bf59487d69fe6aab87af0df6f7f2799">EFI_PEI_MP_SERVICES_PPI.StartupAllAPs()</a> or <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#aa34a5103be897862c002624b21ed3b33">EFI_PEI_MP_SERVICES_PPI.StartupThisAP()</a>. If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure for all APs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, all APs have finished before the timeout expired. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Caller processor is AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>No enabled APs exist in the system. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Any enabled APs are busy. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before all enabled APs have finished. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Activate a specific application processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on enabled APs of the system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a6bf539700302f5e11cf2e4b14b61bb7b">EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroSeconds</td><td>Indicates the time limit in microseconds for APs to return from Procedure, for blocking mode only. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. All enabled APs are available for next function assigned by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a5bf59487d69fe6aab87af0df6f7f2799">EFI_PEI_MP_SERVICES_PPI.StartupAllAPs()</a> or <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#aa34a5103be897862c002624b21ed3b33">EFI_PEI_MP_SERVICES_PPI.StartupThisAP()</a>. If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure for all APs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, specified AP finished before the timeout expires. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before the specified AP has finished. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the BSP or disabled AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Switch the boot strap processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a6bf539700302f5e11cf2e4b14b61bb7b">EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EnableOldBSP</td><td>If TRUE, then the old BSP will be listed as an enabled AP. Otherwise, it will be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>BSP successfully switched. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP is not supported. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the current BSP or a disabled AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The specified AP is busy.</td></tr>
  </table>
  </dd>
</dl>
<p>Enable or disable an application processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a6bf539700302f5e11cf2e4b14b61bb7b">EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EnableAP</td><td>Specifies the new state for the processor for enabled, FALSE for disabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HealthFlag</td><td>If not NULL, a pointer to a value that specifies the new health status of the AP. This flag corresponds to StatusFlag defined in <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a78f9140fb5a013111ea0fbc4420257cc">EFI_PEI_MP_SERVICES_PPI.GetProcessorInfo()</a>. Only the PROCESSOR_HEALTH_STATUS_BIT is used. All other bits are ignored. If it is NULL, this parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified AP was enabled or disabled successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Enabling or disabling an AP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Enabling or disabling an AP is not supported. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the BSP.</td></tr>
  </table>
  </dd>
</dl>
<p>Identify the currently executing processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a6bf539700302f5e11cf2e4b14b61bb7b">EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The current processor handle number was returned in ProcessorNumber. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve additional information associated with a PCD token.</p>
<p>This includes information such as the type of value the TokenNumber is associated with as well as possible human readable name that is associated with the token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>The 128-bit unique value that designates the namespace from which to extract the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TokenNumber</td><td>The PCD token number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PcdInfo</td><td>The returned information associated with the requested TokenNumber.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The PCD information was returned successfully </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The PCD service could not find the requested token number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the MM Foundation entry point with the processor code. This entry point will be invoked by the MM Processor entry code as defined in PI specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_PEI_MM_CONFIGURATION_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MmEntryPoint</td><td>MM Foundation entry point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The entry-point was successfully registered.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the frequency for the I2C clock line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to an EFI_PEI_I2C_MASTER_PPI structure. </td></tr>
    <tr><td class="paramname">BusClockHertz</td><td>Pointer to the requested I2C bus clock frequency in Hertz. Upon return this value contains the actual frequency in use by the I2C controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The bus frequency was set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BusClockHertz is NULL </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The controller does not support this frequency.</td></tr>
  </table>
  </dd>
</dl>
<p>Reset the I2C controller and configure it for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to an EFI_PEI_I2C_MASTER_PPI structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The reset completed successfully. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The reset operation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>Start an I2C transaction on the host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to an EFI_PEI_I2C_MASTER_PPI structure. </td></tr>
    <tr><td class="paramname">SlaveAddress</td><td>Address of the device on the I2C bus. Set the I2C_ADDRESSING_10_BIT when using 10-bit addresses, clear this bit for 7-bit addressing. Bits 0-6 are used for 7-bit I2C slave addresses and bits 0-9 are used for 10-bit I2C slave addresses. </td></tr>
    <tr><td class="paramname">RequestPacket</td><td>Pointer to an <a class="el" href="struct_e_f_i___i2_c___r_e_q_u_e_s_t___p_a_c_k_e_t.html">EFI_I2C_REQUEST_PACKET</a> structure describing the I2C transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The transaction completed successfully. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The RequestPacket-&gt;LengthInBytes value is too large. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>There was an I2C error (NACK) during the transaction. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RequestPacket is NULL </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>The I2C device is not responding to the slave address. EFI_DEVICE_ERROR will be returned if the controller cannot distinguish when the NACK occurred. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Reserved bit set in the SlaveAddress parameter </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory for I2C transaction </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The controller does not support the requested transaction.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function that is invoked when the HTTP Boot driver is about to transmit or has received a packet.</p>
<p>This function is invoked when the HTTP Boot driver is about to transmit or has received packet. Parameters DataType and Received specify the type of event and the format of the buffer pointed to by Data. Due to the polling nature of UEFI device drivers, this callback function should not execute for more than 5 ms. The returned status code determines the behavior of the HTTP Boot driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_HTTP_BOOT_CALLBACK_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The event that occurs in the current state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Received</td><td>TRUE if the callback is being invoked due to a receive event. FALSE if the callback is being invoked due to a transmit event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>The length in bytes of the buffer pointed to by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data, the data type is specified by DataType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Tells the HTTP Boot driver to continue the HTTP Boot process. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Tells the HTTP Boot driver to abort the current HTTP Boot process.</td></tr>
  </table>
  </dd>
</dl>
<p>Enable access to an I2C bus configuration.</p>
<p>This routine must be called at or below TPL_NOTIFY. For synchronous requests this routine must be called at or below TPL_CALLBACK.</p>
<p>Reconfigure the switches and multiplexers in the I2C bus to enable access to a specific I2C bus configuration. Also select the maximum clock frequency for this I2C bus configuration.</p>
<p>This routine uses the I2C Master protocol to perform I2C transactions on the local bus. This eliminates any recursion in the I2C stack for configuration transactions on the same I2C bus. This works because the local I2C bus is idle while the I2C bus configuration is being enabled.</p>
<p>If I2C transactions must be performed on other I2C busses, then the EFI_I2C_HOST_PROTOCOL, the EFI_I2C_IO_PROTCOL, or a third party I2C driver interface for a specific device must be used. This requirement is because the I2C host protocol controls the flow of requests to the I2C controller. Use the EFI_I2C_HOST_PROTOCOL when the I2C device is not enumerated by the EFI_I2C_ENUMERATE_PROTOCOL. Use a protocol produced by a third party driver when it is available or the EFI_I2C_IO_PROTOCOL when the third party driver is not available but the device is enumerated with the EFI_I2C_ENUMERATE_PROTOCOL.</p>
<p>When Event is NULL, EnableI2cBusConfiguration operates synchronously and returns the I2C completion status as its return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I2cBusConfiguration</td><td>Index of an I2C bus configuration. All values in the range of zero to N-1 are valid where N is the total number of I2C bus configurations for an I2C bus. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>Event to signal when the transaction is complete </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I2cStatus</td><td>Buffer to receive the transaction status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When Event is NULL, EnableI2cBusConfiguration operates synchrouously and returns the I2C completion status as its return value. In this case it is recommended to use NULL for I2cStatus. The values returned from EnableI2cBusConfiguration are:</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The asynchronous bus configuration request was successfully started when Event is not NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The bus configuration request completed successfully when Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The bus configuration failed. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>Invalid I2cBusConfiguration value</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves the context driver.</p>
<p>The GetContextfunction returns the context of the protocol, the application identifiers supported by the protocol and the number and the CSN unique identifier of Smart Cards that are present and supported by protocol.</p>
<p>If AidTableSize, AidTable, CsnTableSize, CsnTable or VersionProtocol is NULL, the function does not fail but does not fill in such variables.</p>
<p>In case AidTableSize indicates a buffer too small to hold all the protocol AID table, only the first AidTableSize items of the table are returned in AidTable.</p>
<p>In case CsnTableSize indicates a buffer too small to hold the entire table of Smart Card CSN present, only the first CsnTableSize items of the table are returned in CsnTable.</p>
<p>VersionScEdgeProtocol returns the version of the EFI_SMART_CARD_EDGE_PROTOCOL this driver uses. For this protocol specification value is SMART_CARD_EDGE_PROTOCOL_VERSION_1.</p>
<p>In case of Smart Card removal the internal CSN list is immediately updated, even if a connection is opened with that Smart Card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NumberAidSupported</td><td>Number of AIDs this protocol supports. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">AidTableSize</td><td>On input, number of items allocated for the AID table. On output, number of items returned by protocol. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AidTable</td><td>Table of the AIDs supported by the protocol. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NumberSCPresent</td><td>Number of currently present Smart Cards that are supported by protocol. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CsnTableSize</td><td>On input, the number of items the buffer CSN table can contain. On output, the number of items returned by the protocol. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CsnTable</td><td>Table of the CSN of the Smart Card present and supported by protocol. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VersionScEdgeProtocol</td><td>EFI_SMART_CARD_EDGE_PROTOCOL version.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>NumberSCPresent is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>This function establish a connection with a Smart Card the protocol support.</p>
<p>In case of success the SCardHandle can be used.</p>
<p>If the ScardCsn is NULL the connection is established with the first Smart Card the protocol finds in its table of Smart Card present and supported. Else it establish context with the Smart Card whose CSN given by ScardCsn.</p>
<p>If ScardAid is not NULL the function returns the Smart Card AID the protocol supports. After a successful connect the SCardHandle will remain existing even in case Smart Card removed from Smart Card reader, but all function invoking this SCardHandle will fail. SCardHandle is released only on Disconnect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScardCsn</td><td>CSN of the Smart Card the connection has to be established. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ScardAid</td><td>AID of the Smart Card the connection has been established.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SCardHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>No Smart Card supported by protocol is present, Smart Card with CSN ScardCsn or Reader has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function releases a connection previously established by Connect.</p>
<p>The Disconnect function releases the connection previously established by a Connect. In case the Smart Card or the Smart Card reader has been removed before this call, this function returns EFI_SUCCESS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Smart Card serial number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Csn</td><td>The Card Serial number, 16 bytes array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the name of the Smart Card reader used for this connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ReaderNameLength</td><td>On input, a pointer to the variable that holds the maximal size, in bytes, of ReaderName. On output, the required size, in bytes, for ReaderName. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReaderName</td><td>A pointer to a NULL terminated string that will contain the reader name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ReaderNameLength is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function authenticates a Smart Card user by presenting a PIN code.</p>
<p>The VerifyPinfunction presents a PIN code to the Smart Card.</p>
<p>If Smart Card found the PIN code correct the user is considered authenticated to current application, and the function returns TRUE.</p>
<p>Negative or null PinSize value rejected if PinCodeis not NULL.</p>
<p>A NULL PinCodebuffer means the application didn't know the PIN, in that case:</p>
<ul>
<li>If PinSize value is negative the caller only wants to know if the current chain of the elements Smart Card Edge protocol, Smart Card Reader protocol and Smart Card Reader supports the Secure Pin Entry PCSC V2 functionality.</li>
<li>If PinSize value is positive or null the caller ask to perform the verify PIN using the Secure PIN Entry functionality.</li>
</ul>
<p>In PinCode buffer, the PIN value is always given in plaintext, in case of secure messaging the SMART_CARD_EDGE_PROTOCOL will be in charge of all intermediate treatments to build the correct Smart Card APDU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PinSize</td><td>PIN code buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PinCode</td><td>PIN code to present to the Smart Card. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PinResult</td><td>Result of PIN code presentation to the Smart Card. TRUE when Smard Card founds the PIN code correct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RemainingAttempts</td><td>Number of attempts still possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Pinsize &lt; 0 and Secure PIN Entry functionality not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Bad value for PinSize: value not supported by Smart Card or, negative with PinCode not null. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PinResult is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gives the remaining number of attempts for PIN code presentation.</p>
<p>The number of attempts to present a correct PIN is limited and depends on Smart Card and on PIN.</p>
<p>This function will retrieve the number of remaining possible attempts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RemainingAttempts</td><td>Number of attempts still possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RemainingAttempts is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a specific data from Smart Card.</p>
<p>The function is generic for any kind of data, but driver and application must share an EFI_GUID that identify the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataId</td><td>The type identifier of the data to get. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>On input, in bytes, the size of Data. On output, in bytes, the size of buffer required to store the specified data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Data</td><td>The data buffer in which the data is returned. The type of the data buffer is associated with the DataId. Ignored if *DataSize is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DataId is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DataSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Data is NULL, and *DataSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>DataId unknown for this driver. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of Data is too small for the specified data and the required size is returned in DataSize. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Operation not performed, conditions not fulfilled. PIN not verified. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieve credentials store into the Smart Card.</p>
<p>The function returns a series of items in TLV (Tag Length Value) format.</p>
<p>First TLV item is the header item that gives the number of following containers (0x00, 0x01, Nb containers).</p>
<p>All these containers are a series of 4 TLV items:</p>
<ul>
<li>The certificate item (0x01, certificate size, certificate)</li>
<li>The Key identifier item (0x02, 0x01, key index)</li>
<li>The key type item (0x03, 0x01, key type)</li>
<li>The key size item (0x04, 0x02, key size), key size in number of bits. Numeric multi-bytes values are on big endian format, most significant byte first:</li>
<li>The L field value for certificate (2 bytes)</li>
<li>The L field value for key size (2 bytes)</li>
<li>The value field for key size (2 bytes)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CredentialSize</td><td>On input, in bytes, the size of buffer to store the list of credential. On output, in bytes, the size of buffer required to store the entire list of credentials.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CredentialList</td><td>List of credentials stored into the Smart Card. A list of TLV (Tag Length Value) elements organized in containers array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CredentialSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CredentialList is NULL, if CredentialSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of CredentialList is too small for the specified data and the required size is returned in CredentialSize. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function signs an already hashed data with a Smart Card private key.</p>
<p>This function signs data, actually it is the hash of these data that is given to the function.</p>
<p>SignatureData buffer shall be big enough for signature. Signature size is function key size and key type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyId</td><td>Identifier of the key container, retrieved in a key index item of credentials. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyType</td><td>The key type, retrieved in a key type item of credentials.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HashAlgorithm</td><td>Hash algorithm used to hash the, one of:<ul>
<li>EFI_HASH_ALGORITHM_SHA1_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA256_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA384_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA512_GUID </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PaddingMethod</td><td>Padding method used jointly with hash algorithm, one of:<ul>
<li>EFI_PADDING_RSASSA_PKCS1V1P5_GUID</li>
<li>EFI_PADDING_RSASSA_PSS_GUID </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HashedData</td><td>Hash of the data to sign. Size is function of the HashAlgorithm.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SignatureData</td><td>Resulting signature with private key KeyId. Size is function of the KeyType and key size retrieved in the associated key size item of credentials.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyId is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyType is not valid or not corresponding to KeyId. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashAlgorithm is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashAlgorithm is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PaddingMethod is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PaddingMethod is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashedData is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SignatureData is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Operation not performed, conditions not fulfilled. PIN not verified. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function decrypts data with a PKI/RSA Smart Card private key.</p>
<p>The function decrypts some PKI/RSA encrypted data with private key securely stored into the Smart Card.</p>
<p>The KeyId must reference a key of type SC_EDGE_RSA_EXCHANGE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyId</td><td>Identifier of the key container, retrieved in a key index item of credentials. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HashAlgorithm</td><td>Hash algorithm used to hash the, one of:<ul>
<li>EFI_HASH_ALGORITHM_SHA1_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA256_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA384_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA512_GUID </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PaddingMethod</td><td>Padding method used jointly with hash algorithm, one of:<ul>
<li>EFI_PADDING_NONE_GUID</li>
<li>EFI_PADDING_RSAES_PKCS1V1P5_GUID</li>
<li>EFI_PADDING_RSAES_OAEP_GUID </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EncryptedSize</td><td>Size of data to decrypt. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EncryptedData</td><td>Data to decrypt </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PlaintextSize</td><td>On input, in bytes, the size of buffer to store the decrypted data. On output, in bytes, the size of buffer required to store the decrypted data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PlaintextData</td><td>Buffer for decrypted data, padding removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyId is not valid or associated key not of type SC_EDGE_RSA_EXCHANGE. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashAlgorithm is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashAlgorithm is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PaddingMethod is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PaddingMethod is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>EncryptedSize is 0. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>EncryptedData is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PlaintextSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PlaintextData is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Operation not performed, conditions not fulfilled. PIN not verified. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>PlaintextSize is too small for the plaintext data and the required size is returned in PlaintextSize. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a secret Diffie Hellman agreement calculation that would be used to derive a symmetric encryption / decryption key.</p>
<p>The function compute a DH agreement that should be diversified togenerate a symmetric key to proceed encryption or decryption.</p>
<p>The application and the Smart Card shall agree on the diversification process.</p>
<p>The KeyId must reference a key of one of the types: SC_EDGE_ECDH_256, SC_EDGE_ECDH_384 or SC_EDGE_ECDH_521.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyId</td><td>Identifier of the key container, retrieved in a key index item of credentials. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataQx</td><td>Public key x coordinate. Size is the same as key size for KeyId. Stored in big endian format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataQy</td><td>Public key y coordinate. Size is the same as key size for KeyId. Stored in big endian format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DHAgreement</td><td>Buffer for DH agreement computed. Size must be bigger or equal to key size for KeyId.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyId is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>dataQx is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>dataQy is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DHAgreement is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Operation not performed, conditions not fulfilled. PIN not verified. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>Provides a simple HTTP-like interface to send and receive resources from a REST service.</p>
<p>The SendReceive() function sends an HTTP request to this REST service, and returns a response when the data is retrieved from the service. RequestMessage contains the HTTP request to the REST resource identified by RequestMessage.Request.Url. The ResponseMessage is the returned HTTP response for that request, including any HTTP status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_REST_PROTOCOL instance for a particular REST service. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestMessage</td><td>Pointer to the HTTP request data for this resource. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ResponseMessage</td><td>Pointer to the HTTP response data obtained for this requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation succeeded. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This, RequestMessage, or ResponseMessage are NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred.</td></tr>
  </table>
  </dd>
</dl>
<p>The GetServiceTime() function is an optional interface to obtain the current time from this REST service instance. If this REST service does not support retrieving the time, this function returns EFI_UNSUPPORTED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_REST_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Time</td><td>A pointer to storage to receive a snapshot of the current time of the REST service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation succeeded </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This or Time are NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The RESTful service does not support returning the time. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred.</td></tr>
  </table>
  </dd>
</dl>
<p>Return key generated through EAP process.</p>
<p>The GetKey() function return the key generated through EAP process, so that the 802.11 MAC layer driver can use MSK to derive more keys, e.g. PMK (Pairwise Master Key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_EAP_MANAGEMENT2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Msk</td><td>Pointer to MSK (Master Session Key) buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MskSize</td><td>MSK buffer size. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Emsk</td><td>Pointer to EMSK (Extended Master Session Key) buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EmskSize</td><td>EMSK buffer size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: Msk is NULL. MskSize is NULL. Emsk is NULL. EmskSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>MSK and EMSK are not generated in current session yet.</td></tr>
  </table>
  </dd>
</dl>
<p>BuildResponsePacket() is called during STA and AP authentication is in progress. Supplicant derives the PTK or session keys depend on type of authentication is being employed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_SUPPLICANT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestBuffer</td><td>Pointer to the most recently received EAPOL packet. NULL means the supplicant need initiate the EAP authentication session and send EAPOL-Start message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestBufferSize</td><td>Packet size in bytes for the most recently received EAPOL packet. 0 is only valid when RequestBuffer is NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the buffer to hold the built packet. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferSize</td><td>Pointer to the buffer size in bytes. On input, it is the buffer size provided by the caller. On output, it is the buffer size in fact needed to contain the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The required EAPOL packet is built successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: RequestBuffer is NULL, but RequestSize is NOT 0. RequestBufferSize is 0. Buffer is NULL, but RequestBuffer is NOT 0. BufferSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>BufferSize is too small to hold the response packet. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Current EAPOL session state is NOT ready to build ResponsePacket.</td></tr>
  </table>
  </dd>
</dl>
<p>ProcessPacket() is called to Supplicant driver to encrypt or decrypt the data depending type of authentication type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_SUPPLICANT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FragmentTable</td><td>Pointer to a list of fragment. The caller will take responsible to handle the original FragmentTable while it may be reallocated in Supplicant driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FragmentCount</td><td>Number of fragment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CryptMode</td><td>Crypt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: FragmentTable is NULL. FragmentCount is NULL. CryptMode is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Current supplicant state is NOT Authenticated. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Something wrong decryption the message. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This API is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>Set Supplicant configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_SUPPLICANT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Pointer to the buffer to hold the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Pointer to the buffer size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The Supplicant configuration data is set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: Data is NULL. DataSize is 0. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Get Supplicant configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_SUPPLICANT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Data</td><td>Pointer to the buffer to hold the data. Ignored if DataSize is 0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>Pointer to the buffer size in bytes. On input, it is the buffer size provided by the caller. On output, it is the buffer size in fact needed to contain the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The Supplicant configuration data is got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. DataSize is NULL. Data is NULL if *DataSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The Supplicant configuration data is not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of Data is too small for the specified configuration data and the required size is returned in DataSize.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the Label Storage Area size and the maximum transfer size for the LabelStorageRead and LabelStorageWrite methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_NVDIMM_LABEL_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">SizeOfLabelStorageArea</td><td>The size of the Label Storage Area for the NVDIMM in bytes. </td></tr>
    <tr><td class="paramname">MaxTransferLength</td><td>The maximum number of bytes that can be transferred in a single call to LabelStorageRead or LabelStorageWrite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The size of theLabel Storage Area and maximum transfer size returned are valid. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The Label Storage Area for the NVDIMM device is not currently accessible. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A physical device error occurred and the data transfer failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the label data for the requested offset and length from within the Label Storage Area for the NVDIMM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_NVDIMM_LABEL_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">Offset</td><td>The byte offset within the Label Storage Area to read from. </td></tr>
    <tr><td class="paramname">TransferLength</td><td>Number of bytes to read from the Label Storage Area beginning at the byte Offset specified. A TransferLength of 0 reads no data. </td></tr>
    <tr><td class="paramname">LabelData</td><td>The return label data read at the requested offset and length from within the Label Storage Area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The label data from the Label Storage Area for the NVDIMM was read successfully at the specified Offset and TransferLength and LabelData contains valid data. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Any of the following are true:<ul>
<li>Offset &gt; SizeOfLabelStorageArea reported in the LabelStorageInformation return data.</li>
<li>Offset + TransferLength is &gt; SizeOfLabelStorageArea reported in the LabelStorageInformation return data.</li>
<li>TransferLength is &gt; MaxTransferLength reported in the LabelStorageInformation return data. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The Label Storage Area for the NVDIMM device is not currently accessible and labels cannot be read at this time. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A physical device error occurred and the data transfer failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the label data for the requested offset and length in to the Label Storage Area for the NVDIMM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_NVDIMM_LABEL_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">Offset</td><td>The byte offset within the Label Storage Area to write to. </td></tr>
    <tr><td class="paramname">TransferLength</td><td>Number of bytes to write to the Label Storage Area beginning at the byte Offset specified. A TransferLength of 0 writes no data. </td></tr>
    <tr><td class="paramname">LabelData</td><td>The return label data write at the requested offset and length from within the Label Storage Area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The label data from the Label Storage Area for the NVDIMM written read successfully at the specified Offset and TransferLength. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Any of the following are true:<ul>
<li>Offset &gt; SizeOfLabelStorageArea reported in the LabelStorageInformation return data.</li>
<li>Offset + TransferLength is &gt; SizeOfLabelStorageArea reported in the LabelStorageInformation return data.</li>
<li>TransferLength is &gt; MaxTransferLength reported in the LabelStorageInformation return data. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The Label Storage Area for the NVDIMM device is not currently accessible and labels cannot be written at this time. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A physical device error occurred and the data transfer failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Handles IPsec processing for both inbound and outbound IP packets. Compare with Process() in EFI_IPSEC_PROTOCOL, this interface has the capability to process Option(Extension Header).</p>
<p>The EFI_IPSEC2_PROCESS process routine handles each inbound or outbound packet. The behavior is that it can perform one of the following actions: bypass the packet, discard the packet, or protect the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IPSEC2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NicHandle</td><td>Instance of the network interface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IpVer</td><td>IP version.IPv4 or IPv6. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">IpHead</td><td>Pointer to the IP Header it is either the <a class="el" href="struct_e_f_i___i_p4___h_e_a_d_e_r.html">EFI_IP4_HEADER</a> or EFI_IP6_HEADER. On input, it contains the IP header. On output, 1) in tunnel mode and the traffic direction is inbound, the buffer will be reset to zero by IPsec; 2) in tunnel mode and the traffic direction is outbound, the buffer will reset to be the tunnel IP header.3) in transport mode, the related fielders (like payload length, Next header) in IP header will be modified according to the condition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">LastHead</td><td>For IP4, it is the next protocol in IP header. For IP6 it is the Next Header of the last extension header. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OptionsBuffer</td><td>On input, it contains the options (extensions header) to be processed by IPsec. On output, 1) in tunnel mode and the traffic direction is outbound, it will be set to NULL, and that means this contents was wrapped after inner header and should not be concatenated after tunnel header again; 2) in transport mode and the traffic direction is inbound, if there are IP options (extension headers) protected by IPsec, IPsec will concatenate the those options after the input options (extension headers); 3) on other situations, the output of contents of OptionsBuffer might be same with input's. The caller should take the responsibility to free the buffer both on input and on output. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OptionsLength</td><td>On input, the input length of the options buffer. On output, the output length of the options buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FragmentTable</td><td>Pointer to a list of fragments. On input, these fragments contain the IP payload. On output, 1) in tunnel mode and the traffic direction is inbound, the fragments contain the whole IP payload which is from the IP inner header to the last byte of the packet; 2) in tunnel mode and the traffic direction is the outbound, the fragments contains the whole encapsulated payload which encapsulates the whole IP payload between the encapsulated header and encapsulated trailer fields. 3) in transport mode and the traffic direction is inbound, the fragments contains the IP payload which is from the next layer protocol to the last byte of the packet; 4) in transport mode and the traffic direction is outbound, the fragments contains the whole encapsulated payload which encapsulates the next layer protocol information between the encapsulated header and encapsulated trailer fields. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FragmentCount</td><td>Number of fragments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TrafficDirection</td><td>Traffic direction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RecycleSignal</td><td>Event for recycling of resources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The packet was processed by IPsec successfully. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The packet was discarded. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The IKE negotiation is invoked and the packet was discarded. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of following are TRUE: If OptionsBuffer is NULL; If OptionsLength is NULL; If FragmentTable is NULL; If FragmentCount is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a RAM disk with specified address, size and type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RamDiskBase</td><td>The base address of registered RAM disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RamDiskSize</td><td>The size of registered RAM disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RamDiskType</td><td>The type of registered RAM disk. The <a class="el" href="struct_g_u_i_d.html">GUID</a> can be any of the values defined in section 9.3.6.9, or a vendor defined <a class="el" href="struct_g_u_i_d.html">GUID</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ParentDevicePath</td><td>Pointer to the parent device path. If there is no parent device path then ParentDevicePath is NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>On return, points to a pointer to the device path of the RAM disk device. If ParentDevicePath is not NULL, the returned DevicePath is created by appending a RAM disk node to the parent device path. If ParentDevicePath is NULL, the returned DevicePath is a RAM disk device path without appending. This function is responsible for allocating the buffer DevicePath with the boot service <a class="el" href="_memory_allocation_lib_8h.html#a646c0f82c2a35557dda175dbfcd26e96">AllocatePool()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The RAM disk is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePath or RamDiskType is NULL. RamDiskSize is 0. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A Device Path Protocol instance to be created is already present in the handle database. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The RAM disk register operation fails due to resource limitation.</td></tr>
  </table>
  </dd>
</dl>
<p>Unregister a RAM disk specified by DevicePath.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DevicePath</td><td>A pointer to the device path that describes a RAM Disk device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The RAM disk is unregistered successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The device specified by DevicePath is not a valid ramdisk device path and not supported by the driver. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The RAM disk pointed by DevicePath doesn't exist.</td></tr>
  </table>
  </dd>
</dl>
<p>Assert or deassert the SPI chip select.</p>
<p>This routine is called at TPL_NOTIFY. Update the value of the chip select line for a SPI peripheral. The SPI bus layer calls this routine either in the board layer or in the SPI controller to manipulate the chip select pin at the start and end of a SPI transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_HC_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SpiPeripheral</td><td>The address of an EFI_SPI_PERIPHERAL data structure describing the SPI peripheral whose chip select pin is to be manipulated. The routine may access the ChipSelectParameter field to gain sufficient context to complete the operati on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PinValue</td><td>The value to be applied to the chip select line of the SPI peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The chip select was set as requested </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Support for the chip select is not properly initialized </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The ChipSeLect value or its contents are invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Set up the clock generator to produce the correct clock frequency, phase and polarity for a SPI chip.</p>
<p>This routine is called at TPL_NOTIFY. This routine updates the clock generator to generate the correct frequency and polarity for the SPI clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_HC_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SpiPeripheral</td><td>Pointer to a EFI_SPI_PERIPHERAL data structure from which the routine can access the ClockParameter, ClockPhase and ClockPolarity fields. The routine also has access to the names for the SPI bus and chip which can be used during debugging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ClockHz</td><td>Pointer to the requested clock frequency. The SPI host controller will choose a supported clock frequency which is less then or equal to this value. Specify zero to turn the clock generator off. The actual clock frequency supported by the SPI host controller will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The clock was set up successfully </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The SPI controller was not able to support the frequency requested by ClockHz</td></tr>
  </table>
  </dd>
</dl>
<p>Perform the SPI transaction on the SPI peripheral using the SPI host controller.</p>
<p>This routine is called at TPL_NOTIFY. This routine synchronously returns EFI_SUCCESS indicating that the asynchronous SPI transaction was started. The routine then waits for completion of the SPI transaction prior to returning the final transaction status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_HC_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BusTransaction</td><td>Pointer to a EFI_SPI_BUS_ TRANSACTION containing the description of the SPI transaction to perform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The transaction completed successfully </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The BusTransaction-&gt;WriteBytes value is invalid, or the BusTransaction-&gt;ReadinBytes value is invalid </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The BusTransaction-&gt; Transaction Type is unsupported</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve additional information associated with a PCD token.</p>
<p>This includes information such as the type of value the TokenNumber is associated with as well as possible human readable name that is associated with the token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TokenNumber</td><td>The PCD token number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PcdInfo</td><td>The returned information associated with the requested TokenNumber.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The PCD information was returned successfully </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The PCD service could not find the requested token number.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve additional information associated with a PCD token.</p>
<p>This includes information such as the type of value the TokenNumber is associated with as well as possible human readable name that is associated with the token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>The 128-bit unique value that designates the namespace from which to extract the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TokenNumber</td><td>The PCD token number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PcdInfo</td><td>The returned information associated with the requested TokenNumber.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The PCD information was returned successfully </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The PCD service could not find the requested token number.</td></tr>
  </table>
  </dd>
</dl>
<p>Reset the block device hardware.</p>
<p>The Reset() function resets the block device hardware.</p>
<p>As part of the initialization process, the firmware/device will make a quick but reasonable attempt to verify that the device is functioning.</p>
<p>If the ExtendedVerificationflag is TRUE the firmware may take an extended amount of time to verify the device is operating on reset. Otherwise the reset operation is to occur as quickly as possible.</p>
<p>The hardware verification process is not defined by this specification and is left up to the platform firmware or driver to implement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ExtendedVerification</td><td>Indicates that the driver may perform a more exhausive verification operation of the device during reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The block device was reset. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The block device is not functioning correctly and could not be reset. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the capabilities of the underlying inline cryptographic interface.</p>
<p>The GetCapabilities() function determines whether pre-OS controllable inline crypto is supported by the system for the current disk and, if so, returns the capabilities of the crypto engine.</p>
<p>The caller is responsible for providing the Capabilities structure with a sufficient number of entries.</p>
<p>If the structure is too small, the EFI_BUFFER_TOO_SMALL error code is returned and the CapabilityCount field contains the number of entries needed to contain the capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Capabilities</td><td>Pointer to the <a class="el" href="struct_e_f_i___b_l_o_c_k___i_o___c_r_y_p_t_o___c_a_p_a_b_i_l_i_t_i_e_s.html">EFI_BLOCK_IO_CRYPTO_CAPABILITIES</a> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The ICI is ready for use. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The Capabilities structure was too small. The number of entries needed is returned in the CapabilityCount field of the structure. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>No response was received from the ICI. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the ICI. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Capabilities is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the configuration of the underlying inline cryptographic interface.</p>
<p>The SetConfiguration() function allows the user to set the current configuration of the inline cryptographic interface and should be called before attempting any crypto operations.</p>
<p>This configures the configuration table entries with algorithms, key sizes and keys. Each configured entry can later be referred to by index at the time of storage transaction.</p>
<p>The configuration table index will refer to the combination ofKeyOwnerGuid, Algorithm, and CryptoKey.</p>
<p>KeyOwnerGuid identifies the component taking ownership of the entry. It helps components to identify their own entries, cooperate with other owner components, and avoid conflicts. This Guid identifier is there to help coordination between cooperating components and not a security or synchronization feature. The Nil <a class="el" href="struct_g_u_i_d.html">GUID</a> can be used by a component to release use of entry owned. It is also used to identify potentially available entries (see GetConfiguration).</p>
<p>CryptoKey specifies algorithm-specific key material to use within parameters of selected crypto capability.</p>
<p>This function is called infrequently typically once, on device start, before IO starts. It can be called at later times in cases the number of keysused on the drive is higher than what can be configured at a time or a new key has to be added.</p>
<p>Components setting or changing an entry or entries for a given index or indices must ensure that IO referencing affected indices is temporarily blocked (run-down) at the time of change.</p>
<p>Indices parameters in each parameter table entry allow to set only a portion of the available table entries in the crypto module anywhere from single entry to entire table supported.</p>
<p>If corresponding table entry or entries being set are already in use by another owner the call should be failed and none of the entries should be modified. The interface implementation must enforce atomicity of this operation (should either succeed fully or fail completely without modifying state).</p>
<p>Note that components using GetConfiguration command to discover available entries should be prepared that by the time of calling SetConfiguration the previously available entry may have become occupied. Such components should be prepared to re-try the sequence of operations.</p>
<p>Alternatively EFI_BLOCK_IO_CRYPTO_INDEX_ANY can be used to have the implementation discover and allocate available,if any, indices atomically.</p>
<p>An optional ResultingTable pointer can be provided by the caller to receive the newly configured entries. The array provided by the caller must have at least ConfigurationCount of entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigurationCount</td><td>Number of entries being configured with this call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigurationTable</td><td>Pointer to a table used to populate the configuration table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ResultingTable</td><td>Optional pointer to a table that receives the newly configured entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The ICI is ready for use. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>No response was received from the ICI. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the ICI. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ConfigurationTable is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ConfigurationCount is 0. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not find the requested number of available entries in the configuration table.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the configuration of the underlying inline cryptographic interface.</p>
<p>The GetConfiguration() function allows the user to get the configuration of the inline cryptographic interface.</p>
<p>Retrieves, entirely or partially, the currently configured key table. Note that the keys themselves are not retrieved, but rather just indices, owner GUIDs and capabilities.</p>
<p>If fewer entries than specified by ConfigurationCount are returned, the Index field of the unused entries is set to EFI_BLOCK_IO_CRYPTO_INDEX_ANY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">StartIndex</td><td>Configuration table index at which to start the configuration query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigurationCount</td><td>Number of entries to return in the response table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyOwnerGuid</td><td>Optional parameter to filter response down to entries with a given owner. A pointer to the Nil value can be used to return available entries. Set to NULL when no owner filtering is required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ConfigurationTable</td><td>Table of configured configuration table entries (with no CryptoKey returned): configuration table index, KeyOwnerGuid, Capability. Should have sufficient space to store up to ConfigurationCount entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The ICI is ready for use. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>No response was received from the ICI. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the ICI. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Configuration table is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>StartIndex is out of bounds.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads the requested number of blocks from the device and optionally decrypts them inline.</p>
<p>TheReadExtended() function allows the caller to perform a storage device read operation. The function reads the requested number of blocks from the device and then if Index is specified decrypts them inline. All the blocks are read and decrypted (if decryption requested), or an error is returned.</p>
<p>If there is no media in the device, the function returns EFI_NO_MEDIA. If the MediaId is not the ID for the current media in the device, the function returns EFI_MEDIA_CHANGED.</p>
<p>If EFI_DEVICE_ERROR, EFI_NO_MEDIA, or EFI_MEDIA_CHANGED is returned and nonblocking I/O is being used, the Event associated with this request will not be signaled.</p>
<p>In addition to standard storage transaction parameters (LBA, IO size, and buffer), this command will also specify a configuration table Index and CryptoIvInput when data has to be decrypted inline by the controller after being read from the storage device. If an Index parameter is not specified, no decryption is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>The media ID that the read request is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LBA</td><td>The starting logical block address to read from on the device. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>The size of the Buffer in bytes. This must be a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A pointer to the destination buffer for the data. The caller is responsible for either having implicit or explicit ownership of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Index</td><td>A pointer to the configuration table index. This is optional. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CryptoIvInput</td><td>A pointer to a buffer that contains additional cryptographic parameters as required by the capability referenced by the configuration table index, such as cryptographic initialization vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The read request was queued if Token-&gt; Event is not NULL. The data was read correctly from the device if the Token-&gt;Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while attempting to perform the read operation and/or decryption operation. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The BufferSize parameter is not a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, or the read request contains LBAs that are not valid, or the buffer is not on proper alignment. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CryptoIvInput is incorrect. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Optionally encrypts a specified number of blocks inline and then writes to the device.</p>
<p>The WriteExtended() function allows the caller to perform a storage device write operation. The function encrypts the requested number of blocks inline if Index is specified and then writes them to the device. All the blocks are encrypted (if encryption requested) and written, or an error is returned.</p>
<p>If there is no media in the device, the function returns EFI_NO_MEDIA. If the MediaId is not the ID for the current media in the device, the function returns EFI_MEDIA_CHANGED.</p>
<p>If EFI_DEVICE_ERROR, EFI_NO_MEDIA, or EFI_MEDIA_CHANGED is returned and nonblocking I/O is being used, the Event associated with this request will not be signaled.</p>
<p>In addition to standard storage transaction parameters (LBA, IO size, and buffer), this command will also specify a configuration table Index and a CryptoIvInput when data has to be decrypted inline by the controller before being written to the storage device. If no Index parameter is specified, no encryption is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>The media ID that the read request is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LBA</td><td>The starting logical block address to read from on the device. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>The size of the Buffer in bytes. This must be a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>A pointer to the source buffer for the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Index</td><td>A pointer to the configuration table index. This is optional. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CryptoIvInput</td><td>A pointer to a buffer that contains additional cryptographic parameters as required by the capability referenced by the configuration table index, such as cryptographic initialization vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The request to encrypt (optionally) and write was queued if Event is not NULL. The data was encrypted (optionally) and written correctly to the device if the Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while attempting to encrypt blocks or to perform the write operation. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The BufferSize parameter is not a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, or the write request contains LBAs that are not valid, or the buffer is not on proper alignment. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CryptoIvInput is incorrect. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Flushes all modified data toa physical block device.</p>
<p>The FlushBlocks() function flushes all modified data to the physical block device. Any modified data that has to be encrypted must have been already encrypted as a part of WriteExtended() operation - inline crypto operation cannot be a part of flush operation.</p>
<p>All data written to the device prior to the flush must be physically written before returning EFI_SUCCESS from this function. This would include any cached data the driver may have cached, and cached data the device may have cached. A flush may cause a read request following the flush to force a device access.</p>
<p>If EFI_DEVICE_ERROR, EFI_NO_MEDIA, EFI_WRITE_PROTECTED or EFI_MEDIA_CHANGED is returned and non-blocking I/O is being used, the Event associated with this request will not be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The flush request was queued if Event is not NULL. All outstanding data was written correctly to the device if the Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while attempting to write data. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Set TLS session data.</p>
<p>The SetSessionData() function set data for a new TLS session. All session data should be set before BuildResponsePacket() invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_TLS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>TLS session data type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Pointer to session data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Total size of session data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The TLS session data is set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Data is NULL. DataSize is 0. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>If the DataType is one of below: EfiTlsClientRandom EfiTlsServerRandom EfiTlsKeyMaterial </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Current TLS session state is NOT EfiTlsSessionStateNotStarted. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Get TLS session data.</p>
<p>The GetSessionData() function return the TLS session information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_TLS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>TLS session data type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>Pointer to session data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>Total size of session data. On input, it means the size of Data buffer. On output, it means the size of copied Data buffer if EFI_SUCCESS, and means the size of desired Data buffer if EFI_BUFFER_TOO_SMALL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The TLS session data is got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. DataSize is NULL. Data is NULL if *DataSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The TLS session data is not found. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The DataType is not ready in current session state. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the data.</td></tr>
  </table>
  </dd>
</dl>
<p>Build response packet according to TLS state machine. This function is only valid for alert, handshake and change_cipher_spec content type.</p>
<p>The BuildResponsePacket() function builds TLS response packet in response to the TLS request packet specified by RequestBuffer and RequestSize. If RequestBuffer is NULL and RequestSize is 0, and TLS session status is EfiTlsSessionNotStarted, the TLS session will be initiated and the response packet needs to be ClientHello. If RequestBuffer is NULL and RequestSize is 0, and TLS session status is EfiTlsSessionClosing, the TLS session will be closed and response packet needs to be CloseNotify. If RequestBuffer is NULL and RequestSize is 0, and TLS session status is EfiTlsSessionError, the TLS session has errors and the response packet needs to be Alert message based on error type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_TLS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestBuffer</td><td>Pointer to the most recently received TLS packet. NULL means TLS need initiate the TLS session and response packet need to be ClientHello. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestSize</td><td>Packet size in bytes for the most recently received TLS packet. 0 is only valid when RequestBuffer is NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the buffer to hold the built packet. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferSize</td><td>Pointer to the buffer size in bytes. On input, it is the buffer size provided by the caller. On output, it is the buffer size in fact needed to contain the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The required TLS packet is built successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. RequestBuffer is NULL but RequestSize is NOT 0. RequestSize is 0 but RequestBuffer is NOT NULL. BufferSize is NULL. Buffer is NULL if *BufferSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>BufferSize is too small to hold the response packet. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Current TLS session state is NOT ready to build ResponsePacket. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Something wrong build response packet.</td></tr>
  </table>
  </dd>
</dl>
<p>Decrypt or encrypt TLS packet during session. This function is only valid after session connected and for application_data content type.</p>
<p>The ProcessPacket () function process each inbound or outbound TLS APP packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_TLS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FragmentTable</td><td>Pointer to a list of fragment. The caller will take responsible to handle the original FragmentTable while it may be reallocated in TLS driver. If CryptMode is EfiTlsEncrypt, on input these fragments contain the TLS header and plain text TLS APP payload; on output these fragments contain the TLS header and cipher text TLS APP payload. If CryptMode is EfiTlsDecrypt, on input these fragments contain the TLS header and cipher text TLS APP payload; on output these fragments contain the TLS header and plain text TLS APP payload. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FragmentCount</td><td>Number of fragment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CryptMode</td><td>Crypt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. FragmentTable is NULL. FragmentCount is NULL. CryptoMode is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Current TLS session state is NOT EfiTlsSessionDataTransferring. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Something wrong decryption the message. TLS session status will become EfiTlsSessionError. The caller need call BuildResponsePacket() to generate Error Alert message and send it out. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>No enough resource to finish the operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Send a security protocol command to a device.</p>
<p>The SendData function sends a security protocol command containing the payload PayloadBuffer to the given MediaId. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. If the underlying protocol command requires a specific padding for the command payload, the SendData function shall add padding bytes to the command payload to satisfy the padding requirements.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL OUT command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED SEND commands defined in ATA8-ACS if PayloadBufferSize is non-zero. If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBuffer is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given MediaId does not support security protocol commands, the function shall return EFI_UNSUPPORTED. If there is no media in the device, the function returns EFI_NO_MEDIA. If the MediaId is not the ID for the current media in the device, the function returns EFI_MEDIA_CHANGED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the function shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to receive data from. </td></tr>
    <tr><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given MediaId does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the BIOS base address.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS base address works with the protect range registers to protect portions of the SPI NOR flash from erase and write operat ions. The BIOS calls this API prior to passing control to the OS loader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BiosBaseAddress</td><td>The BIOS base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The BIOS base address was properly set </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BiosBaseAddress &gt; This-&gt;MaximumOffset </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The BIOS base address was already set or not a legacy SPI host controller</td></tr>
  </table>
  </dd>
</dl>
<p>Clear the SPI protect range registers.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS uses this routine to set an initial condition on the SPI protect range registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_FLASH_PROTOCOL data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The registers were successfully cleared </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Not a legacy SPI host controller</td></tr>
  </table>
  </dd>
</dl>
<p>Set the next protect range register.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS sets the protect range register to prevent write and erase operations to a portion of the SPI NOR flash device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BiosAddress</td><td>Address within a 4 KiB block to start protecting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlocksToProtect</td><td>The number of 4 KiB blocks to protect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The register was successfully updated </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BiosAddress &lt; This-&gt;BiosBaseAddress, or </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BlocksToProtect * 4 KiB &gt; This-&gt;MaximumRangeBytes, or BiosAddress - This-&gt;BiosBaseAddress<ul>
<li>(BlocksToProtect * 4 KiB) &gt; This-&gt;MaximumRangeBytes </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>No protect range register available </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Call This-&gt;SetBaseAddress because the BIOS base address is not set Not a legacy SPI host controller</td></tr>
  </table>
  </dd>
</dl>
<p>Lock the SPI controller configuration.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine locks the SPI controller's configuration so that the software is no longer able to update: Prefix table Opcode menu Opcode type table BIOS base address Protect range registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_FLASH_PROTOCOL data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SPI controller was successfully locked </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The SPI controller was already locked </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Not a legacy SPI host controller</td></tr>
  </table>
  </dd>
</dl>
<p>Open I/O aperture.</p>
<p>This function opens an I/O aperture in a ISA Host Controller for the I/O addresses specified by IoAddress to IoAddress + IoLength - 1. It may be possible that a single hardware aperture may be used for more than one device. This function tracks the number of times that each aperture is referenced, and does not close the hardware aperture (via CloseIoAperture()) until there are no more references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to this instance of the EFI_ISA_HC_PROTOCOL. </td></tr>
    <tr><td class="paramname">IoAddress</td><td>An unsigned integer that specifies the first byte of the I/O space required. </td></tr>
    <tr><td class="paramname">IoLength</td><td>An unsigned integer that specifies the number of bytes of the I/O space required. </td></tr>
    <tr><td class="paramname">IoApertureHandle</td><td>A pointer to the returned I/O aperture handle. This value can be used on subsequent calls to CloseIoAperture().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The I/O aperture was opened successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The ISA Host Controller is a subtractive-decode controller. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is no available I/O aperture.</td></tr>
  </table>
  </dd>
</dl>
<p>Close I/O aperture.</p>
<p>This function closes a previously opened I/O aperture handle. If there are no more I/O aperture handles that refer to the hardware I/O aperture resource, then the hardware I/O aperture is closed. It may be possible that a single hardware aperture may be used for more than one device. This function tracks the number of times that each aperture is referenced, and does not close the hardware aperture (via CloseIoAperture()) until there are no more references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to this instance of the EFI_ISA_HC_PROTOCOL. </td></tr>
    <tr><td class="paramname">IoApertureHandle</td><td>The I/O aperture handle previously returned from a call to OpenIoAperture().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The IO aperture was closed successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Service to retrieves the number of logical processor in the platform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NumberOfProcessors</td><td>Pointer to the total number of logical processors in the system, including the BSP and all APs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The number of processors was retrieved successfully </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>NumberOfProcessors is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>This service allows the caller to invoke a procedure one of the application processors (AP). This function uses an optional token parameter to support blocking and non-blocking modes. If the token is passed into the call, the function will operate in a non-blocking fashion and the caller can check for completion with CheckOnProcedure or WaitForProcedure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the procedure to be run on the designated target AP of the system. Type EFI_AP_PROCEDURE2 is defined below in related definitions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CpuNumber</td><td>The zero-based index of the processor number of the target AP, on which the code stream is supposed to run. If the number points to the calling processor then it will not run the supplied code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroseconds</td><td>Indicates the time limit in microseconds for this AP to finish execution of Procedure, either for blocking or non-blocking mode. Zero means infinity. If the timeout expires before this AP returns from Procedure, then Procedure on the AP is terminated. If the timeout expires in blocking mode, the call returns EFI_TIMEOUT. If the timeout expires in non-blocking mode, the timeout determined can be through CheckOnProcedure or WaitForProcedure. Note that timeout support is optional. Whether an implementation supports this feature, can be determined via the Attributes data member. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ProcedureArguments</td><td>Allows the caller to pass a list of parameters to the code that is run by the AP. It is an optional common mailbox between APs and the caller to share information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>This is parameter is broken into two components: 1.Token-&gt;Completion is an optional parameter that allows the caller to execute the procedure in a blocking or non-blocking fashion. If it is NULL the call is blocking, and the call will not return until the AP has completed the procedure. If the token is not NULL, the call will return immediately. The caller can check whether the procedure has completed with CheckOnProcedure or WaitForProcedure. 2.Token-&gt;Status The implementation updates the address pointed at by this variable with the status code returned by Procedure when it completes execution on the target AP, or with EFI_TIMEOUT if the Procedure fails to complete within the optional timeout. The implementation will update this variable with EFI_NOT_READY prior to starting Procedure on the target AP. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CPUStatus</td><td>This optional pointer may be used to get the status code returned by Procedure when it completes execution on the target AP, or with EFI_TIMEOUT if the Procedure fails to complete within the optional timeout. The implementation will update this variable with EFI_NOT_READY prior to starting Procedure on the target AP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In the blocking case, this indicates that Procedure has completed execution on the target AP. In the non-blocking case this indicates that the procedure has been successfully scheduled for execution on the target AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The input arguments are out of range. Either the target AP is the caller of the function, or the Procedure or Token is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>If the target AP is busy executing another procedure </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>Token is already in use for another procedure </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before the specified AP has finished</td></tr>
  </table>
  </dd>
</dl>
<p>This service allows the caller to invoke a procedure on all running application processors (AP) except the caller. This function uses an optional token parameter to support blocking and nonblocking modes. If the token is passed into the call, the function will operate in a non-blocking fashion and the caller can check for completion with CheckOnProcedure or WaitForProcedure.</p>
<p>It is not necessary for the implementation to run the procedure on every processor on the platform. Processors that are powered down in such a way that they cannot respond to interrupts, may be excluded from the broadcast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the code stream to be run on the APs that have entered MM. Type EFI_AP_PROCEDURE is defined below in related definitions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroseconds</td><td>Indicates the time limit in microseconds for the APs to finish execution of Procedure, either for blocking or non-blocking mode. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. If the timeout expires in blocking mode, the call returns EFI_TIMEOUT. If the timeout expires in non-blocking mode, the timeout determined can be through CheckOnProcedure or WaitForProcedure. Note that timeout support is optional. Whether an implementation supports this feature can be determined via the Attributes data member. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ProcedureArguments</td><td>Allows the caller to pass a list of parameters to the code that is run by the AP. It is an optional common mailbox between APs and the caller to share information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>This is parameter is broken into two components: 1.Token-&gt;Completion is an optional parameter that allows the caller to execute the procedure in a blocking or non-blocking fashion. If it is NULL the call is blocking, and the call will not return until the AP has completed the procedure. If the token is not NULL, the call will return immediately. The caller can check whether the procedure has completed with CheckOnProcedure or WaitForProcedure. 2.Token-&gt;Status The implementation updates the address pointed at by this variable with the status code returned by Procedure when it completes execution on the target AP, or with EFI_TIMEOUT if the Procedure fails to complete within the optional timeout. The implementation will update this variable with EFI_NOT_READY prior to starting Procedure on the target AP </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CPUStatus</td><td>This optional pointer may be used to get the individual status returned by every AP that participated in the broadcast. This parameter if used provides the base address of an array to hold the EFI_STATUS value of each AP in the system. The size of the array can be ascertained by the GetNumberOfProcessors function. As mentioned above, the broadcast may not include every processor in the system. Some implementations may exclude processors that have been powered down in such a way that they are not responsive to interrupts. Additionally the broadcast excludes the processor which is making the BroadcastProcedure call. For every excluded processor, the array entry must contain a value of EFI_NOT_STARTED</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In the blocking case, this indicates that Procedure has completed execution on the APs. In the non-blocking case this indicates that the procedure has been successfully scheduled for execution on the APs. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure or Token is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>If a target AP is busy executing another procedure. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before all enabled APs have finished. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>Before the AP procedure associated with the Token is finished, the same Token cannot be used to dispatch or broadcast another procedure.</td></tr>
  </table>
  </dd>
</dl>
<p>This service allows the caller to set a startup procedure that will be executed when an AP powers up from a state where core configuration and context is lost. The procedure is execution has the following properties:</p>
<ol type="1">
<li>The procedure executes before the processor is handed over to the operating system.</li>
<li>All processors execute the same startup procedure.</li>
<li>The procedure may run in parallel with other procedures invoked through the functions in this protocol, or with processors that are executing an MM handler or running in the operating system.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the code stream to be run on the designated target AP of the system. Type EFI_AP_PROCEDURE is defined below in Volume 2 with the related definitions of <a class="el" href="struct___e_f_i___m_p___s_e_r_v_i_c_e_s___p_r_o_t_o_c_o_l.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs</a>. If caller may pass a value of NULL to deregister any existing startup procedure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ProcedureArguments</td><td>Allows the caller to pass a list of parameters to the code that is run by the AP. It is an optional common mailbox between APs and the caller to share information</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The Procedure has been set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>When non-blocking execution of a procedure on an AP is invoked with DispatchProcedure, via the use of a token, this function can be used to check for completion of the procedure on the AP. The function takes the token that was passed into the DispatchProcedure call. If the procedure is complete, and therefore it is now possible to run another procedure on the same AP, this function returns EFI_SUCESS. In this case the status returned by the procedure that executed on the AP is returned in the token's Status field. If the procedure has not yet completed, then this function returns EFI_NOT_READY.</p>
<p>When a non-blocking execution of a procedure is invoked with BroadcastProcedure, via the use of a token, this function can be used to check for completion of the procedure on all the broadcast APs. The function takes the token that was passed into the BroadcastProcedure call. If the procedure is complete on all broadcast APs this function returns EFI_SUCESS. In this case the Status field in the token passed into the function reflects the overall result of the invocation, which may be EFI_SUCCESS, if all executions succeeded, or the first observed failure. If the procedure has not yet completed on the broadcast APs, the function returns EFI_NOT_READY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>This parameter describes the token that was passed into DispatchProcedure or BroadcastProcedure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Procedure has completed. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The Procedure has not completed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Token or Token-&gt;Completion is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Token is not currently in use for a non-blocking call</td></tr>
  </table>
  </dd>
</dl>
<p>When a non-blocking execution of a procedure on an AP is invoked via DispatchProcedure, this function will block the caller until the remote procedure has completed on the designated AP. The non-blocking procedure invocation is identified by the Token parameter, which must match the token that used when DispatchProcedure was called. Upon completion the status returned by the procedure that executed on the AP is used to update the token's Status field.</p>
<p>When a non-blocking execution of a procedure on an AP is invoked via BroadcastProcedure this function will block the caller until the remote procedure has completed on all of the APs that entered MM. The non-blocking procedure invocation is identified by the Token parameter, which must match the token that used when BroadcastProcedure was called. Upon completion the overall status returned by the procedures that executed on the broadcast AP is used to update the token's Status field. The overall status may be EFI_SUCCESS, if all executions succeeded, or the first observed failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>This parameter describes the token that was passed into DispatchProcedure or BroadcastProcedure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Procedure has completed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Token or Token-&gt;Completion is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Token is not currently in use for a non-blocking call</td></tr>
  </table>
  </dd>
</dl>
<p>Erase a specified number of device blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>The media ID that the erase request is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LBA</td><td>The starting logical block address to be erased. The caller is responsible for erasing only legitimate locations. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Size</td><td>The size in bytes to be erased. This must be a multiple of the physical block size of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The erase request was queued if Event is not NULL. The data was erased correctly to the device if the Event is NULL.to the device. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be erased due to write protection. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while attempting to perform the erase operation. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The erase request contains LBAs that are not valid. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media.</td></tr>
  </table>
  </dd>
</dl>
<p>Queue an I2C transaction for execution on the I2C device.</p>
<p>This routine must be called at or below TPL_NOTIFY. For synchronous requests this routine must be called at or below TPL_CALLBACK.</p>
<p>This routine queues an I2C transaction to the I2C controller for execution on the I2C bus.</p>
<p>When Event is NULL, QueueRequest() operates synchronously and returns the I2C completion status as its return value.</p>
<p>When Event is not NULL, QueueRequest() synchronously returns EFI_SUCCESS indicating that the asynchronous I2C transaction was queued. The values above are returned in the buffer pointed to by I2cStatus upon the completion of the I2C transaction when I2cStatus is not NULL.</p>
<p>The upper layer driver writer provides the following to the platform vendor:</p>
<ol type="1">
<li>Vendor specific <a class="el" href="struct_g_u_i_d.html">GUID</a> for the I2C part</li>
<li>Guidance on proper construction of the slave address array when the I2C device uses more than one slave address. The I2C bus protocol uses the SlaveAddressIndex to perform relative to physical address translation to access the blocks of hardware within the I2C device.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_IO_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SlaveAddressIndex</td><td>Index value into an array of slave addresses for the I2C device. The values in the array are specified by the board designer, with the third party I2C device driver writer providing the slave address order.</td></tr>
  </table>
  </dd>
</dl>
<p>For devices that have a single slave address, this value must be zero. If the I2C device uses more than one slave address then the third party (upper level) I2C driver writer needs to specify the order of entries in the slave address array.</p>
<p>Third Party I2C Drivers" section in I2cMaster.h. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>Event to signal for asynchronous transactions, NULL for synchronous transactions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestPacket</td><td>Pointer to an <a class="el" href="struct_e_f_i___i2_c___r_e_q_u_e_s_t___p_a_c_k_e_t.html">EFI_I2C_REQUEST_PACKET</a> structure describing the I2C transaction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I2cStatus</td><td>Optional buffer to receive the I2C transaction completion status</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The asynchronous transaction was successfully queued when Event is not NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The transaction completed successfully when Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The RequestPacket-&gt;LengthInBytes value is too large. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>There was an I2C error (NACK) during the transaction. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RequestPacket is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>The EFI_I2C_HOST_PROTOCOL could not set the bus configuration required to access this I2C device. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>The I2C device is not responding to the slave address selected by SlaveAddressIndex. EFI_DEVICE_ERROR will be returned if the controller cannot distinguish when the NACK occurred. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory for I2C transaction </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The controller does not support the requested transaction.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns information about what USB port type was attached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PortType</td><td>Returns the USB port type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request or there is no USB port attached to the device.</td></tr>
  </table>
  </dd>
</dl>
<p>Configures endpoints based on supplied device and configuration descriptors.</p>
<p>Assuming that the hardware has already been initialized, this function configures the endpoints using the device information supplied by DeviceInfo, activates the port, and starts receiving USB events.</p>
<p>This function must ignore the bMaxPacketSize0field of the Standard Device Descriptor and the wMaxPacketSize field of the Standard Endpoint Descriptor that are made available through DeviceInfo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DeviceInfo</td><td>A pointer to EFI_USBFN_DEVICE_INFO instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the maximum packet size of the specified endpoint type for the supplied bus speed.</p>
<p>If the BusSpeed is UsbBusSpeedUnknown, the maximum speed the underlying controller supports is assumed.</p>
<p>This protocol currently does not support isochronous or interrupt transfers. Future revisions of this protocol may eventually support it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOLinstance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointType</td><td>Endpoint type as defined as EFI_USB_ENDPOINT_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BusSpeed</td><td>Bus speed as defined as EFI_USB_BUS_SPEED. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MaxPacketSize</td><td>The maximum packet size, in bytes, of the specified endpoint type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns device specific information based on the supplied identifier as a Unicode string.</p>
<p>If the supplied Buffer isn't large enough, or is NULL, the method fails with EFI_BUFFER_TOO_SMALL and the required size is returned through BufferSize. All returned strings are in Unicode format.</p>
<p>An Id of EfiUsbDeviceInfoUnknown is treated as an invalid parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOLinstance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Id</td><td>The requested information id.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>On input, the size of the Buffer in bytes. On output, the amount of data returned in Buffer in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A pointer to a buffer to returnthe requested information as a Unicode string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: BufferSize is NULL. BufferSize is not 0 and Buffer is NULL. Id in invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the buffer. BufferSize has been updated with the size needed to hold the request string.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the vendor-id and product-id of the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Vid</td><td>Returned vendor-id of the device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Pid</td><td>Returned product-id of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Unable to return the vendor-id or the product-id.</td></tr>
  </table>
  </dd>
</dl>
<p>Aborts the transfer on the specified endpoint.</p>
<p>This function should fail with EFI_INVALID_PARAMETER if the specified direction is incorrect for the endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the endpoint on which the ongoing transfer needs to be canceled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the stall state on the specified endpoint.</p>
<p>This function should fail with EFI_INVALID_PARAMETER if the specified direction is incorrect for the endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">State</td><td>Boolean, true value indicates that the endpoint is in a stalled state, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets or clears the stall state on the specified endpoint.</p>
<p>This function should fail with EFI_INVALID_PARAMETER if the specified direction is incorrect for the endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">State</td><td>Requested stall state on the specified endpoint. True value causes the endpoint to stall; false value clears an existing stall.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called repeatedly to get information on USB bus states, receive-completion and transmit-completion events on the endpoints, and notification on setup packet on endpoint 0.</p>
<p>A class driver must call <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a27b79b326e4146b395d8bc8b8f704b69">EFI_USBFN_IO_PROTOCOL.EventHandler()</a>repeatedly to receive updates on the transfer status and number of bytes transferred on various endpoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Message</td><td>Indicates the event that initiated this notification. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PayloadSize</td><td>On input, the size of the memory pointed by Payload. On output, the amount ofdata returned in Payload. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Payload</td><td>A pointer to EFI_USBFN_MESSAGE_PAYLOAD instance to return additional payload for current message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The Supplied buffer is not large enough to hold the message payload.</td></tr>
  </table>
  </dd>
</dl>
<p>This function handles transferring data to or from the host on the specified endpoint, depending on the direction specified.</p>
<p>A class driver must call <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a27b79b326e4146b395d8bc8b8f704b69">EFI_USBFN_IO_PROTOCOL.EventHandler()</a> repeatedly to receive updates on the transfer status and the number of bytes transferred on various endpoints. Upon an update of the transfer status, the Buffer field of the EFI_USBFN_TRANSFER_RESULT structure (as described in the function description for <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a27b79b326e4146b395d8bc8b8f704b69">EFI_USBFN_IO_PROTOCOL.EventHandler()</a>) must be initialized with the Buffer pointer that was supplied to this method.</p>
<p>The overview of the call sequence is illustrated in the Figure 54.</p>
<p>This function should fail with EFI_INVALID_PARAMETER if the specified direction is incorrect for the endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the endpoint on which TX or RX transfer needs to take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferSize</td><td>If Direction is EfiUsbEndpointDirectionDeviceRx: On input, the size of the Bufferin bytes. On output, the amount of data returned in Buffer in bytes. If Direction is EfiUsbEndpointDirectionDeviceTx: On input, the size of the Bufferin bytes. On output, the amount of data transmitted in bytes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Buffer</td><td>If Direction is EfiUsbEndpointDirectionDeviceRx: The Buffer to return the received data. If Directionis EfiUsbEndpointDirectionDeviceTx: The Buffer that contains the data to be transmitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the maximum supported transfer size.</p>
<p>Returns the maximum number of bytes that the underlying controller can accommodate in a single transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MaxTransferSize</td><td>The maximum supported transfer size, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates a transfer buffer of the specified sizethat satisfies the controller requirements.</p>
<p>The AllocateTransferBuffer() function allocates a memory region of Size bytes and returns the address of the allocated memory that satisfies the underlying controller requirements in the location referenced by Buffer.</p>
<p>The allocated transfer buffer must be freed using a matching call to <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#ad957c3237a95273701e8c335494bf906">EFI_USBFN_IO_PROTOCOL.FreeTransferBuffer()</a>function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Size</td><td>The number of bytes to allocate for the transfer buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The requested transfer buffer could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Deallocates the memory allocated for the transfer buffer by the <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a4861402e6f8b48c020747af38fe31477">EFI_USBFN_IO_PROTOCOL.AllocateTransferBuffer()</a> function.</p>
<p>The <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#ad957c3237a95273701e8c335494bf906">EFI_USBFN_IO_PROTOCOL.FreeTransferBuffer()</a> function deallocates the memory specified by Buffer. The Buffer that is freed must have been allocated by <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a4861402e6f8b48c020747af38fe31477">EFI_USBFN_IO_PROTOCOL.AllocateTransferBuffer()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>A pointer to the transfer buffer to deallocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>This function supplies power to the USB controller if needed and initializes the hardware and the internal data structures. The port must not be activated by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error.</td></tr>
  </table>
  </dd>
</dl>
<p>This function stops the USB hardware device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the configuration policy for the specified non-control endpoint.</p>
<p>This function can only be called before <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#ab8e3afdcd981ebd3bc9e11901121254f">EFI_USBFN_IO_PROTOCOL.StartController()</a> or after <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a190c410d7a8d667a41cc34d5e35e5e52">EFI_USBFN_IO_PROTOCOL.StopController()</a> has been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the non-control endpoint for which the policy needs to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PolicyType</td><td>Policy type the user is trying to set for the specified non-control endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>The size of the Bufferin bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>The new value for the policy parameter that PolicyType specifies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Changing this policy value is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the configuration policy for the specified non-control endpoint.</p>
<p>This function can only be called before <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#ab8e3afdcd981ebd3bc9e11901121254f">EFI_USBFN_IO_PROTOCOL.StartController()</a> or after <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a190c410d7a8d667a41cc34d5e35e5e52">EFI_USBFN_IO_PROTOCOL.StopController()</a> has been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the non-control endpoint for which the policy needs to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PolicyType</td><td>Policy type the user is trying to retrieve for the specified non-control endpoint. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferSize</td><td>On input, the size of Bufferin bytes. On output, the amount of data returned in Bufferin bytes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Buffer</td><td>A pointer to a buffer to return requested endpoint policy value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The specified policy value is not supported. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>Supplied buffer is not large enough to hold requested policy value.</td></tr>
  </table>
  </dd>
</dl>
<p>Terminate outstanding asynchronous requests to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>All outstanding requests were successfully terminated. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the cancel operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads a specified number of bytes from a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to be read. </td></tr>
    <tr><td class="paramname">Offset</td><td>The starting byte offset on the logical block I/O device to read from. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. If this field is NULL, synchronous/blocking IO is performed. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>The size in bytes of Buffer. The number of bytes to read from the device. </td></tr>
    <tr><td class="paramname">Buffer</td><td>A pointer to the destination buffer for the data. The caller is responsible either having implicit or explicit ownership of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was read correctly from the device. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. Event will be signaled upon completion. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the write. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no medium in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHNAGED</td><td>The MediaId is not for the current medium. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The read request contains device addresses that are not valid for the device. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes a specified number of bytes to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to be written. </td></tr>
    <tr><td class="paramname">Offset</td><td>The starting byte offset on the logical block I/O device to write to. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. If this field is NULL, synchronous/blocking IO is performed. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>The size in bytes of Buffer. The number of bytes to write to the device. </td></tr>
    <tr><td class="paramname">Buffer</td><td>A pointer to the buffer containing the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was written correctly to the device. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. Event will be signaled upon completion. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the write operation. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no medium in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHNAGED</td><td>The MediaId is not for the current medium. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The write request contains device addresses that are not valid for the device. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Flushes all modified data to the physical device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to be written. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. If this field is NULL, synchronous/blocking IO is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was flushed successfully to the device. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. Event will be signaled upon completion. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the write operation. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no medium in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHNAGED</td><td>The MediaId is not for the current medium. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Set EAP configuration data.</p>
<p>The SetData() function sets EAP configuration to non-volatile storage or volatile storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_EAP_CONFIGURATION_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EapType</td><td>EAP type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Pointer to configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Total size of configuration data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The EAP configuration data is set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: Data is NULL. DataSize is 0. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The EapType or DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Get EAP configuration data.</p>
<p>The GetData() function gets EAP configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_EAP_CONFIGURATION_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EapType</td><td>EAP type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>Pointer to configuration data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>Total size of configuration data. On input, it means the size of Data buffer. On output, it means the size of copied Data buffer if EFI_SUCCESS, and means the size of desired Data buffer if EFI_BUFFER_TOO_SMALL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The EAP configuration data is got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: Data is NULL. DataSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The EapType or DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The EAP configuration data is not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Processes a buffer containing binary DER-encoded PKCS7 signature. The signed data content may be embedded within the buffer or separated. Funtion verifies the signature of the content is valid and signing certificate was not revoked and is contained within a list of trusted signers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_PKCS7_VERIFY_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SignedData</td><td>Points to buffer containing ASN.1 DER-encoded PKCS7 signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SignedDataSize</td><td>The size of SignedData buffer in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InData</td><td>In case of detached signature, InData points to buffer containing the raw message data previously signed and to be verified by function. In case of SignedData containing embedded data, InData must be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InDataSize</td><td>When InData is used, the size of InData buffer in bytes. When InData is NULL. This parameter must be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AllowedDb</td><td>Pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. The <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures contain lists of X.509 certificates of approved signers. Function recognizes signer certificates of type EFI_CERT_X509_GUID. Any hash certificate in AllowedDb list is ignored by this function. Function returns success if signer of the buffer is within this list (and not within RevokedDb). This parameter is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RevokedDb</td><td>Optional pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. List of X.509 certificates of revoked signers and revoked file hashes. Except as noted in description of TimeStampDb signature verification will always fail if the signer of the file or the hash of the data component of the buffer is in RevokedDb list. This list is optional and caller may pass Null or pointer to NULL if not required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeStampDb</td><td>Optional pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. This parameter can be used to pass a list of X.509 certificates of trusted time stamp signers. This list is optional and caller must pass Null or pointer to NULL if not required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Content</td><td>On input, points to an optional caller-allocated buffer into which the function will copy the content portion of the file after verification succeeds. This parameter is optional and if NULL, no copy of content from file is performed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ContentSize</td><td>On input, points to the size in bytes of the optional buffer Content previously allocated by caller. On output, if the verification succeeds, the value referenced by ContentSize will contain the actual size of the content from signed file. If ContentSize indicates the caller-allocated buffer is too small to contain content, an error is returned, and ContentSize will be updated with the required size. This parameter must be 0 if Content is Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Content signature was verified against hash of content, the signer's certificate was not found in RevokedDb, and was found in AllowedDb or if in signer is found in both AllowedDb and RevokedDb, the signing was allowed by reference to TimeStampDb as described above, and no hash matching content hash was found in RevokedDb. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The SignedData buffer was correctly formatted but signer was in RevokedDb or not in AllowedDb. Also returned if matching content hash found in RevokedDb. </td></tr>
    <tr><td class="paramname">EFI_COMPROMISED_DATA</td><td>Calculated hash differs from signed hash. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SignedData is NULL or SignedDataSize is zero. AllowedDb is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Content is not NULL and ContentSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Unsupported or invalid format in TimeStampDb, RevokedDb or AllowedDb list contents was detected. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Content not found because InData is NULL and no content embedded in SignedData. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The SignedData buffer was not correctly formatted for processing by the function. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Signed data embedded in SignedData but InData is not NULL. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of buffer indicated by ContentSize is too small to hold the content. ContentSize updated to required size.</td></tr>
  </table>
  </dd>
</dl>
<p>Processes a buffer containing binary DER-encoded detached PKCS7 signature. The hash of the signed data content is calculated and passed by the caller. Function verifies the signature of the content is valid and signing certificate was not revoked and is contained within a list of trusted signers.</p>
<p>Note: because this function uses hashes and the specification contains a variety of hash choices, you should be aware that the check against the RevokedDb list will improperly succeed if the signature is revoked using a different hash algorithm. For this reason, you should either cycle through all UEFI supported hashes to see if one is forbidden, or rely on a single hash choice only if the UEFI signature authority only signs and revokes with a single hash (at time of writing, this hash choice is SHA256).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_PKCS7_VERIFY_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Signature</td><td>Points to buffer containing ASN.1 DER-encoded PKCS detached signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SignatureSize</td><td>The size of Signature buffer in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InHash</td><td>InHash points to buffer containing the caller calculated hash of the data. The parameter may not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InHashSize</td><td>The size in bytes of InHash buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AllowedDb</td><td>Pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. The <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures contain lists of X.509 certificates of approved signers. Function recognizes signer certificates of type EFI_CERT_X509_GUID. Any hash certificate in AllowedDb list is ignored by this function. Function returns success if signer of the buffer is within this list (and not within RevokedDb). This parameter is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RevokedDb</td><td>Optional pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. List of X.509 certificates of revoked signers and revoked file hashes. Signature verification will always fail if the signer of the file or the hash of the data component of the buffer is in RevokedDb list. This parameter is optional and caller may pass Null if not required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeStampDb</td><td>Optional pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. This parameter can be used to pass a list of X.509 certificates of trusted time stamp counter-signers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Signed hash was verified against caller-provided hash of content, the signer's certificate was not found in RevokedDb, and was found in AllowedDb or if in signer is found in both AllowedDb and RevokedDb, the signing was allowed by reference to TimeStampDb as described above, and no hash matching content hash was found in RevokedDb. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The SignedData buffer was correctly formatted but signer was in RevokedDb or not in AllowedDb. Also returned if matching content hash found in RevokedDb. </td></tr>
    <tr><td class="paramname">EFI_COMPROMISED_DATA</td><td>Caller provided hash differs from signed hash. Or, caller and encrypted hash are different sizes. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Signature is NULL or SignatureSize is zero. InHash is NULL or InHashSize is zero. AllowedDb is NULL. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Unsupported or invalid format in TimeStampDb, RevokedDb or AllowedDb list contents was detected. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The Signature buffer was not correctly formatted for processing by the function.</td></tr>
  </table>
  </dd>
</dl>
<p>The Request() function queues an HTTP request to this HTTP instance, similar to <a class="el" href="_supplicant_8h.html#ad64984a28acf10f8bb9dd4ef2843635cabfe0b4da68061025c67c7a77b8b6abd2">Transmit()</a> function in the EFI TCP driver. When the HTTP request is sent successfully, or if there is an error, Status in token will be updated and Event will be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_HTTP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to storage containing HTTP request token.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI HTTP Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Data was dropped out of the transmit or receive queue. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token-&gt;Message is NULL. Token-&gt;Message-&gt;Body is not NULL, Token-&gt;Message-&gt;BodyLength is non-zero, and Token-&gt;Message-&gt;Data is NULL, but a previous call to Request()has not been completed successfully. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate enough system resources. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The HTTP method is not supported in current implementation.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="_tcg2_protocol_8h.html#a412aad19df2dd28f58da0fdef8f7ad02">Response()</a> function queues an HTTP response to this HTTP instance, similar to <a class="el" href="_supplicant_8h.html#ad64984a28acf10f8bb9dd4ef2843635ca5a54306f6db7e247a7746d8d5ff701e9">Receive()</a> function in the EFI TCP driver. When the HTTP Response is received successfully, or if there is an error, Status in token will be updated and Event will be signaled.</p>
<p>The HTTP driver will queue a receive token to the underlying TCP instance. When data is received in the underlying TCP instance, the data will be parsed and Token will be populated with the response data. If the data received from the remote host contains an incomplete or invalid HTTP header, the HTTP driver will continue waiting (asynchronously) for more data to be sent from the remote host before signaling Event in Token.</p>
<p>It is the responsibility of the caller to allocate a buffer for Body and specify the size in BodyLength. If the remote host provides a response that contains a content body, up to BodyLength bytes will be copied from the receive buffer into Body and BodyLength will be updated with the amount of bytes received and copied to Body. This allows the client to download a large file in chunks instead of into one contiguous block of memory. Similar to HTTP request, if Body is not NULL and BodyLength is non-zero and all other fields are NULL or 0, the HTTP driver will queue a receive token to underlying TCP instance. If data arrives in the receive buffer, up to BodyLength bytes of data will be copied to Body. The HTTP driver will then update BodyLength with the amount of bytes received and copied to Body.</p>
<p>If the HTTP driver does not have an open underlying TCP connection with the host specified in the response URL, Request() will return EFI_ACCESS_DENIED. This is consistent with RFC 2616 recommendation that HTTP clients should attempt to maintain an open TCP connection between client and host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_HTTP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to storage containing HTTP response token.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Allocation succeeded. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI HTTP Protocol instance has not been initialized. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token-&gt;Message-&gt;Headers is NULL. Token-&gt;Message is NULL. Token-&gt;Message-&gt;Body is not NULL, Token-&gt;Message-&gt;BodyLength is non-zero, and Token-&gt;Message-&gt;Data is NULL, but a previous call to <a class="el" href="_tcg2_protocol_8h.html#a412aad19df2dd28f58da0fdef8f7ad02">Response()</a> has not been completed successfully. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate enough system resources. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>An open TCP connection is not present with the host specified by response URL.</td></tr>
  </table>
  </dd>
</dl>
<p>The Poll() function can be used by network drivers and applications to increase the rate that data packets are moved between the communication devices and the transmit and receive queues.</p>
<p>In some systems, the periodic timer event in the managed network driver may not poll the underlying communications device fast enough to transmit and/or receive all data packets without missing incoming packets or dropping outgoing packets. Drivers and applications that are experiencing packet loss should try calling the Poll() function more often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_HTTP_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed.. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>No incoming or outgoing data is processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI HTTP Protocol instance has not been started.</td></tr>
  </table>
  </dd>
</dl>
<p>Read or write specified device descriptor of a UFS device.</p>
<p>The service is used to read/write UFS device descriptors. The consumer of this API is responsible for allocating the data buffer pointed by Descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_UFS_DEVICE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Read</td><td>The boolean variable to show r/w direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DescId</td><td>The ID of device descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Index</td><td>The Index of device descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Selector</td><td>The Selector of device descriptor. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Descriptor</td><td>The buffer of device descriptor to be read or written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DescSize</td><td>The size of device descriptor buffer. On input, the size, in bytes, of the data buffer specified by Descriptor. On output, the number of bytes that were actually transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device descriptor is read/written successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Descriptor is NULL or DescSize is NULL. DescId, Index and Selector are invalid combination to point to a type of UFS device descriptor. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device descriptor is not read/written successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Read or write specified flag of a UFS device.</p>
<p>The service is used to read/write UFS flag descriptors. The consumer of this API is responsible for allocating the buffer pointed by Flag. The buffer size is 1 byte as UFS flag descriptor is just a single Boolean value that represents a TRUE or FALSE, '0' or '1', ON or OFF type of value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_UFS_DEVICE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Read</td><td>The boolean variable to show r/w direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlagId</td><td>The ID of flag to be read or written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Flag</td><td>The buffer to set or clear flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The flag descriptor is set/clear successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Flag is NULL. FlagId is an invalid UFS flag ID. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The flag is not set/clear successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Read or write specified attribute of a UFS device.</p>
<p>The service is used to read/write UFS attributes. The consumer of this API is responsible for allocating the data buffer pointed by Attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_UFS_DEVICE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Read</td><td>The boolean variable to show r/w direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AttrId</td><td>The ID of Attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Index</td><td>The Index of Attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Selector</td><td>The Selector of Attribute. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Attribute</td><td>The buffer of Attribute to be read or written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">AttrSize</td><td>The size of Attribute buffer. On input, the size, in bytes, of the data buffer specified by Attribute. On output, the number of bytes that were actually transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The attribute is read/written successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Attribute is NULL or AttrSize is NULL. AttrId, Index and Selector are invalid combination to point to a type of UFS attribute. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The attribute is not read/written successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a notification function to be called when ResetSystem() is called.</p>
<p>The RegisterResetNotify() function registers a notification function that is called when ResetSystem()is called and prior to completing the reset of the platform. The registered functions must not perform a platform reset themselves. These notifications are intended only for the notification of components which may need some special-purpose maintenance prior to the platform resetting. The list of registered reset notification functions are processed if ResetSystem()is called before ExitBootServices(). The list of registered reset notification functions is ignored if ResetSystem()is called after ExitBootServices().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_RESET_NOTIFICATION_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ResetFunction</td><td>Points to the function to be called when a ResetSystem() is executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The reset notification function was successfully registered. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ResetFunction is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There are not enough resources available to register the reset notification function. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The reset notification function specified by ResetFunction has already been registered.</td></tr>
  </table>
  </dd>
</dl>
<p>Unregister a notification function.</p>
<p>The UnregisterResetNotify() function removes the previously registered notification using RegisterResetNotify().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_RESET_NOTIFICATION_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ResetFunction</td><td>The pointer to the ResetFunction being unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The reset notification function was unregistered. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ResetFunction is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The reset notification function specified by ResetFunction was not previously registered using RegisterResetNotify().</td></tr>
  </table>
  </dd>
</dl>
<p>Enumerate the I2C devices</p>
<p>This function enables the caller to traverse the set of I2C devices on an I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The platform data for the next device on the I2C bus was returned successfully. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Device</td><td>Pointer to a buffer containing an <a class="el" href="struct_e_f_i___i2_c___d_e_v_i_c_e.html">EFI_I2C_DEVICE</a> structure. Enumeration is started by setting the initial <a class="el" href="struct_e_f_i___i2_c___d_e_v_i_c_e.html">EFI_I2C_DEVICE</a> structure pointer to NULL. The buffer receives an <a class="el" href="struct_e_f_i___i2_c___d_e_v_i_c_e.html">EFI_I2C_DEVICE</a> structure pointer to the next I2C device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The platform data for the next device on the I2C bus was returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Device is NULL </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>*Device does not point to a valid <a class="el" href="struct_e_f_i___i2_c___d_e_v_i_c_e.html">EFI_I2C_DEVICE</a> structure returned in a previous call Enumerate().</td></tr>
  </table>
  </dd>
</dl>
<p>Get the requested I2C bus frequency for a specified bus configuration.</p>
<p>This function returns the requested I2C bus clock frequency for the I2cBusConfiguration. This routine is provided for diagnostic purposes and is meant to be called after calling Enumerate to get the I2cBusConfiguration value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_ENUMERATE_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I2cBusConfiguration</td><td>I2C bus configuration to access the I2C device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*BusClockHertz</td><td>Pointer to a buffer to receive the I2C bus clock frequency in Hertz</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The I2C bus frequency was returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BusClockHertz was NULL </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>Invalid I2cBusConfiguration value</td></tr>
  </table>
  </dd>
</dl>
<p>Request a survey of potential wireless networks that administrator can later elect to try to join.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_WIRELESS_MAC_CONNECTION_II_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to the token for getting wireless network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation started, and an event will eventually be raised for the caller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>One or more of the input parameters is not supported by this implementation. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The operation of getting wireless network is already started. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Connect a wireless network specified by a particular SSID, BSS type and Security type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_WIRELESS_MAC_CONNECTION_II_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to the token for connecting wireless network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation started successfully. Results will be notified eventually. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>One or more of the input parameters are not supported by this implementation. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The connection process is already started. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified wireless network is not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Request a disconnection with current connected wireless network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_WIRELESS_MAC_CONNECTION_II_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to the token for disconnecting wireless network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation started successfully. Results will be notified eventually. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>One or more of the input parameters are not supported by this implementation. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Not connected to a wireless network. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Read the 3 byte manufacture and device ID from the SPI flash.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine reads the 3 byte manufacture and device ID from the flash part filling the buffer provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to a 3 byte buffer to receive the manufacture and device ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The manufacture and device ID was read successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Buffer is NULL </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Invalid data received from SPI flash part.</td></tr>
  </table>
  </dd>
</dl>
<p>Read data from the SPI flash.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine reads data from the SPI part in the buffer provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlashAddress</td><td>Address in the flash to start reading </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthInBytes</td><td>Read length in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Address of a buffer to receive the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The data was read successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Buffer is NULL, or FlashAddress &gt;= This-&gt;FlashSize, or LengthInBytes &gt; This-&gt;FlashSize - FlashAddress</td></tr>
  </table>
  </dd>
</dl>
<p>Read the flash status register.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine reads the flash part status register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthInBytes</td><td>Number of status bytes to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FlashStatus</td><td>Pointer to a buffer to receive the flash status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The status register was read successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Write the flash status register.</p>
<p>This routine must be called at or below TPL_N OTIFY. This routine writes the flash part status register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthInBytes</td><td>Number of status bytes to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlashStatus</td><td>Pointer to a buffer containing the new status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The status write was successful. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate the write buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Write data to the SPI flash.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine breaks up the write operation as necessary to write the data to the SPI part.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlashAddress</td><td>Address in the flash to start writing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthInBytes</td><td>Write length in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Address of a buffer containing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The data was written successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Buffer is NULL, or FlashAddress &gt;= This-&gt;FlashSize, or LengthInBytes &gt; This-&gt;FlashSize - FlashAddress </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory to copy buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Efficiently erases one or more 4KiB regions in the SPI flash.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine uses a combination of 4 KiB and larger blocks to erase the specified area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlashAddress</td><td>Address within a 4 KiB block to start erasing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockCount</td><td>Number of 4 KiB blocks to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The erase was completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>FlashAddress &gt;= This-&gt;FlashSize, or BlockCount * 4 KiB &gt; This-&gt;FlashSize - FlashAddress</td></tr>
  </table>
  </dd>
</dl>
<p>Host name to host address translation.</p>
<p>The HostNameToIp () function is used to translate the host name to host IP address. A type AAAA query is used to get the one or more IPv6 addresses for this host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HostName</td><td>Host name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to translate host name to host address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. HostName is NULL or buffer contained unsupported characters. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>This Token is being used in another DNS session. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Host address to host name translation.</p>
<p>The IpToHostName () function is used to translate the host address to host name. A type PTR query is used to get the primary name of the host. Implementation can choose to support this function or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IpAddress</td><td>Ip Address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to translate host address to host name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. IpAddress is not valid IP address. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides capability to retrieve arbitrary information from the DNS server.</p>
<p>This GeneralLookup() function retrieves arbitrary information from the DNS. The caller supplies a QNAME, QTYPE, and QCLASS, and all of the matching RRs are returned. All RR content (e.g., TTL) was returned. The caller need parse the returned RR to get required information. The function is optional. Implementation can choose to support it or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QName</td><td>Pointer to Query Name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QType</td><td>Query Type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QClass</td><td>Query Name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to retrieve arbitrary information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported. Or the requested QType is not supported </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. QName is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is to update the DNS Cache.</p>
<p>The UpdateDnsCache() function is used to add/delete/modify DNS cache entry. DNS cache can be normally dynamically updated after the DNS resolve succeeds. This function provided capability to manually add/delete/modify the DNS cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeleteFlag</td><td>If FALSE, this function is to add one entry to the DNS Cahce. If TRUE, this function will delete matching DNS Cache entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Override</td><td>If TRUE, the maching DNS cache entry will be overwritten with the supplied parameter. If FALSE, EFI_ACCESS_DENIED will be returned if the entry to be added is already existed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DnsCacheEntry</td><td>Pointer to DNS Cache entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. DnsCacheEntry.HostName is NULL. DnsCacheEntry.IpAddress is NULL. DnsCacheEntry.Timeout is zero. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The DNS cache entry already exists and Override is not TRUE. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCE</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Polls for incoming data packets and processes outgoing data packets.</p>
<p>The Poll() function can be used by network drivers and applications to increase the rate that data packets are moved between the communications device and the transmit and receive queues.</p>
<p>In some systems, the periodic timer event in the managed network driver may not poll the underlying communications device fast enough to transmit and/or receive all data packets without missing incoming packets or dropping outgoing packets. Drivers and applications that are experiencing packet loss should try calling the Poll() function more often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI DNS Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There is no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Data was dropped out of the transmit and/or receive queue. Consider increasing the polling rate.</td></tr>
  </table>
  </dd>
</dl>
<p>Abort an asynchronous DNS operation, including translation between IP and Host, and general look up behavior.</p>
<p>The Cancel() function is used to abort a pending resolution request. After calling this function, Token.Status will be set to EFI_ABORTED and then Token.Event will be signaled. If the token is not in one of the queues, which usually means that the asynchronous operation has completed, this function will not signal the token and EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to a token that has been issued by <a class="el" href="struct___e_f_i___d_n_s6___p_r_o_t_o_c_o_l.html#a821ea81654cc7f3057dd792d10e81dfe">EFI_DNS6_PROTOCOL.HostNameToIp</a> (), <a class="el" href="struct___e_f_i___d_n_s6___p_r_o_t_o_c_o_l.html#a00c7ed8daa23d4752ddd102b97f169f8">EFI_DNS6_PROTOCOL.IpToHostName()</a> or EFI_DNS6_PROTOCOL.GeneralLookup(). If NULL, all pending tokens are aborted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI DNS6 Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>When Token is not NULL, and the asynchronous DNS operation was not found in the transmit queue. It was either completed or was not issued by HostNameToIp(), IpToHostName() or GeneralLookup().</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function to send request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_ATTRIBUTE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Data received. The first byte is the attribute opcode, followed by opcode specific fields. See Bluetooth specification, Vol 3, Part F, Attribute Protocol. It might be a normal RESPONSE message, or ERROR RESPONSE messag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>The length of Data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>The context passed from the callback registration request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Send a "REQUEST" or "COMMAND" message to remote server and receive a "RESPONSE" message for "REQUEST" from remote server according to Bluetooth attribute protocol data unit(PDU).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_ATTRIBUTE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Data of a REQUEST or COMMAND message. The first byte is the attribute PDU related opcode, followed by opcode specific fields. See Bluetooth specification, Vol 3, Part F, Attribute Protocol. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>The length of Data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Callback function to notify the RESPONSE is received to the caller, with the response buffer. Caller must check the response buffer content to know if the request action is success or fail. It may be NULL if the data is a COMMAND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. It is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The request is sent successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more parameters are invalid due to following conditions:<ul>
<li>The Buffer is NULL.</li>
<li>The BufferLength is 0.</li>
<li>The opcode in Buffer is not a valid OPCODE according to Bluetooth specification.</li>
<li>The Callback is NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Sending the request failed due to the host controller or the device error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>A GATT operation is already underway for this device. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The attribute does not support the corresponding operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function, it is called if a BluetoothLE device is found during scan process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Context passed from scan request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallbackInfo</td><td>Data related to scan result. NULL CallbackInfo means scan complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Get BluetoothLE configuration data.</p>
<p>The GetData() function returns BluetoothLE configuration data. For remote BluetoothLE device configuration data, please use GetRemoteData() function with valid BD_ADDR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>On input, indicates the size, in bytes, of the data buffer specified by Data. On output, indicates the amount of data actually returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The BluetoothLE configuration data is returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE:<ul>
<li>DataSize is NULL.</li>
<li>*DataSize is 0.</li>
<li>Data is NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The DataType is not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Set BluetoothLE configuration data.</p>
<p>The SetData() function sets local BluetoothLE device configuration data. Not all DataType can be set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Indicates the size, in bytes, of the data buffer specified by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The BluetoothLE configuration data is set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE:<ul>
<li>DataSize is 0.</li>
<li>Data is NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>Cannot set configuration data.</td></tr>
  </table>
  </dd>
</dl>
<p>Get remove BluetoothLE device configuration data.</p>
<p>The GetRemoteData() function returns remote BluetoothLE device configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>On input, indicates the size, in bytes, of the data buffer specified by Data. On output, indicates the amount of data actually returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The remote BluetoothLE device configuration data is returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE:<ul>
<li>DataSize is NULL.</li>
<li>*DataSize is 0.</li>
<li>Data is NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The DataType is not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function for SMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into callback function. This is optional parameter and may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EventDataType</td><td>Event data type in EFI_BLUETOOTH_LE_SMP_EVENT_DATA_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Indicates the size, in bytes, of the data buffer specified by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register Security Manager Protocol callback function for user authentication/authorization.</p>
<p>The RegisterSmpAuthCallback() function register Security Manager Protocol callback function for user authentication/authorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Callback function for user authentication/authorization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMP callback function is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A callback function is already registered on the same attribute opcode and attribute handle, when the Callback is not NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>A callback function is not registered on the same attribute opcode and attribute handle, when the Callback is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Send user authentication/authorization to remote device.</p>
<p>The SendSmpAuthData() function sends user authentication/authorization to remote device. It should be used to send these information after the caller gets the request data from the callback function by RegisterSmpAuthCallback().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EventDataType</td><td>Event data type in EFI_BLUETOOTH_LE_SMP_EVENT_DATA_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>The size of Data in bytes, of the data buffer specified by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be sent. The data format depends on the type of SMP event data being responded to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMP authorization data is sent successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>SMP is not in the correct state to receive the auth data.</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function to get SMP data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into callback function. This is optional parameter and may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. For Local device setting, it should be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Data type in EFI_BLUETOOTH_LE_SMP_DATA_TYPE. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>On input, indicates the size, in bytes, of the data buffer specified by Data. On output, indicates the amount of data actually returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a callback function to get SMP related data.</p>
<p>The RegisterSmpGetDataCallback() function registers a callback function to get SMP related data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Callback function for SMP get data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMP get data callback function is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A callback function is already registered on the same attribute opcode and attribute handle, when the Callback is not NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>A callback function is not registered on the same attribute opcode and attribute handle, when the Callback is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function to set SMP data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into callback function. This is optional parameter and may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Data type in EFI_BLUETOOTH_LE_SMP_DATA_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Indicates the size, in bytes, of the data buffer specified by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a callback function to set SMP related data.</p>
<p>The RegisterSmpSetDataCallback() function registers a callback function to set SMP related data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Callback function for SMP set data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMP set data callback function is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A callback function is already registered on the same attribute opcode and attribute handle, when the Callback is not NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>A callback function is not registered on the same attribute opcode and attribute handle, when the Callback is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function to hook connect complete event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into callback function. This is optional parameter and may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallbackType</td><td>The value defined in EFI_BLUETOOTH_CONNECT_COMPLETE_CALLBACK_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputBuffer</td><td>A pointer to the buffer of data that is input from callback caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputBufferSize</td><td>Indicates the size, in bytes, of the data buffer specified by InputBuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register link connect complete callback function.</p>
<p>The RegisterLinkConnectCompleteCallback() function registers Bluetooth link connect complete callback function. The Bluetooth Configuration driver may call RegisterLinkConnectCompleteCallback() to register a callback function. During pairing, Bluetooth bus driver must trigger this callback function to report device state, if it is registered. Then Bluetooth Configuration driver will get information on device connection, according to CallbackType defined by EFI_BLUETOOTH_CONNECT_COMPLETE_CALLBACK_TYPE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>The callback function. NULL means unregister. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The link connect complete callback function is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A callback function is already registered on the same attribute opcode and attribute handle, when the Callback is not NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>A callback function is not registered on the same attribute opcode and attribute handle, when the Callback is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve mode data of this DNS instance.</p>
<p>This function is used to retrieve DNS mode data for this DNS instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DnsModeData</td><td>Point to the mode data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>When DnsConfigData is queried, no configuration data is available because this instance has not been configured. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or DnsModeData is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Configure this DNS instance.</p>
<p>This function is used to configure DNS mode data for this DNS instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DnsConfigData</td><td>Point to the Configuration data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The designated protocol is not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. The StationIp address provided in DnsConfigData is not a valid unicast. DnsServerList is NULL while DnsServerListCount is not ZERO. DnsServerListCount is ZERO while DnsServerList is not NULL </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The DNS instance data or required space could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred. The EFI DNSv4 Protocol instance is not configured. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>Second call to Configure() with DnsConfigData. To reconfigure the instance the caller must call Configure() with NULL first to return driver to unconfigured state.</td></tr>
  </table>
  </dd>
</dl>
<p>Host name to host address translation.</p>
<p>The HostNameToIp () function is used to translate the host name to host IP address. A type A query is used to get the one or more IP addresses for this host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HostName</td><td>Host name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to translate host name to host address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. HostName is NULL. HostName string is unsupported format. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This instance has not been started.</td></tr>
  </table>
  </dd>
</dl>
<p>IPv4 address to host name translation also known as Reverse DNS lookup.</p>
<p>The IpToHostName() function is used to translate the host address to host name. A type PTR query is used to get the primary name of the host. Support of this function is optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IpAddress</td><td>Ip Address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to translate host address to host name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. IpAddress is not valid IP address . </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>This Token is being used in another DNS session. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve arbitrary information from the DNS server.</p>
<p>This GeneralLookup() function retrieves arbitrary information from the DNS. The caller supplies a QNAME, QTYPE, and QCLASS, and all of the matching RRs are returned. All RR content (e.g., TTL) was returned. The caller need parse the returned RR to get required information. The function is optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QName</td><td>Pointer to Query Name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QType</td><td>Query Type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QClass</td><td>Query Name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to retrieve arbitrary information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported. Or the requested QType is not supported </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. QName is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>This Token is being used in another DNS session. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is to update the DNS Cache.</p>
<p>The UpdateDnsCache() function is used to add/delete/modify DNS cache entry. DNS cache can be normally dynamically updated after the DNS resolve succeeds. This function provided capability to manually add/delete/modify the DNS cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeleteFlag</td><td>If FALSE, this function is to add one entry to the DNS Cahce. If TRUE, this function will delete matching DNS Cache entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Override</td><td>If TRUE, the maching DNS cache entry will be overwritten with the supplied parameter. If FALSE, EFI_ACCESS_DENIED will be returned if the entry to be added is already existed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DnsCacheEntry</td><td>Pointer to DNS Cache entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. DnsCacheEntry.HostName is NULL. DnsCacheEntry.IpAddress is NULL. DnsCacheEntry.Timeout is zero. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The DNS cache entry already exists and Override is not TRUE.</td></tr>
  </table>
  </dd>
</dl>
<p>Polls for incoming data packets and processes outgoing data packets.</p>
<p>The Poll() function can be used by network drivers and applications to increase the rate that data packets are moved between the communications device and the transmit and receive queues. In some systems, the periodic timer event in the managed network driver may not poll the underlying communications device fast enough to transmit and/or receive all data packets without missing incoming packets or dropping outgoing packets. Drivers and applications that are experiencing packet loss should try calling the Poll() function more often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI DNS Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Data was dropped out of the transmit and/or receive queue. Consider increasing the polling rate.</td></tr>
  </table>
  </dd>
</dl>
<p>Abort an asynchronous DNS operation, including translation between IP and Host, and general look up behavior.</p>
<p>The Cancel() function is used to abort a pending resolution request. After calling this function, Token.Status will be set to EFI_ABORTED and then Token.Event will be signaled. If the token is not in one of the queues, which usually means that the asynchronous operation has completed, this function will not signal the token and EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to a token that has been issued by <a class="el" href="struct___e_f_i___d_n_s4___p_r_o_t_o_c_o_l.html#a0922b5b85674f5c86fc525a93a8df9db">EFI_DNS4_PROTOCOL.HostNameToIp</a> (), <a class="el" href="struct___e_f_i___d_n_s4___p_r_o_t_o_c_o_l.html#a393fbab3879d778d66acd1a095158653">EFI_DNS4_PROTOCOL.IpToHostName()</a> or EFI_DNS4_PROTOCOL.GeneralLookup(). If NULL, all pending tokens are aborted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI DNS4 Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>When Token is not NULL, and the asynchronous DNS operation was not found in the transmit queue. It was either completed or was not issued by HostNameToIp(), IpToHostName() or GeneralLookup().</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TREE_PROTOCOL GetCapability function call provides protocol capability information and state information about the TrEE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ProtocolCapability</td><td>The caller allocates memory for a TREE_BOOT_SERVICE_CAPABILITY structure and sets the size field to the size of the structure allocated. The callee fills in the fields with the EFI protocol capability information and the current TrEE state information up to the number of fields which fit within the size of the structure passed in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was unsuccessful. The ProtocolCapability variable will not be populated. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. The ProtocolCapability variable will not be populated. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The ProtocolCapability variable is too small to hold the full response. It will be partially populated (required Size field will be set).</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TREE_PROTOCOL Get Event Log function call allows a caller to retrieve the address of a given event log and its last entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EventLogFormat</td><td>The type of the event log for which the information is requested. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogLocation</td><td>A pointer to the memory address of the event log. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogLastEntry</td><td>If the Event Log contains more than one entry, this is a pointer to the address of the start of the last entry in the event log in memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogTruncated</td><td>If the Event Log is missing at least one entry because an event would have exceeded the area allocated for events, this value is set to TRUE. Otherwise, the value will be FALSE and the Event Log will be complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect (e.g. asking for an event log whose format is not supported).</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TREE_PROTOCOL HashLogExtendEvent function call provides callers with an opportunity to extend and optionally log events without requiring knowledge of actual TPM commands. The extend operation will occur even if this function cannot create an event log entry (e.g. due to the event log being full).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Bitmap providing additional information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataToHash</td><td>Physical address of the start of the data buffer to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataToHashLen</td><td>The length in bytes of the buffer referenced by DataToHash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>Pointer to data buffer containing information about the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was unsuccessful. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The extend operation occurred, but the event could not be written to one or more event logs. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The PE/COFF image type is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>This service enables the sending of commands to the TrEE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputParameterBlockSize</td><td>Size of the TrEE input parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputParameterBlock</td><td>Pointer to the TrEE input parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputParameterBlockSize</td><td>Size of the TrEE output parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputParameterBlock</td><td>Pointer to the TrEE output parameter block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The command byte stream was successfully sent to the device and a response was successfully received. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was not successfully sent to the device or a response was not successfully received from the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The output parameter block is too small.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads data from a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_FILE_PROTOCOL instance that is the file handle to read data from. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was read successfully. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no medium. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An attempt was made to read from a deleted file. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>On entry, the current file position is beyond the end of the file. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Unable to queue the request due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes data to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_FILE_PROTOCOL instance that is the file handle to write data to. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was read successfully. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Writes to open directory files are not supported. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no medium. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An attempt was made to write to a deleted file. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The file or medium is write-protected. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file was opened read only. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The volume is full. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Unable to queue the request due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Flushes all modified data associated with a file to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_FILE_PROTOCOL instance that is the file handle to flush. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was read successfully. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no medium. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The file or medium is write-protected. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file was opened read-only. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The volume is full. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Unable to queue the request due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the configuration for the EFI IPv4 network stack running on the communication device this EFI IPv4 Configuration II Protocol instance manages.</p>
<p>This function is used to set the configuration data of type DataType for the EFI IPv4 network stack running on the communication device this EFI IPv4 Configuration II Protocol instance manages. The successfully configured data is valid after system reset or power-off. The DataSize is used to calculate the count of structure instances in the Data for some DataType that multiple structure instances are allowed. This function is always non-blocking. When setting some typeof configuration data, an asynchronous process is invoked to check the correctness of the data, such as doing address conflict detection on the manually set local IPv4 address. EFI_NOT_READY is returned immediately to indicate that such an asynchronous process is invoked and the process is not finished yet. The caller willing to get the result of the asynchronous process is required to call RegisterDataNotify() to register an event on the specified configuration data. Once the event is signaled, the caller can call GetData()to get back the configuration data in order to know the result. For other types of configuration data that do not require an asynchronous configuration process, the result of the operation is immediately returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IP4_CONFIG2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Size of the buffer pointed to by Data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>The data buffer to set. The type ofthe data buffer is associated with the DataType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified configuration data for the EFI IPv4 network stack is set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following are TRUE: This is NULL. One or more fields in Data and DataSize do not match the requirement of the data type indicated by DataType. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The specified configuration data is read-only or the specified configuration data can not be set under the current policy. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Another set operation on the specified configuration data is already in process. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>An asynchronous process is invoked to set the specified configuration data and the process is not finished yet. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The DataSize does not match the size of the type indicated by DataType. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This DataType is not supported. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system error or network error occurred.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the configuration data for the EFI IPv4 network stack running on the communication device this EFI IPv4 Configuration II Protocol instance manages.</p>
<p>This function returns the configuration data of type DataType for the EFI IPv4 network stack running on the communication device this EFI IPv4 Configuration II Protocol instance manages. The caller is responsible for allocating the buffer usedto return the specified configuration data and the required size will be returned to the caller if the size of the buffer is too small. EFI_NOT_READY is returned if the specified configuration data is not ready due to an already in progress asynchronous configuration process. The caller can call RegisterDataNotify() to register an event on the specified configuration data. Once the asynchronous configuration process is finished, the event will be signaled and a subsequent GetData() call will return the specified configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IP4_CONFIG2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data to get. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DataSize</td><td>On input, in bytes, the size of Data. On output, in bytes, the size of buffer required to store the specified configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>The data buffer in which the configuration data is returned. The type of the data buffer is associated with the DataType. Ignored if DataSize is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified configuration data is got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the followings are TRUE: This is NULL. DataSize is NULL. Data is NULL if *DataSizeis not zero. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of Data is too small for the specified configuration data and the required size is returned in DataSize. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The specified configuration data is not ready due to an already in progress asynchronous configuration process. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified configuration data is not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Register an event that is to be signaled whenever a configuration process on the specified configuration data is done.</p>
<p>This function registers an event that is to be signaled whenever a configuration process on the specified configuration data is done. An event can be registered for different DataType simultaneously and the caller is responsible for determining which type of configuration data causes the signaling of the event in such case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IP4_CONFIG2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data to unregister the event for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>The event to register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The notification event for the specified configuration data is registered. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The configuration data type specified by DataType is not supported. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The Event is already registered for the DataType.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove a previously registered event for the specified configuration data.</p>
<p>This function removes a previously registeredevent for the specified configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IP4_CONFIG2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data to remove the previously registered event for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>The event to unregister.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event registered for the specified configuration data is removed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The Eventhas not been registered for the specified DataType.</td></tr>
  </table>
  </dd>
</dl>
<p>The DXE Foundation uses this service to measure and/or verify a UEFI image.</p>
<p>This service abstracts the invocation of Trusted Computing Group (TCG) measured boot, UEFI Secure boot, and UEFI User Identity infrastructure. For the former two, the DXE Foundation invokes the FileAuthentication() with a DevicePath and corresponding image in FileBuffer memory. The TCG measurement code will record the FileBuffer contents into the appropriate PCR. The image verification logic will confirm the integrity and provenance of the image in FileBuffer of length FileSize . The origin of the image will be DevicePath in these cases. If the FileBuffer is NULL, the interface will determine if the DevicePath can be connected in order to support the User Identification policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>The EFI_SECURITY2_ARCH_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">File</td><td>A pointer to the device path of the file that is being dispatched. This will optionally be used for logging. </td></tr>
    <tr><td class="paramname">FileBuffer</td><td>A pointer to the buffer with the UEFI file image. </td></tr>
    <tr><td class="paramname">FileSize</td><td>The size of the file. </td></tr>
    <tr><td class="paramname">BootPolicy</td><td>A boot policy that was used to call LoadImage() UEFI service. If FileAuthentication() is invoked not from the LoadImage(), BootPolicy must be set to FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The file specified by DevicePath and non-NULL FileBuffer did authenticate, and the platform policy dictates that the DXE Foundation may use the file. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path specified by NULL device path DevicePath and non-NULL FileBuffer did authenticate, and the platform policy dictates that the DXE Foundation may execute the image in FileBuffer. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>FileBuffer is NULL and current user has permission to start UEFI device drivers on the device path specified by DevicePath. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The file specified by DevicePath and FileBuffer did not authenticate, and the platform policy dictates that the file should be placed in the untrusted state. The image has been added to the file execution table. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file specified by File and FileBuffer did not authenticate, and the platform policy dictates that the DXE Foundation may not use File. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>FileBuffer is NULL and the user has no permission to start UEFI device drivers on the device path specified by DevicePath. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>FileBuffer is not NULL and the user has no permission to load drivers from the device path specified by DevicePath. The image has been added into the list of the deferred images.</td></tr>
  </table>
  </dd>
</dl>
<p>This function accepts a &lt;MultiKeywordResp&gt; formatted string, finds the associated keyword owners, creates a &lt;MultiConfigResp&gt; string from it and forwards it to the EFI_HII_ROUTING_PROTOCOL.RouteConfig function.</p>
<p>If there is an issue in resolving the contents of the KeywordString, then the function returns an error and also sets the Progress and ProgressErr with the appropriate information about where the issue occurred and additional data about the nature of the issue.</p>
<p>In the case when KeywordString containing multiple keywords, when an EFI_NOT_FOUND error is generated during processing the second or later keyword element, the system storage associated with earlier keywords is not modified. All elements of the KeywordString must successfully pass all tests for format and access prior to making any modifications to storage.</p>
<p>In the case when EFI_DEVICE_ERROR is returned from the processing of a KeywordString containing multiple keywords, the state of storage associated with earlier keywords is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to the EFI_KEYWORD_HANDLER _PROTOCOL instance.</td></tr>
    <tr><td class="paramname">KeywordString</td><td>A null-terminated string in &lt;MultiKeywordResp&gt; format.</td></tr>
    <tr><td class="paramname">Progress</td><td>On return, points to a character in the KeywordString. Points to the string's NULL terminator if the request was successful. Points to the most recent '&amp;' before the first failing name / value pair (or the beginning of the string if the failure is in the first name / value pair) if the request was not successful.</td></tr>
    <tr><td class="paramname">ProgressErr</td><td>If during the processing of the KeywordString there was a failure, this parameter gives additional information about the possible source of the problem. The various errors are defined in "Related Definitions" below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified action was completed successfully.</td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following are TRUE:<ol type="1">
<li>KeywordString is NULL.</li>
<li>Parsing of the KeywordString resulted in an error. See Progress and ProgressErr for more data.</li>
</ol>
</td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>An element of the KeywordString was not found. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The action violated system policy. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system error occurred. See ProgressErr for more data.</td></tr>
  </table>
  </dd>
</dl>
<p>This function accepts a &lt;MultiKeywordRequest&gt; formatted string, finds the underlying keyword owners, creates a &lt;MultiConfigRequest&gt; string from it and forwards it to the EFI_HII_ROUTING_PROTOCOL.ExtractConfig function.</p>
<p>If there is an issue in resolving the contents of the KeywordString, then the function returns an EFI_INVALID_PARAMETER and also set the Progress and ProgressErr with the appropriate information about where the issue occurred and additional data about the nature of the issue.</p>
<p>In the case when KeywordString is NULL, or contains multiple keywords, or when EFI_NOT_FOUND is generated while processing the keyword elements, the Results string contains values returned for all keywords processed prior to the keyword generating the error but no values for the keyword with error or any following keywords.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to the EFI_KEYWORD_HANDLER _PROTOCOL instance.</td></tr>
    <tr><td class="paramname">NameSpaceId</td><td>A null-terminated string containing the platform configuration language to search through in the system. If a NULL is passed in, then it is assumed that any platform configuration language with the prefix of "x-UEFI-" are searched.</td></tr>
    <tr><td class="paramname">KeywordString</td><td>A null-terminated string in &lt;MultiKeywordRequest&gt; format. If a NULL is passed in the KeywordString field, all of the known keywords in the system for the NameSpaceId specified are returned in the Results field.</td></tr>
    <tr><td class="paramname">Progress</td><td>On return, points to a character in the KeywordString. Points to the string's NULL terminator if the request was successful. Points to the most recent '&amp;' before the first failing name / value pair (or the beginning of the string if the failure is in the first name / value pair) if the request was not successful.</td></tr>
    <tr><td class="paramname">ProgressErr</td><td>If during the processing of the KeywordString there was a failure, this parameter gives additional information about the possible source of the problem. See the definitions in SetData() for valid value definitions.</td></tr>
    <tr><td class="paramname">Results</td><td>A null-terminated string in &lt;MultiKeywordResp&gt; format is returned which has all the values filled in for the keywords in the KeywordString. This is a callee-allocated field, and must be freed by the caller after being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified action was completed successfully.</td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following are TRUE: 1.Progress, ProgressErr, or Results is NULL. 2.Parsing of the KeywordString resulted in an error. See Progress and ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>An element of the KeywordString was not found. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The NamespaceId specified was not found. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The action violated system policy. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system error occurred. See ProgressErr for more data.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns information about the random number generation implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_RNG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">RNGAlgorithmListSize</td><td>On input, the size in bytes of RNGAlgorithmList. On output with a return code of EFI_SUCCESS, the size in bytes of the data returned in RNGAlgorithmList. On output with a return code of EFI_BUFFER_TOO_SMALL, the size of RNGAlgorithmList required to obtain the list. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RNGAlgorithmList</td><td>A caller-allocated memory buffer filled by the driver with one EFI_RNG_ALGORITHM element for each supported RNG algorithm. The list must not change across multiple calls to the same driver. The first algorithm in the list is the default algorithm for the driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The RNG algorithm list was returned successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The services is not supported by this driver. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The list of algorithms could not be retrieved due to a hardware or firmware error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer RNGAlgorithmList is too small to hold the result.</td></tr>
  </table>
  </dd>
</dl>
<p>Produces and returns an RNG value using either the default or specified RNG algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_RNG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RNGAlgorithm</td><td>A pointer to the EFI_RNG_ALGORITHM that identifies the RNG algorithm to use. May be NULL in which case the function will use its default RNG algorithm. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RNGValueLength</td><td>The length in bytes of the memory buffer pointed to by RNGValue. The driver shall return exactly this numbers of bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RNGValue</td><td>A caller-allocated memory buffer filled by the driver with the resulting RNG value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The RNG value was returned successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The algorithm specified by RNGAlgorithm is not supported by this driver. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An RNG value could not be retrieved due to a hardware or firmware error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>There is not enough random data available to satisfy the length requested by RNGValueLength. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RNGValue is NULL or RNGValueLength is zero.</td></tr>
  </table>
  </dd>
</dl>
<p>This function requests connection to the smart card or the reader, using the appropriate reset type and protocol.</p>
<p>The SCardConnectfunction requests access to the smart card or the reader. Upon success, it is then possible to call SCardTransmit.</p>
<p>If AccessMode is set to SCARD_AM_READER, PreferredProtocols must be set to SCARD_PROTOCOL_UNDEFINED and CardAction to SCARD_CA_NORESET else function fails with EFI_INVALID_PARAMETER.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AccessMode</td><td>Codes of access mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CardAction</td><td>SCARD_CA_NORESET, SCARD_CA_COLDRESET or SCARD_CA_WARMRESET. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PreferredProtocols</td><td>Bitmask of acceptable protocols. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ActiveProtocol</td><td>A flag that indicates the active protocol.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>AccessMode is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CardAction is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Invalid combination of AccessMode/CardAction/ PreferredProtocols. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>A smart card is inserted but failed to return an ATR. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>PreferredProtocols does not contain an available protocol to use. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>AccessMode is set to SCARD_AM_CARD but there is no smart card inserted. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access is already locked by a previous SCardConnectcall. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function releases a connection previously taken by SCardConnect.</p>
<p>The SCardDisconnect function releases the lock previously taken by SCardConnect. In case the smart card has been removed before this call, thisfunction returns EFI_SUCCESS. If there is no previous call to SCardConnect, this function returns EFI_SUCCESS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CardAction</td><td>Codes for card action.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CardAction value is unknown. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Reader does not support Eject card feature (disconnect was not performed). </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves some basic information about the smart card and reader.</p>
<p>The SCardStatusfunction retrieves basic reader and card information.</p>
<p>If ReaderName, State, CardProtocolor Atris NULL, the function does not fail but does not fill in such variables.</p>
<p>If EFI_SUCCESS is not returned, ReaderName and Atr contents shall not be considered as valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReaderName</td><td>A pointer to a NULL terminated string that will contain the reader name. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ReaderNameLength</td><td>On input, a pointer to the variablethat holds the maximal size, in bytes,of ReaderName. On output, the required size, in bytes, for ReaderName. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">State</td><td>Current state of the smart card reader. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CardProtocol</td><td>Current protocol used to communicate with the smart card. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Atr</td><td>A pointer to retrieve the ATR of the smart card. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">AtrLength</td><td>On input, a pointer to hold the maximum size, in bytes, of Atr(usually 33). On output, the required size, inbytes, for the smart card ATR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ReaderName is not NULL but ReaderNameLength is NULL </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Atr is not NULL but AtrLength is NULL </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>ReaderNameLength is not big enough to hold the reader name. ReaderNameLength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>AtrLength is not big enough to hold the ATR. AtrLength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sends a command to the card or reader and returns its response.</p>
<p>The protocol to use to communicate with the smart card has been selected through SCardConnectcall.</p>
<p>In case RAPDULength indicates a buffer too small to holdthe response APDU, the function fails with EFI_BUFFER_TOO_SMALL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOLinstance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CAPDU</td><td>A pointer to a byte array thatcontains the Command APDU to send to the smart card or reader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CAPDULength</td><td>Command APDU size, in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RAPDU</td><td>A pointer to a byte array that will contain the Response APDU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">RAPDULength</td><td>On input, the maximum size, inbytes, of the Response APDU. On output, the size, in bytes, of the Response APDU.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CAPDU is NULL or CAPDULength is 0. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>RAPDULength is not big enough to hold the response APDU. RAPDULength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no card in the reader. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Card is not powered. </td></tr>
    <tr><td class="paramname">EFI_PROTOCOL_ERROR</td><td>A protocol error has occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>The reader did not respond. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>A communication with the reader/card is already pending. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides direct access to the reader.</p>
<p>This function gives direct control to send commands to the driver or the reader. The ControlCode to use is vendor dependant; the only standard code defined is the one to get PC/SC part 10 features.</p>
<p>InBuffer and Outbuffer may be NULL when ControlCode operation does not require them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControlCode</td><td>The control code for the operation to perform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InBuffer</td><td>A pointer to the input parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InBufferLength</td><td>Size, in bytes, of input parameters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OutBuffer</td><td>A pointer to the output parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutBufferLength</td><td>On input, maximal size, in bytes, to store output parameters. On output, the size, in bytes, of output parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ControlCode requires input parameters but: InBuffer is NULL or InBufferLenth is NULL or InBuffer is not NULL but InBufferLenth is less than expected. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>OutBuffer is not NULL but OutBufferLength is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>ControlCode is not supported. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>OutBufferLength is not big enough to hold the output parameters. OutBufferLength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no card in the reader and the control code specified requires one. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>ControlCode requires a powered card to operate. </td></tr>
    <tr><td class="paramname">EFI_PROTOCOL_ERROR</td><td>A protocol error has occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>The reader did not respond. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>A communication with the reader/card is already pending. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves a reader or smart card attribute.</p>
<p>Possibly supported attrib values are listed in "PC/SC specification, Part 3:
Requirements for PC-Connected Interface Devices".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Attrib</td><td>Identifier for the attribute to retrieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OutBuffer</td><td>A pointer to a buffer that will contain attribute data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutBufferLength</td><td>On input, maximal size, in bytes, to store attribute data. On output, the size, in bytes, of attribute data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>OutBuffer is NULL or OutBufferLength is 0. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>OutBufferLength is not big enough to hold the output parameters. OutBufferLength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Attribis not supported </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no card in the reader and Attrib value requires one. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Attrib requires a powered card to operate. </td></tr>
    <tr><td class="paramname">EFI_PROTOCOL_ERROR</td><td>A protocol error has occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>The reader did not respond. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>Initiate a SPI transaction between the host and a SPI peripheral.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine works with the SPI bus layer to pass the SPI transaction to the SPI controller for execution on the SPI bus. There are four types of supported transactions supported by this routine: Full Duplex: WriteBuffer and ReadBuffer are the same size. Write Only: WriteBuffer contains data for SPI peripheral, ReadBytes = 0 Read Only: ReadBuffer to receive data from SPI peripheral, WriteBytes = 0 Write Then Read: WriteBuffer contains control data to write to SPI peripheral before data is placed into the ReadBuffer. Both WriteBytes and ReadBytes must be non-zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_IO_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TransactionType</td><td>Type of SPI transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DebugTransaction</td><td>Set TRUE only when debugging is desired. Debugging may be turned on for a single SPI transaction. Only this transaction will display debugging messages. All other transactions with this value set to FALSE will not display any debugging messages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ClockHz</td><td>Specify the ClockHz value as zero (0) to use the maximum clock frequency supported by the SPI controller and part. Specify a non-zero value only when a specific SPI transaction requires a reduced clock rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BusWidth</td><td>Width of the SPI bus in bits: 1, 2, 4 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FrameSize</td><td>Frame size in bits, range: 1 - 32 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WriteBytes</td><td>The length of the WriteBuffer in bytes. Specify zero for read-only operations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WriteBuffer</td><td>The buffer containing data to be sent from the host to the SPI chip. Specify NULL for read only operations. Frame sizes 1-8 bits: UINT8 (one byte) per frame Frame sizes 7-16 bits: UINT16 (two bytes) per frame Frame sizes 17-32 bits: UINT32 (four bytes) per frame The transmit frame is in the least significant N bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ReadBytes</td><td>The length of the ReadBuffer in bytes. Specify zero for write-only operations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReadBuffer</td><td>The buffer to receeive data from the SPI chip during the transaction. Specify NULL for write only operations. Frame sizes 1-8 bits: UINT8 (one byte) per frame Frame sizes 7-16 bits: UINT16 (two bytes) per frame Frame sizes 17-32 bits: UINT32 (four bytes) per frame The received frame is in the least significant N bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SPI transaction completed successfully </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The writeBytes value was invalid </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The ReadBytes value was invalid </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>TransactionType is not valid, or BusWidth not supported by SPI peripheral or SPI host controller, or WriteBytes non-zero and WriteBuffer is NULL, or ReadBytes non-zero and ReadBuffer is NULL, or ReadBuffer != WriteBuffer for full-duplex type, or WriteBuffer was NULL, or TPL is too high </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory for SPI transaction </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The FrameSize is not supported by the SPI bus layer or the SPI host controller </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The SPI controller was not able to support</td></tr>
  </table>
  </dd>
</dl>
<p>Update the SPI peripheral associated with this SPI 10 instance.</p>
<p>Support socketed SPI parts by allowing the SPI peripheral driver to replace the SPI peripheral after the connection is made. An example use is socketed SPI NOR flash parts, where the size and parameters change depending upon device is in the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_IO_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SpiPeripheral</td><td>Pointer to an EFI_SPI_PERIPHERAL structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SPI peripheral was updated successfully </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The SpiPeripheral value is NULL, or the SpiPeripheral-&gt;SpiBus is NULL, or the SpiP eripheral - &gt;SpiBus pointing at wrong bus, or the SpiP eripheral - &gt;SpiPart is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Reset the block device hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ExtendedVerification</td><td>Indicates that the driver may perform a more exhausive verification operation of the device during reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device was reset. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device is not functioning properly and could not be reset.</td></tr>
  </table>
  </dd>
</dl>
<p>Read BufferSize bytes from Lba into Buffer.</p>
<p>This function reads the requested number of blocks from the device. All the blocks are read, or an error is returned. If EFI_DEVICE_ERROR, EFI_NO_MEDIA,_or EFI_MEDIA_CHANGED is returned and non-blocking I/O is being used, the Event associated with this request will not be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>Id of the media, changes every time the media is replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Lba</td><td>The starting Logical Block Address to read from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>Size of Buffer, must be a multiple of device block size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A pointer to the destination buffer for the data. The caller is responsible for either having implicit or explicit ownership of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The read request was queued if Token-&gt;Event is not NULL.The data was read correctly from the device if the Token-&gt;Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the read. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The BufferSize parameter is not a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The read request contains LBAs that are not valid, or the buffer is not on proper alignment. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Write BufferSize bytes from Lba into Buffer.</p>
<p>This function writes the requested number of blocks to the device. All blocks are written, or an error is returned.If EFI_DEVICE_ERROR, EFI_NO_MEDIA, EFI_WRITE_PROTECTED or EFI_MEDIA_CHANGED is returned and non-blocking I/O is being used, the Event associated with this request will not be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>The media ID that the write request is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Lba</td><td>The starting logical block address to be written. The caller is responsible for writing to only legitimate locations. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>Size of Buffer, must be a multiple of device block size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>A pointer to the source buffer for the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The write request was queued if Event is not NULL. The data was written correctly to the device if the Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device can not be written to. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHNAGED</td><td>The MediaId does not matched the current device. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the write. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The Buffer was not a multiple of the block size of the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The write request contains LBAs that are not valid, or the buffer is not on proper alignment. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Flush the Block Device.</p>
<p>If EFI_DEVICE_ERROR, EFI_NO_MEDIA,_EFI_WRITE_PROTECTED or EFI_MEDIA_CHANGED is returned and non-blocking I/O is being used, the Event associated with this request will not be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The flush request was queued if Event is not NULL. All outstanding data was written correctly to the device if the Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while writting back the data. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>The async callback of AsyncReceiveEvent().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Data received via asynchronous transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>The length of Data in bytes, received via asynchronous transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Context passed from asynchronous transfer request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback does execute successfully. </td></tr>
    <tr><td class="paramname">Others</td><td>The callback doesn't execute successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Receive HCI event packet in non-blocking way.</p>
<p>The AsyncReceiveEvent() function receives HCI event packet in non-blocking way. Data in Callback function holds the whole HCI event packet, including EventCode, parameter length, and parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_HC_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IsNewTransfer</td><td>If TRUE, a new transfer will be submitted. If FALSE, the request is deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PollingInterval</td><td>Indicates the periodic rate, in milliseconds, that the transfer is to be executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>Specifies the length, in bytes, of the data to be received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>The callback function. This function is called if the asynchronous transfer is completed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The HCI asynchronous receive request is submitted successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: DataLength is 0. If IsNewTransfer is TRUE, and an asynchronous receive request already exists.</td></tr>
  </table>
  </dd>
</dl>
<p>Receive HCI ACL data packet in non-blocking way.</p>
<p>The AsyncReceiveACLData() function receives HCI ACL data packet in non-blocking way. Data in Callback holds the whole HCI ACL data packet, including Handle, PB flag, BC flag, data length, and data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_HC_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IsNewTransfer</td><td>If TRUE, a new transfer will be submitted. If FALSE, the request is deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PollingInterval</td><td>Indicates the periodic rate, in milliseconds, that the transfer is to be executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>Specifies the length, in bytes, of the data to be received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>The callback function. This function is called if the asynchronous transfer is completed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The HCI asynchronous receive request is submitted successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: DataLength is 0. If IsNewTransfer is TRUE, and an asynchronous receive request already exists.</td></tr>
  </table>
  </dd>
</dl>
<p>Receive HCI SCO data packet in non-blocking way.</p>
<p>The AsyncReceiveSCOData() function receives HCI SCO data packet in non-blocking way. Data in Callback holds the whole HCI SCO data packet, including ConnectionHandle, PacketStatus flag, data length, and data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_HC_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IsNewTransfer</td><td>If TRUE, a new transfer will be submitted. If FALSE, the request is deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PollingInterval</td><td>Indicates the periodic rate, in milliseconds, that the transfer is to be executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>Specifies the length, in bytes, of the data to be received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>The callback function. This function is called if the asynchronous transfer is completed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The HCI asynchronous receive request is submitted successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: DataLength is 0. If IsNewTransfer is TRUE, and an asynchronous receive request already exists.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the current status of the key management service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The KMS is ready for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>No connection to the KMS is available. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>No valid connection configuration exists for the KMS. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>No response was received from the KMS. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the KMS. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Register client information with the supported KMS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The client information has been accepted by the KMS. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>No connection to the KMS is available. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>There was no response from the device or the key server. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the KMS. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required resources were not available to perform the function. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The KMS does not support the use of client identifiers.</td></tr>
  </table>
  </dd>
</dl>
<p>Request that the KMS generate one or more new keys and associate them with key identifiers. The key value(s) is returned to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors to be processed by this operation. On return, this number will be updated with the number of key descriptors successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys to be generated. On input, the KeyIdentifierSize and the KeyIdentifier may specify an identifier to be used for the key, but this is not required. The KeyFormat field must specify a key format <a class="el" href="struct_g_u_i_d.html">GUID</a> reported as supported by the KeyFormats field of the EFI_KMS_PROTOCOL. The value for this field in the first key descriptor will be considered the default value for subsequent key descriptors requested in this operation if those key descriptors have a NULL <a class="el" href="struct_g_u_i_d.html">GUID</a> in the key format field. On output, the KeyIdentifierSize and KeyIdentifier fields will specify an identifier for the key which will be either the original identifier if one was provided, or an identifier generated either by the KMS or the KMS protocol implementation. The KeyFormat field will be updated with the <a class="el" href="struct_g_u_i_d.html">GUID</a> used to generate the key if it was a NULL <a class="el" href="struct_g_u_i_d.html">GUID</a>, and the KeyValue field will contain a pointer to memory containing the key value for the generated key. Memory for both the KeyIdentifier and the KeyValue fields will be allocated with the BOOT_SERVICES_DATA type and must be freed by the caller when it is no longer needed. Also, the KeyStatus field must reflect the result of the request relative to that key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully generated and retrieved all requested keys. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported by the KMS. &ndash;OR&ndash; One (or more) of the key requests submitted is not supported by the KMS. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required resources were not available to perform the function. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either no id was provided or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the KMS. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or Keys is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures could not be processed properly. KeyDescriptorCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve an existing key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors to be processed by this operation. On return, this number will be updated with the number of key descriptors successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys to be retrieved from the KMS. On input, the KeyIdentifierSize and the KeyIdentifier must specify an identifier to be used to retrieve a specific key. All other fields in the descriptor should be NULL. On output, the KeyIdentifierSize and KeyIdentifier fields will be unchanged, while the KeyFormat and KeyValue fields will be updated values associated with this key identifier. Memory for the KeyValue field will be allocated with the BOOT_SERVICES_DATA type and must be freed by the caller when it is no longer needed. Also, the KeyStatus field will reflect the result of the request relative to the individual key descriptor. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully retrieved all requested keys. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate resources for the method processing. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple keys are associated with a single identifier, and the KeyValue buffer does not contain enough structures (KeyDescriptorCount) to contain all the key data, then the available structures will be filled and KeyDescriptorCount will be updated to indicate the number of keys which could not be processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or Keys is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures could not be processed properly. KeyDescriptorCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Add a new key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors to be processed by this operation. On normal return, this number will be updated with the number of key descriptors successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys to be added. On input, the KeyId field for first key must contain valid identifier data to be used for adding a key to the KMS. The values for these fields in this key definition will be considered default values for subsequent keys requested in this operation. A value of 0 in any subsequent KeyId field will be replaced with the current default value. The KeyFormat and KeyValue fields for each key to be added must contain consistent values to be associated with the given KeyId. On return, the KeyStatus field will reflect the result of the operation for each key request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully added all requested keys. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple keys are associated with a single identifier, and the KeyValue buffer does not contain enough structures (KeyDescriptorCount) to contain all the key data, then the available structures will be filled and KeyDescriptorCount will be updated to indicate the number of keys which could not be processed </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or Keys is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures could not be processed properly. KeyDescriptorCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete an existing key from the KMS database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors to be processed by this operation. On normal return, this number will be updated with the number of key descriptors successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys to be deleted. On input, the KeyId field for first key must contain valid identifier data to be used for adding a key to the KMS. The values for these fields in this key definition will be considered default values for subsequent keys requested in this operation. A value of 0 in any subsequent KeyId field will be replaced with the current default value. The KeyFormat and KeyValue fields are ignored, but should be 0. On return, the KeyStatus field will reflect the result of the operation for each key request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully deleted all requested keys. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or Keys is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures could not be processed properly. KeyDescriptorCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Get one or more attributes associated with a specified key identifier. If none are found, the returned attributes count contains a value of zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifierSize</td><td>Pointer to the size in bytes of the KeyIdentifier variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifier</td><td>Pointer to the key identifier associated with this key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributesCount</td><td>Pointer to the number of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures associated with the Key identifier. If none are found, the count value is zero on return. On input this value reflects the number of KeyAttributes that may be returned. On output, the value reflects the number of completed KeyAttributes structures found. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributes</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures associated with the Key Identifier. On input, the fields in the structure should be NULL. On output, the attribute fields will have updated values for attributes associated with this key identifier. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully retrieved all key attributes. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate resources for the method processing. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key attribute request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple key attributes are associated with a single identifier, and the KeyAttributes buffer does not contain enough structures (KeyAttributesCount) to contain all the key attributes data, then the available structures will be filled and KeyAttributesCount will be updated to indicate the number of key attributes which could not be processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key attribute request(s) (i.e. key attribute status for each) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyIdentifierSize is NULL , or KeyIdentifier is NULL, or KeyAttributes is NULL, or KeyAttributesSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The KeyIdentifier could not be found. KeyAttributesCount contains zero. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Add one or more attributes to a key specified by a key identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifierSize</td><td>Pointer to the size in bytes of the KeyIdentifier variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifier</td><td>Pointer to the key identifier associated with this key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributesCount</td><td>Pointer to the number of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures to associate with the Key. On normal returns, this number will be updated with the number of key attributes successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributes</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures providing the attribute information to associate with the key. On input, the values for the fields in the structure are completely filled in. On return the KeyAttributeStatus field will reflect the result of the operation for each key attribute request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully added all requested key attributes. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key attribute request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple keys attributes are associated with a single key identifier, and the attributes buffer does not contain enough structures (KeyAttributesCount) to contain all the data, then the available structures will be filled and KeyAttributesCount will be updated to indicate the number of key attributes which could not be processed. The status of each key attribute is also updated indicating success or failure for that attribute in case there are other errors for those attributes that could be processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key attribute request(s) (i.e. key attribute status for each) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyAttributesCount is NULL, or KeyAttributes is NULL, or KeyIdentifierSize is NULL, or KeyIdentifer is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The KeyIdentifier could not be found. On return the KeyAttributesCount contains the number of attributes processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete attributes to a key specified by a key identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifierSize</td><td>Pointer to the size in bytes of the KeyIdentifier variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifier</td><td>Pointer to the key identifier associated with this key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributesCount</td><td>Pointer to the number of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures to associate with the Key. On input, the count value is one or more. On normal returns, this number will be updated with the number of key attributes successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributes</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures providing the attribute information to associate with the key. On input, the values for the fields in the structure are completely filled in. On return the KeyAttributeStatus field will reflect the result of the operation for each key attribute request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully deleted all requested key attributes. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key attribute request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key attribute request(s) (i.e. key attribute status for each) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyAttributesCount is NULL, or KeyAttributes is NULL, or KeyIdentifierSize is NULL, or KeyIdentifer is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The KeyIdentifier could not be found or the attribute could not be found. On return the KeyAttributesCount contains the number of attributes processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve one or more key that has matched all of the specified key attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributesCount</td><td>Pointer to a count of the number of key attribute structures that must be matched for each returned key descriptor. On input the count value is one or more. On normal returns, this number will be updated with the number of key attributes successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributes</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structure to search for. On input, the values for the fields in the structure are completely filled in. On return the KeyAttributeStatus field will reflect the result of the operation for each key attribute request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors matched by this operation. On entry, this number will be zero. On return, this number will be updated to the number of key descriptors successfully found. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys from the KMS having the KeyAttribute(s) specified. On input, this pointer will be NULL. On output, the array will contain an <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structure for each key meeting the search criteria. Memory for the array and all KeyValue fields will be allocated with the EfiBootServicesData type and must be freed by the caller when it is no longer needed. Also, the KeyStatus field of each descriptor will reflect the result of the request relative to that key descriptor. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully retrieved all requested keys. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key attribute request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple keys are associated with the attribute(s), and the KeyValue buffer does not contain enough structures (KeyDescriptorCount) to contain all the key data, then the available structures will be filled and KeyDescriptorCount will be updated to indicate the number of keys which could not be processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key attribute request(s) (i.e. key attribute status for each) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or KeyDescriptors is NULL or KeyAttributes is NULL, or KeyAttributesCount is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures could not be processed properly. KeyAttributeCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Execute the command line.</p>
<p>This function creates a nested instance of the shell and executes the specified command (CommandLine) with the specified environment (Environment). Upon return, the status code returned by the specified command is placed in StatusCode.</p>
<p>If Environment is NULL, then the current environment is used and all changes made by the commands executed will be reflected in the current environment. If the Environment is non-NULL, then the changes made will be discarded.</p>
<p>The CommandLine is executed from the current working directory on the current device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ParentImageHandle</td><td>A handle of the image that is executing the specified command line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CommandLine</td><td>Points to the NULL-terminated UCS-2 encoded string containing the command line. If NULL then the command- line will be empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Environment</td><td>Points to a NULL-terminated array of environment variables with the format 'x=y', where x is the environment variable name and y is the value. If this is NULL, then the current shell environment is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ErrorCode</td><td>Points to the status code returned by the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The command executed successfully. The status code returned by the command is pointed to by StatusCode. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Out of resources. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Nested shell invocations are not allowed.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees the file list.</p>
<p>This function cleans up the file list and any related data structures. It has no impact on the files themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileList</td><td>The file list to free. Type <a class="el" href="struct_e_f_i___s_h_e_l_l___f_i_l_e___i_n_f_o.html">EFI_SHELL_FILE_INFO</a> is defined in OpenFileList().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Free the file list successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the name of the device specified by the device handle.</p>
<p>This function gets the user-readable name of the device specified by the device handle. If no user-readable name could be generated, then *BestDeviceName will be NULL and EFI_NOT_FOUND will be returned.</p>
<p>If EFI_DEVICE_NAME_USE_COMPONENT_NAME is set, then the function will return the device's name using the EFI_COMPONENT_NAME2_PROTOCOL, if present on DeviceHandle.</p>
<p>If EFI_DEVICE_NAME_USE_DEVICE_PATH is set, then the function will return the device's name using the <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a>, if present on DeviceHandle. If both EFI_DEVICE_NAME_USE_COMPONENT_NAME and EFI_DEVICE_NAME_USE_DEVICE_PATH are set, then EFI_DEVICE_NAME_USE_COMPONENT_NAME will have higher priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceHandle</td><td>The handle of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Determines the possible sources of component names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Language</td><td>A pointer to the language specified for the device name, in the same format as described in the UEFI specification, Appendix M. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BestDeviceName</td><td>On return, points to the callee-allocated NULL- terminated name of the device. If no device name could be found, points to NULL. The name must be freed by the caller...</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Get the name successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Fail to get the device name.</td></tr>
  </table>
  </dd>
</dl>
<p>Return help information about a specific command.</p>
<p>This function returns the help information for the specified command. The help text can be internal to the shell or can be from a UEFI Shell manual page.</p>
<p>If Sections is specified, then each section name listed will be compared in a casesensitive manner, to the section names described in Appendix B. If the section exists, it will be appended to the returned help text. If the section does not exist, no information will be returned. If Sections is NULL, then all help text information available will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Command</td><td>Points to the NULL-terminated UEFI Shell command name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sections</td><td>Points to the NULL-terminated comma-delimited section names to return. If NULL, then all sections will be returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HelpText</td><td>On return, points to a callee-allocated buffer containing all specified help text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The help text was returned. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The necessary buffer could not be allocated to hold the returned help text. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HelpText is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There is no help text available for Command.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens a file or a directory by file name.</p>
<p>This function opens the specified file in the specified OpenMode and returns a file handle. If the file name begins with '&gt;v', then the file handle which is returned refers to the shell environment variable with the specified name. If the shell environment variable exists, is non-volatile and the OpenMode indicates EFI_FILE_MODE_WRITE, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file name is '&gt;i', then the file handle which is returned refers to the standard input. If the OpenMode indicates EFI_FILE_MODE_WRITE, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file name is '&gt;o', then the file handle which is returned refers to the standard output. If the OpenMode indicates EFI_FILE_MODE_READ, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file name is '&gt;e', then the file handle which is returned refers to the standard error. If the OpenMode indicates EFI_FILE_MODE_READ, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file name is 'NUL', then the file handle that is returned refers to the standard NUL file. If the OpenMode indicates EFI_FILE_MODE_READ, then EFI_INVALID_PARAMETER is returned.</p>
<p>If return EFI_SUCCESS, the FileHandle is the opened file's handle, else, the FileHandle is NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileName</td><td>Points to the NULL-terminated UCS-2 encoded file name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FileHandle</td><td>On return, points to the file handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OpenMode</td><td>File open mode. Either EFI_FILE_MODE_READ or EFI_FILE_MODE_WRITE from section 12.4 of the UEFI Specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The file was opened. FileHandle has the opened file's handle. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One of the parameters has an invalid value. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Could not open the file path. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified file could not be found on the device or the file system could not be found on the device. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no medium. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The device has a different medium in it or the medium is no longer supported. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error or can't get the file path according the FileName. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>An attempt was made to create a file, or open a file for write when the media is write-protected. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The service denied access to the file. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Not enough resources were available to open the file. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The volume is full. FileHandle is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens the files that match the path specified.</p>
<p>This function opens all of the files specified by Path. Wildcards are processed according to the rules specified in UEFI Shell 2.0 spec section 3.7.1. Each matching file has an <a class="el" href="struct_e_f_i___s_h_e_l_l___f_i_l_e___i_n_f_o.html">EFI_SHELL_FILE_INFO</a> structure created in a linked list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Path</td><td>A pointer to the path string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OpenMode</td><td>Specifies the mode used to open each file, EFI_FILE_MODE_READ or EFI_FILE_MODE_WRITE. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FileList</td><td>Points to the start of a list of files opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Create the file list successfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Can't create the file list.</dd></dl>
<p>Reads data from the file.</p>
<p>If FileHandle is not a directory, the function reads the requested number of bytes from the file at the file's current position and returns them in Buffer. If the read goes beyond the end of the file, the read length is truncated to the end of the file. The file's current position is increased by the number of bytes returned. If FileHandle is a directory, then an error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileHandle</td><td>The opened file handle for read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ReadSize</td><td>On input, the size of Buffer, in bytes. On output, the amount of data read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Buffer</td><td>The buffer in which data is read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Data was read. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no media. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TO_SMALL</td><td>Buffer is too small. ReadSize contains required size.</td></tr>
  </table>
  </dd>
</dl>
<p>Deletes the duplicate file names files in the given file list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileList</td><td>A pointer to the first entry in the file list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Always success.</td></tr>
  </table>
  </dd>
</dl>
<p>Changes the current directory on the specified device.</p>
<p>If the FileSystem is NULL, and the directory Dir does not contain a file system's mapped name, this function changes the current working directory. If FileSystem is NULL and the directory Dir contains a mapped name, then the current file system and the current directory on that file system are changed.</p>
<p>If FileSystem is not NULL, and Dir is NULL, then this changes the current working file system.</p>
<p>If FileSystem is not NULL and Dir is not NULL, then this function changes the current directory on the specified file system.</p>
<p>If the current working directory or the current working file system is changed then the cwd% environment variable will be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileSystem</td><td>A pointer to the file system's mapped name. If NULL, then the current working directory is changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dir</td><td>Points to the NULL-terminated directory on the device specified by FileSystem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>Current directory does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current directory.</dd></dl>
<p>Sets the environment variable.</p>
<p>This function changes the current value of the specified environment variable. If the environment variable exists and the Value is an empty string, then the environment variable is deleted. If the environment variable exists and the Value is not an empty string, then the value of the environment variable is changed. If the environment variable does not exist and the Value is an empty string, there is no action. If the environment variable does not exist and the Value is a non-empty string, then the environment variable is created and assigned the specified value.</p>
<p>For a description of volatile and non-volatile environment variables, see UEFI Shell 2.0 specification section 3.6.1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Name</td><td>Points to the NULL-terminated environment variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Value</td><td>Points to the NULL-terminated environment variable value. If the value is an empty string then the environment variable is deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Volatile</td><td>Indicates whether the variable is non-volatile (FALSE) or volatile (TRUE).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The environment variable was successfully updated.</td></tr>
  </table>
  </dd>
</dl>
<p>Manipulate the chip select for a SPI device.</p>
<p>This routine must be called at or below TPL_NOTIFY. Update the value of the chip select line for a SPI peripheral. The SPI bus layer calls this routine either in the board layer or in the SPI controller to manipulate the chip select pin at the start and end of a SPI transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SpiPeripheral</td><td>The address of an EFI_SPI_PERIPHERAL data structure describing the SPI peripheral whose chip select pin is to be manipulated. The routine may access the ChipSelectParameter field to gain sufficient context to complete the operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PinValue</td><td>The value to be applied to the chip select line of the SPI peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The chip select was set successfully </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Support for the chip select is not properly initialized </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The SpiPeripheral-&gt;ChipSelectParameter value is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Set up the clock generator to produce the correct clock frequency, phase and polarity for a SPI chip.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine updates the clock generator to generate the correct frequency and polarity for the SPI clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SpiPeripheral</td><td>Pointer to a EFI_SPI_PERIPHERAL data structure from which the routine can access the ClockParameter, ClockPhase and ClockPolarity fields. The routine also has access to the names for the SPI bus and chip which can be used during debugging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ClockHz</td><td>Pointer to the requested clock frequency. The clock generator will choose a supported clock frequency which is less then or equal to this value. Specify zero to turn the clock generator off. The actual clock frequency supported by the clock generator will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The clock was set up successfully </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The SPI controller was not able to support the frequency requested by CLockHz</td></tr>
  </table>
  </dd>
</dl>
<p>Returns information about the regular expression syntax types supported by the implementation.</p>
<p>This A pointer to the EFI_REGULAR_EXPRESSION_PROTOCOL instance.</p>
<p>RegExSyntaxTypeListSize On input, the size in bytes of RegExSyntaxTypeList. On output with a return code of EFI_SUCCESS, the size in bytes of the data returned in RegExSyntaxTypeList. On output with a return code of EFI_BUFFER_TOO_SMALL, the size of RegExSyntaxTypeListrequired to obtain the list.</p>
<p>RegExSyntaxTypeList A caller-allocated memory buffer filled by the driver with one EFI_REGEX_SYNTAX_TYPEelement for each supported Regular expression syntax type. The list must not change across multiple calls to the same driver. The first syntax type in the list is the default type for the driver.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The regular expression syntax types list was returned successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The service is not supported by this driver. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The list of syntax types could not be retrieved due to a hardware or firmware error. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer RegExSyntaxTypeList is too small to hold the result. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RegExSyntaxTypeListSize is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Checks if the input string matches to the regular expression pattern.</p>
<p>This A pointer to the EFI_REGULAR_EXPRESSION_PROTOCOL instance. Type EFI_REGULAR_EXPRESSION_PROTOCOL is defined in Section XYZ.</p>
<p>String A pointer to a NULL terminated string to match against the regular expression string specified by Pattern.</p>
<p>Pattern A pointer to a NULL terminated string that represents the regular expression.</p>
<p>SyntaxType A pointer to the EFI_REGEX_SYNTAX_TYPE that identifies the regular expression syntax type to use. May be NULL in which case the function will use its default regular expression syntax type.</p>
<p>Result On return, points to TRUE if String fully matches against the regular expression Pattern using the regular expression SyntaxType. Otherwise, points to FALSE.</p>
<p>Captures A Pointer to an array of <a class="el" href="struct_e_f_i___r_e_g_e_x___c_a_p_t_u_r_e.html">EFI_REGEX_CAPTURE</a> objects to receive the captured groups in the event of a match. The full sub-string match is put in Captures[0], and the results of N capturing groups are put in Captures[1:N]. If Captures is NULL, then this function doesn't allocate the memory for the array and does not build up the elements. It only returns the number of matching patterns in CapturesCount. If Captures is not NULL, this function returns a pointer to an array and builds up the elements in the array. CapturesCount is also updated to the number of matching patterns found. It is the caller's responsibility to free the memory pool in Captures and in each CapturePtr in the array elements.</p>
<p>CapturesCount On output, CapturesCount is the number of matching patterns found in String. Zero means no matching patterns were found in the string.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The regular expression string matching completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The regular expression syntax specified by SyntaxTypeis not supported by this driver. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The regular expression string matching failed due to a hardware or firmware error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>String, Pattern, Result, or CapturesCountis NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function, it is called when asynchronous transfer is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ChannelID</td><td>Bluetooth L2CAP message channel ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Data received via asynchronous transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>The length of Data in bytes, received via asynchronous transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Context passed from asynchronous transfer request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function, it is called when asynchronous transfer is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Data received via asynchronous transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>The length of Data in bytes, received via asynchronous transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Context passed from asynchronous transfer request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Create HTTP header based on a combination of seed header, fields to delete, and fields to append.</p>
<p>The Build() function is used to manage the headers portion of an HTTP message by providing the ability to add, remove, or replace HTTP headers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_HTTP_UTILITIES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SeedMessageSize</td><td>Size of the initial HTTP header. This can be zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SeedMessage</td><td>Initial HTTP header to be used as a base for building a new HTTP header. If NULL, SeedMessageSize is ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeleteCount</td><td>Number of null-terminated HTTP header field names in DeleteList. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeleteList</td><td>List of null-terminated HTTP header field names to remove from SeedMessage. Only the field names are in this list because the field values are irrelevant to this operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AppendCount</td><td>Number of header fields in AppendList. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AppendList</td><td>List of HTTP headers to populate NewMessage with. If SeedMessage is not NULL, AppendList will be appended to the existing list from SeedMessage in NewMessage. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NewMessageSize</td><td>Pointer to number of header fields in NewMessage. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NewMessage</td><td>Pointer to a new list of HTTP headers based on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Add, remove, and replace operations succeeded. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate memory for NewMessage. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Parses HTTP header and produces an array of key/value pairs.</p>
<p>The Parse() function is used to transform data stored in HttpHeader into a list of fields paired with their corresponding values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_HTTP_UTILITIES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HttpMessage</td><td>Contains raw unformatted HTTP header string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HttpMessageSize</td><td>Size of HTTP header. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HeaderFields</td><td>Array of key/value header pairs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FieldCount</td><td>Number of headers in HeaderFields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Allocation succeeded. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI HTTP Protocol instance has not been initialized. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. HttpMessage is NULL. HeaderFields is NULL. FieldCount is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function, it is called if a Bluetooth device is found during scan process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">Context</td><td>Context passed from scan request. </td></tr>
    <tr><td class="paramname">CallbackInfo</td><td>Data related to scan result. NULL CallbackInfo means scan complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the frequency for the I2C clock line.</p>
<p>This routine must be called at or below TPL_NOTIFY.</p>
<p>The software and controller do a best case effort of using the specified frequency for the I2C bus. If the frequency does not match exactly then the I2C master protocol selects the next lower frequency to avoid exceeding the operating conditions for any of the I2C devices on the bus. For example if 400 KHz was specified and the controller's divide network only supports 402 KHz or 398 KHz then the I2C master protocol selects 398 KHz. If there are not lower frequencies available, then return EFI_UNSUPPORTED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_MASTER_PROTOCOL structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BusClockHertz</td><td>Pointer to the requested I2C bus clock frequency in Hertz. Upon return this value contains the actual frequency in use by the I2C controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The bus frequency was set successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The controller is busy with another transaction. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BusClockHertz is NULL </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The controller does not support this frequency.</td></tr>
  </table>
  </dd>
</dl>
<p>Reset the I2C controller and configure it for use</p>
<p>This routine must be called at or below TPL_NOTIFY.</p>
<p>The I2C controller is reset. The caller must call SetBusFrequench() after calling Reset().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_MASTER_PROTOCOL structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The reset completed successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The controller is busy with another transaction. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The reset operation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>Start an I2C transaction on the host controller.</p>
<p>This routine must be called at or below TPL_NOTIFY. For synchronous requests this routine must be called at or below TPL_CALLBACK.</p>
<p>This function initiates an I2C transaction on the controller. To enable proper error handling by the I2C protocol stack, the I2C master protocol does not support queuing but instead only manages one I2C transaction at a time. This API requires that the I2C bus is in the correct configuration for the I2C transaction.</p>
<p>The transaction is performed by sending a start-bit and selecting the I2C device with the specified I2C slave address and then performing the specified I2C operations. When multiple operations are requested they are separated with a repeated start bit and the slave address. The transaction is terminated with a stop bit.</p>
<p>When Event is NULL, StartRequest operates synchronously and returns the I2C completion status as its return value.</p>
<p>When Event is not NULL, StartRequest synchronously returns EFI_SUCCESS indicating that the I2C transaction was started asynchronously. The transaction status value is returned in the buffer pointed to by I2cStatus upon the completion of the I2C transaction when I2cStatus is not NULL. After the transaction status is returned the Event is signaled.</p>
<p>Note: The typical consumer of this API is the I2C host protocol. Extreme care must be taken by other consumers of this API to prevent confusing the third party I2C drivers due to a state change at the I2C device which the third party I2C drivers did not initiate. I2C platform specific code may use this API within these guidelines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_MASTER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SlaveAddress</td><td>Address of the device on the I2C bus. Set the I2C_ADDRESSING_10_BIT when using 10-bit addresses, clear this bit for 7-bit addressing. Bits 0-6 are used for 7-bit I2C slave addresses and bits 0-9 are used for 10-bit I2C slave addresses. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestPacket</td><td>Pointer to an <a class="el" href="struct_e_f_i___i2_c___r_e_q_u_e_s_t___p_a_c_k_e_t.html">EFI_I2C_REQUEST_PACKET</a> structure describing the I2C transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>Event to signal for asynchronous transactions, NULL for asynchronous transactions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I2cStatus</td><td>Optional buffer to receive the I2C transaction completion status</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The asynchronous transaction was successfully started when Event is not NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The transaction completed successfully when Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The controller is busy with another transaction. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The RequestPacket-&gt;LengthInBytes value is too large. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>There was an I2C error (NACK) during the transaction. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RequestPacket is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Reserved bit set in the SlaveAddress parameter </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>The I2C device is not responding to the slave address. EFI_DEVICE_ERROR will be returned if the controller cannot distinguish when the NACK occurred. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory for I2C transaction </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The controller does not support the requested transaction.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends SD command to an SD card that is attached to the SD controller.</p>
<p>The PassThru() function sends the SD command specified by Packet to the SD card specified by Slot.</p>
<p>If Packet is successfully sent to the SD card, then EFI_SUCCESS is returned.</p>
<p>If a device error occurs while sending the Packet, then EFI_DEVICE_ERROR is returned.</p>
<p>If Slot is not in a valid range for the SD controller, then EFI_INVALID_PARAMETER is returned.</p>
<p>If Packet defines a data command but both InDataBuffer and OutDataBuffer are NULL, EFI_INVALID_PARAMETER is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>The slot number of the SD card to send the command to. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Packet</td><td>A pointer to the SD command data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>If Event is NULL, blocking I/O is performed. If Event is not NULL, then nonblocking I/O is performed, and Event will be signaled when the Packet completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SD Command Packet was sent by the host. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A device error occurred while attempting to send the SD command Packet. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Packet, Slot, or the contents of the Packet is invalid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Packet defines a data command but both InDataBuffer and OutDataBuffer are NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>SD Device not present in the Slot. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The command described by the SD Command Packet is not supported by the host controller. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The InTransferLength or OutTransferLength exceeds the limit supported by SD card ( i.e. if the number of bytes exceed the Last LBA).</td></tr>
  </table>
  </dd>
</dl>
<p>Used to retrieve next slot numbers supported by the SD controller. The function returns information about all available slots (populated or not-populated).</p>
<p>The GetNextSlot() function retrieves the next slot number on an SD controller. If on input Slot is 0xFF, then the slot number of the first slot on the SD controller is returned.</p>
<p>If Slot is a slot number that was returned on a previous call to GetNextSlot(), then the slot number of the next slot on the SD controller is returned.</p>
<p>If Slot is not 0xFF and Slot was not returned on a previous call to GetNextSlot(), EFI_INVALID_PARAMETER is returned.</p>
<p>If Slot is the slot number of the last slot on the SD controller, then EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Slot</td><td>On input, a pointer to a slot number on the SD controller. On output, a pointer to the next slot number on the SD controller. An input value of 0xFF retrieves the first slot number on the SD controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The next slot number on the SD controller was returned in Slot. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There are no more slots on this SD controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Slot is not 0xFF and Slot was not returned on a previous call to GetNextSlot().</td></tr>
  </table>
  </dd>
</dl>
<p>Used to allocate and build a device path node for an SD card on the SD controller.</p>
<p>The BuildDevicePath() function allocates and builds a single device node for the SD card specified by Slot.</p>
<p>If the SD card specified by Slot is not present on the SD controller, then EFI_NOT_FOUND is returned.</p>
<p>If DevicePath is NULL, then EFI_INVALID_PARAMETER is returned.</p>
<p>If there are not enough resources to allocate the device path node, then EFI_OUT_OF_RESOURCES is returned.</p>
<p>Otherwise, DevicePath is allocated with the boot service <a class="el" href="_memory_allocation_lib_8h.html#a646c0f82c2a35557dda175dbfcd26e96">AllocatePool()</a>, the contents of DevicePath are initialized to describe the SD card specified by Slot, and EFI_SUCCESS is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>Specifies the slot number of the SD card for which a device path node is to be allocated and built. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>A pointer to a single device path node that describes the SD card specified by Slot. This function is responsible for allocating the buffer DevicePath with the boot service <a class="el" href="_memory_allocation_lib_8h.html#a646c0f82c2a35557dda175dbfcd26e96">AllocatePool()</a>. It is the caller's responsibility to free DevicePath when the caller is finished with DevicePath.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path node that describes the SD card specified by Slot was allocated and returned in DevicePath. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The SD card specified by Slot does not exist on the SD controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There are not enough resources to allocate DevicePath.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves an SD card slot number based on the input device path.</p>
<p>The GetSlotNumber() function retrieves slot number for the SD card specified by the DevicePath node. If DevicePath is NULL, EFI_INVALID_PARAMETER is returned.</p>
<p>If DevicePath is not a device path node type that the SD Pass Thru driver supports, EFI_UNSUPPORTED is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DevicePath</td><td>A pointer to the device path node that describes a SD card on the SD controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Slot</td><td>On return, points to the slot number of an SD card on the SD controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>SD card slot number is returned in Slot. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Slot or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>DevicePath is not a device path node type that the SD Pass Thru driver supports.</td></tr>
  </table>
  </dd>
</dl>
<p>Resets an SD card that is connected to the SD controller.</p>
<p>The ResetDevice() function resets the SD card specified by Slot.</p>
<p>If this SD controller does not support a device reset operation, EFI_UNSUPPORTED is returned.</p>
<p>If Slot is not in a valid slot number for this SD controller, EFI_INVALID_PARAMETER is returned.</p>
<p>If the device reset operation is completed, EFI_SUCCESS is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>Specifies the slot number of the SD card to be reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SD card specified by Slot was reset. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The SD controller does not support a device reset operation. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Slot number is invalid. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>SD Device not present in the Slot. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The reset command failed due to a device error</td></tr>
  </table>
  </dd>
</dl>
<p>Queue an I2C transaction for execution on the I2C controller.</p>
<p>This routine must be called at or below TPL_NOTIFY. For synchronous requests this routine must be called at or below TPL_CALLBACK.</p>
<p>The I2C host protocol uses the concept of I2C bus configurations to describe the I2C bus. An I2C bus configuration is defined as a unique setting of the multiplexers and switches in the I2C bus which enable access to one or more I2C devices. When using a switch to divide a bus, due to bus frequency differences, the I2C bus configuration management protocol defines an I2C bus configuration for the I2C devices on each side of the switch. When using a multiplexer, the I2C bus configuration management defines an I2C bus configuration for each of the selector values required to control the multiplexer. See Figure 1 in the I2C -bus specification and user manual for a complex I2C bus configuration.</p>
<p>The I2C host protocol processes all transactions in FIFO order. Prior to performing the transaction, the I2C host protocol calls EnableI2cBusConfiguration to reconfigure the switches and multiplexers in the I2C bus enabling access to the specified I2C device. The EnableI2cBusConfiguration also selects the I2C bus frequency for the I2C device. After the I2C bus is configured, the I2C host protocol calls the I2C master protocol to start the I2C transaction.</p>
<p>When Event is NULL, QueueRequest() operates synchronously and returns the I2C completion status as its return value.</p>
<p>When Event is not NULL, QueueRequest() synchronously returns EFI_SUCCESS indicating that the asynchronously I2C transaction was queued. The values above are returned in the buffer pointed to by I2cStatus upon the completion of the I2C transaction when I2cStatus is not NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_HOST_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I2cBusConfiguration</td><td>I2C bus configuration to access the I2C device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SlaveAddress</td><td>Address of the device on the I2C bus. Set the I2C_ADDRESSING_10_BIT when using 10-bit addresses, clear this bit for 7-bit addressing. Bits 0-6 are used for 7-bit I2C slave addresses and bits 0-9 are used for 10-bit I2C slave addresses. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>Event to signal for asynchronous transactions, NULL for synchronous transactions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestPacket</td><td>Pointer to an <a class="el" href="struct_e_f_i___i2_c___r_e_q_u_e_s_t___p_a_c_k_e_t.html">EFI_I2C_REQUEST_PACKET</a> structure describing the I2C transaction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I2cStatus</td><td>Optional buffer to receive the I2C transaction completion status</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The asynchronous transaction was successfully queued when Event is not NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The transaction completed successfully when Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The RequestPacket-&gt;LengthInBytes value is too large. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>There was an I2C error (NACK) during the transaction. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RequestPacket is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Reserved bit set in the SlaveAddress parameter </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>Invalid I2cBusConfiguration value </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>The I2C device is not responding to the slave address. EFI_DEVICE_ERROR will be returned if the controller cannot distinguish when the NACK occurred. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory for I2C transaction </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The controller does not support the requested transaction.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the erase block opcode.</p>
<p>This routine must be called at or below TPL_NOTIFY. The menu table contains SPI transaction opcodes which are accessible after the legacy SPI flash controller's configuration is locked. The board layer specifies the erase block size for the SPI NOR flash part. The SPI NOR flash peripheral driver selects the erase block opcode which matches the erase block size and uses this API to load the opcode into the opcode menu table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EraseBlockOpcode</td><td>Erase block opcode to be placed into the opcode menu table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The opcode menu table was updated </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked</td></tr>
  </table>
  </dd>
</dl>
<p>Set the write status prefix opcode.</p>
<p>This routine must be called at or below TPL_NOTIFY. The prefix table contains SPI transaction write prefix opcodes which are accessible after the legacy SPI flash controller's configuration is locked. The board layer specifies the write status prefix opcode for the SPI NOR flash part. The SPI NOR flash peripheral driver uses this API to load the opcode into the prefix table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WriteStatusPrefix</td><td>Prefix opcode for the write status command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The prefix table was updated </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked</td></tr>
  </table>
  </dd>
</dl>
<p>Set the BIOS base address.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS base address works with the protect range registers to protect portions of the SPI NOR flash from erase and write operat ions. The BIOS calls this API prior to passing control to the OS loader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BiosBaseAddress</td><td>The BIOS base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The BIOS base address was properly set </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The BIOS base address is greater than This-&gt;Maxi.mumOffset </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The BIOS base address was already set</td></tr>
  </table>
  </dd>
</dl>
<p>Clear the SPI protect range registers.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS uses this routine to set an initial condition on the SPI protect range registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The registers were successfully cleared </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked</td></tr>
  </table>
  </dd>
</dl>
<p>Set the next protect range register.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS sets the protect range register to prevent write and erase operations to a portion of the SPI NOR flash device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BiosAddress</td><td>Address within a 4 KiB block to start protecting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlocksToProtect</td><td>The number of 4 KiB blocks to protect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The register was successfully updated </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BiosAddress &lt; This-&gt;BiosBaseAddress, or BlocksToProtect * 4 KiB &gt; This-&gt;MaximumRangeBytes, or BiosAddress - This-&gt;BiosBaseAddress<ul>
<li>(BlocksToProtect * 4 KiB) &gt; This-&gt;MaximumRangeBytes </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>No protect range register available </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Call This-&gt;SetBaseAddress because the BIOS base address is not set</td></tr>
  </table>
  </dd>
</dl>
<p>Lock the SPI controller configuration.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine locks the SPI controller's configuration so that the software is no longer able to update: Prefix table Opcode menu Opcode type table BIOS base address Protect range registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SPI controller was successfully locked </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The SPI controller was already locked</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TCG2_PROTOCOL GetCapability function call provides protocol capability information and state information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ProtocolCapability</td><td>The caller allocates memory for a EFI_TCG2_BOOT_SERVICE_CAPABILITY structure and sets the size field to the size of the structure allocated. The callee fills in the fields with the EFI protocol capability information and the current EFI TCG2 state information up to the number of fields which fit within the size of the structure passed in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was unsuccessful. The ProtocolCapability variable will not be populated. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. The ProtocolCapability variable will not be populated. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The ProtocolCapability variable is too small to hold the full response. It will be partially populated (required Size field will be set).</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TCG2_PROTOCOL Get Event Log function call allows a caller to retrieve the address of a given event log and its last entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EventLogFormat</td><td>The type of the event log for which the information is requested. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogLocation</td><td>A pointer to the memory address of the event log. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogLastEntry</td><td>If the Event Log contains more than one entry, this is a pointer to the address of the start of the last entry in the event log in memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogTruncated</td><td>If the Event Log is missing at least one entry because an event would have exceeded the area allocated for events, this value is set to TRUE. Otherwise, the value will be FALSE and the Event Log will be complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect (e.g. asking for an event log whose format is not supported).</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TCG2_PROTOCOL HashLogExtendEvent function call provides callers with an opportunity to extend and optionally log events without requiring knowledge of actual TPM commands. The extend operation will occur even if this function cannot create an event log entry (e.g. due to the event log being full).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Bitmap providing additional information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataToHash</td><td>Physical address of the start of the data buffer to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataToHashLen</td><td>The length in bytes of the buffer referenced by DataToHash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EfiTcgEvent</td><td>Pointer to data buffer containing information about the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was unsuccessful. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The extend operation occurred, but the event could not be written to one or more event logs. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The PE/COFF image type is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>This service enables the sending of commands to the TPM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputParameterBlockSize</td><td>Size of the TPM input parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputParameterBlock</td><td>Pointer to the TPM input parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputParameterBlockSize</td><td>Size of the TPM output parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputParameterBlock</td><td>Pointer to the TPM output parameter block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The command byte stream was successfully sent to the device and a response was successfully received. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was not successfully sent to the device or a response was not successfully received from the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The output parameter block is too small.</td></tr>
  </table>
  </dd>
</dl>
<p>This service returns the currently active PCR banks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ActivePcrBanks</td><td>Pointer to the variable receiving the bitmap of currently active PCR banks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The bitmap of active PCR banks was stored in the ActivePcrBanks parameter. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect.</td></tr>
  </table>
  </dd>
</dl>
<p>This service sets the currently active PCR banks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ActivePcrBanks</td><td>Bitmap of the requested active PCR banks. At least one bit SHALL be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The bitmap in ActivePcrBank parameter is already active. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect.</td></tr>
  </table>
  </dd>
</dl>
<p>This service retrieves the result of a previous invocation of SetActivePcrBanks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OperationPresent</td><td>Non-zero value to indicate a SetActivePcrBank operation was invoked during the last boot. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Response</td><td>The response from the SetActivePcrBank request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The result value could be returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect.</td></tr>
  </table>
  </dd>
</dl>
<p>Displays a popup window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_HII_POPUP_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">PopupStyle</td><td>Popup style to use. </td></tr>
    <tr><td class="paramname">PopupType</td><td>Type of the popup to display. </td></tr>
    <tr><td class="paramname">HiiHandle</td><td>HII handle of the string pack containing Message </td></tr>
    <tr><td class="paramname">Message</td><td>A message to display in the popup box. </td></tr>
    <tr><td class="paramname">UserSelection</td><td>User selection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The popup box was successfully displayed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HiiHandle and Message do not define a valid HII string. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PopupType is not one of the values defined by this specification. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There are not enough resources available to display the popup box. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aced10be2c8aeb0a1f5fbe55879e3b524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiPeiGraphicsPpiGuid</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ee16cea0340e4558b8b17c3b12ae3d0b.html">MdePkg</a></li><li class="navelem"><a class="el" href="dir_43dbc6def9233b1fec759bd8d9ab8e67.html">Include</a></li><li class="navelem"><a class="el" href="dir_51f2417dcd5a0e61f471615fd8fdb9b8.html">Ppi</a></li><li class="navelem"><a class="el" href="_graphics_8h.html">Graphics.h</a></li>
    <li class="footer">Generated on Sun Dec 5 2021 03:51:06 for MdePkg[all] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
