<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MdePkg[all]: MdePkg/Include/Uefi/UefiBaseType.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MdePkg[all]
   &#160;<span id="projectnumber">1.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_uefi_base_type_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">UefiBaseType.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___m_a_c___a_d_d_r_e_s_s.html">EFI_MAC_ADDRESS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_e_f_i___i_p___a_d_d_r_e_s_s.html">EFI_IP_ADDRESS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae4575a8865019cd2a3065bb97eb08dbd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(_a)&#160;&#160;&#160;<a class="el" href="_base_8h.html#aded24a20d27f416cbf77c8fdb589a35f">ENCODE_ERROR</a>(_a)</td></tr>
<tr class="separator:ae4575a8865019cd2a3065bb97eb08dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170e88146954e1126b97a0ce22ec5d52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a170e88146954e1126b97a0ce22ec5d52">EFI_ERROR</a>(A)&#160;&#160;&#160;<a class="el" href="_base_8h.html#a2392c023633bef44fe57f69600e09f43">RETURN_ERROR</a>(A)</td></tr>
<tr class="separator:a170e88146954e1126b97a0ce22ec5d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d050384cfdc94809913cfdec9571e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a13d050384cfdc94809913cfdec9571e6">EFI_PAGE_SIZE</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a893d7f21ccd211aa54f16e4c259f04ff">SIZE_4KB</a></td></tr>
<tr class="separator:a13d050384cfdc94809913cfdec9571e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace83cb8fe7c059da5f93f59dc1a77a5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#ace83cb8fe7c059da5f93f59dc1a77a5b">EFI_PAGE_MASK</a>&#160;&#160;&#160;0xFFF</td></tr>
<tr class="separator:ace83cb8fe7c059da5f93f59dc1a77a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc02417bc3f15dd459be81b382242de0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#abc02417bc3f15dd459be81b382242de0">EFI_PAGE_SHIFT</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:abc02417bc3f15dd459be81b382242de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f57c818fb20c4fd8385eff35e3cdcf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#ae8f57c818fb20c4fd8385eff35e3cdcf">EFI_SIZE_TO_PAGES</a>(<a class="el" href="_erase_block_8h.html#a72bc0f4ec3949cb17265790875cbd0c4">Size</a>)&#160;&#160;&#160;(((<a class="el" href="_erase_block_8h.html#a72bc0f4ec3949cb17265790875cbd0c4">Size</a>) &gt;&gt; <a class="el" href="_uefi_base_type_8h.html#abc02417bc3f15dd459be81b382242de0">EFI_PAGE_SHIFT</a>) + (((<a class="el" href="_erase_block_8h.html#a72bc0f4ec3949cb17265790875cbd0c4">Size</a>) &amp; <a class="el" href="_uefi_base_type_8h.html#ace83cb8fe7c059da5f93f59dc1a77a5b">EFI_PAGE_MASK</a>) ? 1 : 0))</td></tr>
<tr class="separator:ae8f57c818fb20c4fd8385eff35e3cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f58af333da95514989b36c7a9ebb52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a44f58af333da95514989b36c7a9ebb52">EFI_PAGES_TO_SIZE</a>(<a class="el" href="_pi_pei_cis_8h.html#ac8b6ea5273cd31a4e83d009859537063">Pages</a>)&#160;&#160;&#160;((<a class="el" href="_pi_pei_cis_8h.html#ac8b6ea5273cd31a4e83d009859537063">Pages</a>) &lt;&lt; <a class="el" href="_uefi_base_type_8h.html#abc02417bc3f15dd459be81b382242de0">EFI_PAGE_SHIFT</a>)</td></tr>
<tr class="separator:a44f58af333da95514989b36c7a9ebb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e39adc4c4a1811ea266b92785c0e2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a55e39adc4c4a1811ea266b92785c0e2e">EFI_IMAGE_MACHINE_IA32</a>&#160;&#160;&#160;0x014C</td></tr>
<tr class="separator:a55e39adc4c4a1811ea266b92785c0e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85302cd36d44b568d46134764b6835e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a85302cd36d44b568d46134764b6835e1">EFI_IMAGE_MACHINE_IA64</a>&#160;&#160;&#160;0x0200</td></tr>
<tr class="separator:a85302cd36d44b568d46134764b6835e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53afa669670cd0e016de9c8f0a1ab2d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a53afa669670cd0e016de9c8f0a1ab2d5">EFI_IMAGE_MACHINE_EBC</a>&#160;&#160;&#160;0x0EBC</td></tr>
<tr class="separator:a53afa669670cd0e016de9c8f0a1ab2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dfa8a3d8b23ba3b20be0bf074d908b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a95dfa8a3d8b23ba3b20be0bf074d908b">EFI_IMAGE_MACHINE_X64</a>&#160;&#160;&#160;0x8664</td></tr>
<tr class="separator:a95dfa8a3d8b23ba3b20be0bf074d908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea11f1e4c576a2f054549dc40a147d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#aaea11f1e4c576a2f054549dc40a147d7">EFI_IMAGE_MACHINE_ARMTHUMB_MIXED</a>&#160;&#160;&#160;0x01C2</td></tr>
<tr class="separator:aaea11f1e4c576a2f054549dc40a147d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0afe0f12ebf8227567fd157d5ffc11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a0e0afe0f12ebf8227567fd157d5ffc11">EFI_IMAGE_MACHINE_AARCH64</a>&#160;&#160;&#160;0xAA64</td></tr>
<tr class="separator:a0e0afe0f12ebf8227567fd157d5ffc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfa1ad4cfa80e7347fa5c91f862421a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a8cfa1ad4cfa80e7347fa5c91f862421a">EFI_IMAGE_MACHINE_RISCV32</a>&#160;&#160;&#160;0x5032</td></tr>
<tr class="separator:a8cfa1ad4cfa80e7347fa5c91f862421a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e7ff8e9ddeb1eaa220830ccf754bea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a72e7ff8e9ddeb1eaa220830ccf754bea">EFI_IMAGE_MACHINE_RISCV64</a>&#160;&#160;&#160;0x5064</td></tr>
<tr class="separator:a72e7ff8e9ddeb1eaa220830ccf754bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb0d889a822787855220bf1b5fcf1af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a6bb0d889a822787855220bf1b5fcf1af">EFI_IMAGE_MACHINE_RISCV128</a>&#160;&#160;&#160;0x5128</td></tr>
<tr class="separator:a6bb0d889a822787855220bf1b5fcf1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61026a2e21c3fb11c6a3169a983e220c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a61026a2e21c3fb11c6a3169a983e220c">EFI_IMAGE_MACHINE_TYPE_SUPPORTED</a>(Machine)&#160;&#160;&#160;((Machine) == <a class="el" href="_uefi_base_type_8h.html#a55e39adc4c4a1811ea266b92785c0e2e">EFI_IMAGE_MACHINE_IA32</a>)</td></tr>
<tr class="separator:a61026a2e21c3fb11c6a3169a983e220c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f356b02a220bd310527aca3e35e7a49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a1f356b02a220bd310527aca3e35e7a49">EFI_IMAGE_MACHINE_CROSS_TYPE_SUPPORTED</a>(Machine)&#160;&#160;&#160;((Machine) == <a class="el" href="_uefi_base_type_8h.html#a95dfa8a3d8b23ba3b20be0bf074d908b">EFI_IMAGE_MACHINE_X64</a>)</td></tr>
<tr class="separator:a1f356b02a220bd310527aca3e35e7a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afd2956ea230ac571679e90c1f7fdcf7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#afd2956ea230ac571679e90c1f7fdcf7a">EFI_SUCCESS</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a9d37d43ac2717b06ef7120784465e56f">RETURN_SUCCESS</a></td></tr>
<tr class="separator:afd2956ea230ac571679e90c1f7fdcf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb42b1a02667e462bd28de378dde7ea2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#aeb42b1a02667e462bd28de378dde7ea2">EFI_LOAD_ERROR</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a0c88292089ea9ff5d6be59a5ff156c0a">RETURN_LOAD_ERROR</a></td></tr>
<tr class="separator:aeb42b1a02667e462bd28de378dde7ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517555b4ca97418f0943e5c437382b4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a517555b4ca97418f0943e5c437382b4c">EFI_INVALID_PARAMETER</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#aeeb1ff83e608d2dcfeeb583c49a2c5ea">RETURN_INVALID_PARAMETER</a></td></tr>
<tr class="separator:a517555b4ca97418f0943e5c437382b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f9e7f3e8414d8c0f37b696fa87e98b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a33f9e7f3e8414d8c0f37b696fa87e98b">EFI_UNSUPPORTED</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a4fb469b94f252b84d1d3b1fac1c2efe2">RETURN_UNSUPPORTED</a></td></tr>
<tr class="separator:a33f9e7f3e8414d8c0f37b696fa87e98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbb6c4bd47378c9ac82c8fa783f184f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a8dbb6c4bd47378c9ac82c8fa783f184f">EFI_BAD_BUFFER_SIZE</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#aef0ed1ea1be4e9e075667ed27803b712">RETURN_BAD_BUFFER_SIZE</a></td></tr>
<tr class="separator:a8dbb6c4bd47378c9ac82c8fa783f184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8e20dfdefffa2aefba608e7b30c701"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#ade8e20dfdefffa2aefba608e7b30c701">EFI_BUFFER_TOO_SMALL</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a0ef706a53eb7ac5d81c6ff33443adfda">RETURN_BUFFER_TOO_SMALL</a></td></tr>
<tr class="separator:ade8e20dfdefffa2aefba608e7b30c701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b217b264b88fe2990003ffce0c285d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a11b217b264b88fe2990003ffce0c285d">EFI_NOT_READY</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a28de6be3117b8611e81dc2388f983272">RETURN_NOT_READY</a></td></tr>
<tr class="separator:a11b217b264b88fe2990003ffce0c285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314604f35676ecd5675c4aed248e687a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a314604f35676ecd5675c4aed248e687a">EFI_DEVICE_ERROR</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a3f476b9accf29d98ee8e4661532c6621">RETURN_DEVICE_ERROR</a></td></tr>
<tr class="separator:a314604f35676ecd5675c4aed248e687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622887a68e58c72b1ceccbf007fc0922"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a622887a68e58c72b1ceccbf007fc0922">EFI_WRITE_PROTECTED</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a1488a50c1a087b9f04e94d637842311f">RETURN_WRITE_PROTECTED</a></td></tr>
<tr class="separator:a622887a68e58c72b1ceccbf007fc0922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf288f30572eb468a09ab95c76c00052"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#adf288f30572eb468a09ab95c76c00052">EFI_OUT_OF_RESOURCES</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a51df0ffd43dd9fee08a066c345d032a1">RETURN_OUT_OF_RESOURCES</a></td></tr>
<tr class="separator:adf288f30572eb468a09ab95c76c00052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799ac69ab99d97820d1ec5ed974aebe4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a799ac69ab99d97820d1ec5ed974aebe4">EFI_VOLUME_CORRUPTED</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#aad3d483af5ba4d02d5d73f43342b829f">RETURN_VOLUME_CORRUPTED</a></td></tr>
<tr class="separator:a799ac69ab99d97820d1ec5ed974aebe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a810abe290057c835d5022294cf555f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a2a810abe290057c835d5022294cf555f">EFI_VOLUME_FULL</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a5e50c595373a03116bf3bf61f1265f33">RETURN_VOLUME_FULL</a></td></tr>
<tr class="separator:a2a810abe290057c835d5022294cf555f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6834fec7bb4610c77aa5ec4551bb55e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a6834fec7bb4610c77aa5ec4551bb55e9">EFI_NO_MEDIA</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a0620b8f8155fb34462cdb4afb53add5a">RETURN_NO_MEDIA</a></td></tr>
<tr class="separator:a6834fec7bb4610c77aa5ec4551bb55e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4a2606302f7c468419f2985abd5b1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a0f4a2606302f7c468419f2985abd5b1c">EFI_MEDIA_CHANGED</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a1ddc6ade8137edccb73bdc79bfbe0e7f">RETURN_MEDIA_CHANGED</a></td></tr>
<tr class="separator:a0f4a2606302f7c468419f2985abd5b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d71dcd8a1666b9119271a011763bf79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a7d71dcd8a1666b9119271a011763bf79">EFI_NOT_FOUND</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a35ff45dff03ac67698cce11e17c46575">RETURN_NOT_FOUND</a></td></tr>
<tr class="separator:a7d71dcd8a1666b9119271a011763bf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac7291e56995be020d249c19cdf3af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a7aac7291e56995be020d249c19cdf3af">EFI_ACCESS_DENIED</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a48417588b2dbb0e95f1987d895732189">RETURN_ACCESS_DENIED</a></td></tr>
<tr class="separator:a7aac7291e56995be020d249c19cdf3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8ce4398d594d5944f4fa97c2ae3389"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a4d8ce4398d594d5944f4fa97c2ae3389">EFI_NO_RESPONSE</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a8206ff02636d2146148a69db32f107ab">RETURN_NO_RESPONSE</a></td></tr>
<tr class="separator:a4d8ce4398d594d5944f4fa97c2ae3389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6cc31078fe0bb82d562279a1409d9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a0e6cc31078fe0bb82d562279a1409d9f">EFI_NO_MAPPING</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a517cfbf7212898591120d27968fc8b73">RETURN_NO_MAPPING</a></td></tr>
<tr class="separator:a0e6cc31078fe0bb82d562279a1409d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a4ae73a61270c9cf93fce9b6963a8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#ad0a4ae73a61270c9cf93fce9b6963a8f">EFI_TIMEOUT</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#ab2c7e5f77fcca5e52861b30f36df54e3">RETURN_TIMEOUT</a></td></tr>
<tr class="separator:ad0a4ae73a61270c9cf93fce9b6963a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f338b4c2382d9daa5ce67fcf907d1af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a6f338b4c2382d9daa5ce67fcf907d1af">EFI_NOT_STARTED</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a34dbb98f960c6430df69b695aa37ee23">RETURN_NOT_STARTED</a></td></tr>
<tr class="separator:a6f338b4c2382d9daa5ce67fcf907d1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99611e3239b11262053173b4503c37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a4f99611e3239b11262053173b4503c37">EFI_ALREADY_STARTED</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#ab4196bec949612482178a4752f26e36e">RETURN_ALREADY_STARTED</a></td></tr>
<tr class="separator:a4f99611e3239b11262053173b4503c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b31df1ca1c127f99c5d53b6c6f5b5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#af7b31df1ca1c127f99c5d53b6c6f5b5b">EFI_ABORTED</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a28a7cd83d1be9f00ef5abb48309d52eb">RETURN_ABORTED</a></td></tr>
<tr class="separator:af7b31df1ca1c127f99c5d53b6c6f5b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe4bf1f52758504b3320a56e6c5b98b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a7fe4bf1f52758504b3320a56e6c5b98b">EFI_ICMP_ERROR</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#af5a9433008c4feea5bc4f3ef77ad9e5b">RETURN_ICMP_ERROR</a></td></tr>
<tr class="separator:a7fe4bf1f52758504b3320a56e6c5b98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaec3033b0a20d8fce48953a9943c42f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#acaec3033b0a20d8fce48953a9943c42f">EFI_TFTP_ERROR</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#abaa9b159de5eeebfbf53effca1b10c88">RETURN_TFTP_ERROR</a></td></tr>
<tr class="separator:acaec3033b0a20d8fce48953a9943c42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712a7f85cab36770c273f477b5a2e6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a6712a7f85cab36770c273f477b5a2e6b">EFI_PROTOCOL_ERROR</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a139458b80fb4d47c2b6b8c2a42acb36a">RETURN_PROTOCOL_ERROR</a></td></tr>
<tr class="separator:a6712a7f85cab36770c273f477b5a2e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa4c301cde7ac51c6aff6fe7b0b7e9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a4fa4c301cde7ac51c6aff6fe7b0b7e9c">EFI_INCOMPATIBLE_VERSION</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a8d290bddbf9af1a5270263c24f492c73">RETURN_INCOMPATIBLE_VERSION</a></td></tr>
<tr class="separator:a4fa4c301cde7ac51c6aff6fe7b0b7e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd7733d7f3a62ab5d4c088e02ce094a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a3cd7733d7f3a62ab5d4c088e02ce094a">EFI_SECURITY_VIOLATION</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a55745a0c30b4fa83edfc1c934f242bce">RETURN_SECURITY_VIOLATION</a></td></tr>
<tr class="separator:a3cd7733d7f3a62ab5d4c088e02ce094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e86bebe336d06823b8a51776ca6015d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a5e86bebe336d06823b8a51776ca6015d">EFI_CRC_ERROR</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#ade0fc8f9789253d847edf7e669a83a56">RETURN_CRC_ERROR</a></td></tr>
<tr class="separator:a5e86bebe336d06823b8a51776ca6015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db62a00c3723c515ecdb1dc2597f45"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#aa7db62a00c3723c515ecdb1dc2597f45">EFI_END_OF_MEDIA</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#af0bb74837d5e69806acfa4addbb95ed1">RETURN_END_OF_MEDIA</a></td></tr>
<tr class="separator:aa7db62a00c3723c515ecdb1dc2597f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eae5fda95bdb480cb36556fa0b5c5b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a7eae5fda95bdb480cb36556fa0b5c5b2">EFI_END_OF_FILE</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#af16f639a7f2638e0676e82f530d132dc">RETURN_END_OF_FILE</a></td></tr>
<tr class="separator:a7eae5fda95bdb480cb36556fa0b5c5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e4bbbdaf5cd44a546a936923bea399"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a54e4bbbdaf5cd44a546a936923bea399">EFI_INVALID_LANGUAGE</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a9459a5f64eedf90a5a28f2aa1288e7aa">RETURN_INVALID_LANGUAGE</a></td></tr>
<tr class="separator:a54e4bbbdaf5cd44a546a936923bea399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e9825d8c810f9358ab30f4574f2b0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#aa9e9825d8c810f9358ab30f4574f2b0b">EFI_COMPROMISED_DATA</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a12336b2815ea5bbb20cf9dddb721d816">RETURN_COMPROMISED_DATA</a></td></tr>
<tr class="separator:aa9e9825d8c810f9358ab30f4574f2b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fe42edf1e8e3089e20d490b0e41454"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a09fe42edf1e8e3089e20d490b0e41454">EFI_HTTP_ERROR</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#af16f0e84d6065b28006d6bc3f9b01a36">RETURN_HTTP_ERROR</a></td></tr>
<tr class="separator:a09fe42edf1e8e3089e20d490b0e41454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0a434fc76962dd5dd6049c24cd3583"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a0f0a434fc76962dd5dd6049c24cd3583">EFI_WARN_UNKNOWN_GLYPH</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#aae02058fe9dbb1892faad6ad7f85169d">RETURN_WARN_UNKNOWN_GLYPH</a></td></tr>
<tr class="separator:a0f0a434fc76962dd5dd6049c24cd3583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f690347b49eb8950b3bf50fe237ddb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#af8f690347b49eb8950b3bf50fe237ddb">EFI_WARN_DELETE_FAILURE</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a46c3357a4bbb87378910161b389cf0e8">RETURN_WARN_DELETE_FAILURE</a></td></tr>
<tr class="separator:af8f690347b49eb8950b3bf50fe237ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb9624fb5aa51a0a853cf24a7be5b4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#abcb9624fb5aa51a0a853cf24a7be5b4c">EFI_WARN_WRITE_FAILURE</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a62cc479511466c5a41b2ec4a170f27f4">RETURN_WARN_WRITE_FAILURE</a></td></tr>
<tr class="separator:abcb9624fb5aa51a0a853cf24a7be5b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3efd8e4fe29febce3beca557b70133a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#af3efd8e4fe29febce3beca557b70133a">EFI_WARN_BUFFER_TOO_SMALL</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#abf95aa0124e33905264a9226420bfcc0">RETURN_WARN_BUFFER_TOO_SMALL</a></td></tr>
<tr class="separator:af3efd8e4fe29febce3beca557b70133a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc766fd140934736b5433af092bdc6ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#adc766fd140934736b5433af092bdc6ae">EFI_WARN_STALE_DATA</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#ad7e0ddcd31f57266f3c5271da307f36e">RETURN_WARN_STALE_DATA</a></td></tr>
<tr class="separator:adc766fd140934736b5433af092bdc6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620cdc16c505c9afaf99b28c14d73bbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a620cdc16c505c9afaf99b28c14d73bbe">EFI_WARN_FILE_SYSTEM</a>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a36fa5929061747e3fea70147e34a06a5">RETURN_WARN_FILE_SYSTEM</a></td></tr>
<tr class="separator:a620cdc16c505c9afaf99b28c14d73bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaf4f3a7316e0f374c74d64361fde5412"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#aaf4f3a7316e0f374c74d64361fde5412">EFI_NETWORK_UNREACHABLE</a>&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(100)</td></tr>
<tr class="separator:aaf4f3a7316e0f374c74d64361fde5412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5713b79c8c1dfba3252aa7d25034112"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#ae5713b79c8c1dfba3252aa7d25034112">EFI_HOST_UNREACHABLE</a>&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(101)</td></tr>
<tr class="separator:ae5713b79c8c1dfba3252aa7d25034112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9ad9cefd25e7a2c3806377dbc0661b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a7d9ad9cefd25e7a2c3806377dbc0661b">EFI_PROTOCOL_UNREACHABLE</a>&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(102)</td></tr>
<tr class="separator:a7d9ad9cefd25e7a2c3806377dbc0661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254df45a966676593ed3d8c9f0675d05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a254df45a966676593ed3d8c9f0675d05">EFI_PORT_UNREACHABLE</a>&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(103)</td></tr>
<tr class="separator:a254df45a966676593ed3d8c9f0675d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a24acd46d6627bac0513cd22c20360f35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a24acd46d6627bac0513cd22c20360f35">EFI_CONNECTION_FIN</a>&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(104)</td></tr>
<tr class="separator:a24acd46d6627bac0513cd22c20360f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a45eb8659bd382763bb1b2d79d7df9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a4a45eb8659bd382763bb1b2d79d7df9d">EFI_CONNECTION_RESET</a>&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(105)</td></tr>
<tr class="separator:a4a45eb8659bd382763bb1b2d79d7df9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d4b500f6ca5ce4360b7f1a1568c971"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a18d4b500f6ca5ce4360b7f1a1568c971">EFI_CONNECTION_REFUSED</a>&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(106)</td></tr>
<tr class="separator:a18d4b500f6ca5ce4360b7f1a1568c971"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad87614428813f71edb2c2d802e9ce2af"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_g_u_i_d.html">GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a></td></tr>
<tr class="separator:ad87614428813f71edb2c2d802e9ce2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fe0c70f8531326ad565427ea96c1f4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_base_8h.html#ae30979abefc3ca8dc6f2135dc9cc40be">RETURN_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a></td></tr>
<tr class="separator:aa8fe0c70f8531326ad565427ea96c1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af943d518ce8a229e7e51ce3fed0e3122"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_shell_8h.html#aa8ff5bd3c2d6cb377b1dd3bbe3e0cfa8">VOID</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a></td></tr>
<tr class="separator:af943d518ce8a229e7e51ce3fed0e3122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3111de303d836d8d3711c39363f81a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_shell_8h.html#aa8ff5bd3c2d6cb377b1dd3bbe3e0cfa8">VOID</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a></td></tr>
<tr class="separator:a7f3111de303d836d8d3711c39363f81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab998e5f7da4a664eaa86252ab16e459a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a></td></tr>
<tr class="separator:ab998e5f7da4a664eaa86252ab16e459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3495b0e526b2172f98d5bde00bf28b72"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a></td></tr>
<tr class="separator:a3495b0e526b2172f98d5bde00bf28b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bc7e7faeab8d2940ee34f21d41cd04"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a></td></tr>
<tr class="separator:a31bc7e7faeab8d2940ee34f21d41cd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353ea2e3d6220a4e32c5f1eb39a1ed6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a353ea2e3d6220a4e32c5f1eb39a1ed6a">EFI_VIRTUAL_ADDRESS</a></td></tr>
<tr class="separator:a353ea2e3d6220a4e32c5f1eb39a1ed6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bb23c0a7f42c5d3d96436fd652cb0c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_i_pv4___a_d_d_r_e_s_s.html">IPv4_ADDRESS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#af4bb23c0a7f42c5d3d96436fd652cb0c">EFI_IPv4_ADDRESS</a></td></tr>
<tr class="separator:af4bb23c0a7f42c5d3d96436fd652cb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc920b25f29315e16fea42801730132"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_i_pv6___a_d_d_r_e_s_s.html">IPv6_ADDRESS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_base_type_8h.html#a3bc920b25f29315e16fea42801730132">EFI_IPv6_ADDRESS</a></td></tr>
<tr class="separator:a3bc920b25f29315e16fea42801730132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines data types and constants introduced in UEFI.</p>
<p>Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<br/>
 Portions copyright (c) 2011 - 2016, ARM Ltd. All rights reserved.<br/>
 Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<br/>
</p>
<p>SPDX-License-Identifier: BSD-2-Clause-Patent </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="af7b31df1ca1c127f99c5d53b6c6f5b5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_ABORTED&#160;&#160;&#160;<a class="el" href="_base_8h.html#a28a7cd83d1be9f00ef5abb48309d52eb">RETURN_ABORTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a7aac7291e56995be020d249c19cdf3af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_ACCESS_DENIED&#160;&#160;&#160;<a class="el" href="_base_8h.html#a48417588b2dbb0e95f1987d895732189">RETURN_ACCESS_DENIED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a4f99611e3239b11262053173b4503c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_ALREADY_STARTED&#160;&#160;&#160;<a class="el" href="_base_8h.html#ab4196bec949612482178a4752f26e36e">RETURN_ALREADY_STARTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a8dbb6c4bd47378c9ac82c8fa783f184f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_BAD_BUFFER_SIZE&#160;&#160;&#160;<a class="el" href="_base_8h.html#aef0ed1ea1be4e9e075667ed27803b712">RETURN_BAD_BUFFER_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="ade8e20dfdefffa2aefba608e7b30c701"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_BUFFER_TOO_SMALL&#160;&#160;&#160;<a class="el" href="_base_8h.html#a0ef706a53eb7ac5d81c6ff33443adfda">RETURN_BUFFER_TOO_SMALL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="aa9e9825d8c810f9358ab30f4574f2b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_COMPROMISED_DATA&#160;&#160;&#160;<a class="el" href="_base_8h.html#a12336b2815ea5bbb20cf9dddb721d816">RETURN_COMPROMISED_DATA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a24acd46d6627bac0513cd22c20360f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_CONNECTION_FIN&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(104)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tcp connection status definitions </p>

</div>
</div>
<a class="anchor" id="a18d4b500f6ca5ce4360b7f1a1568c971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_CONNECTION_REFUSED&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(106)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tcp connection status definitions </p>

</div>
</div>
<a class="anchor" id="a4a45eb8659bd382763bb1b2d79d7df9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_CONNECTION_RESET&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(105)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tcp connection status definitions </p>

</div>
</div>
<a class="anchor" id="a5e86bebe336d06823b8a51776ca6015d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_CRC_ERROR&#160;&#160;&#160;<a class="el" href="_base_8h.html#ade0fc8f9789253d847edf7e669a83a56">RETURN_CRC_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a314604f35676ecd5675c4aed248e687a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_DEVICE_ERROR&#160;&#160;&#160;<a class="el" href="_base_8h.html#a3f476b9accf29d98ee8e4661532c6621">RETURN_DEVICE_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a7eae5fda95bdb480cb36556fa0b5c5b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_END_OF_FILE&#160;&#160;&#160;<a class="el" href="_base_8h.html#af16f639a7f2638e0676e82f530d132dc">RETURN_END_OF_FILE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="aa7db62a00c3723c515ecdb1dc2597f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_END_OF_MEDIA&#160;&#160;&#160;<a class="el" href="_base_8h.html#af0bb74837d5e69806acfa4addbb95ed1">RETURN_END_OF_MEDIA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a170e88146954e1126b97a0ce22ec5d52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">A</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_base_8h.html#a2392c023633bef44fe57f69600e09f43">RETURN_ERROR</a>(A)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5713b79c8c1dfba3252aa7d25034112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_HOST_UNREACHABLE&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(101)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ICMP error definitions </p>

</div>
</div>
<a class="anchor" id="a09fe42edf1e8e3089e20d490b0e41454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_HTTP_ERROR&#160;&#160;&#160;<a class="el" href="_base_8h.html#af16f0e84d6065b28006d6bc3f9b01a36">RETURN_HTTP_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a7fe4bf1f52758504b3320a56e6c5b98b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_ICMP_ERROR&#160;&#160;&#160;<a class="el" href="_base_8h.html#af5a9433008c4feea5bc4f3ef77ad9e5b">RETURN_ICMP_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a0e0afe0f12ebf8227567fd157d5ffc11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_AARCH64&#160;&#160;&#160;0xAA64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PE32+ Machine type for AARCH64 A64 images. </p>

</div>
</div>
<a class="anchor" id="aaea11f1e4c576a2f054549dc40a147d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_ARMTHUMB_MIXED&#160;&#160;&#160;0x01C2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PE32+ Machine type for ARM mixed ARM and Thumb/Thumb2 images. </p>

</div>
</div>
<a class="anchor" id="a1f356b02a220bd310527aca3e35e7a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_CROSS_TYPE_SUPPORTED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Machine</td><td>)</td>
          <td>&#160;&#160;&#160;((Machine) == <a class="el" href="_uefi_base_type_8h.html#a95dfa8a3d8b23ba3b20be0bf074d908b">EFI_IMAGE_MACHINE_X64</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a53afa669670cd0e016de9c8f0a1ab2d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_EBC&#160;&#160;&#160;0x0EBC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PE32+ Machine type for EBC UEFI images. </p>

</div>
</div>
<a class="anchor" id="a55e39adc4c4a1811ea266b92785c0e2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_IA32&#160;&#160;&#160;0x014C</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PE32+ Machine type for IA32 UEFI images. </p>

</div>
</div>
<a class="anchor" id="a85302cd36d44b568d46134764b6835e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_IA64&#160;&#160;&#160;0x0200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PE32+ Machine type for IA64 UEFI images. </p>

</div>
</div>
<a class="anchor" id="a6bb0d889a822787855220bf1b5fcf1af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_RISCV128&#160;&#160;&#160;0x5128</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8cfa1ad4cfa80e7347fa5c91f862421a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_RISCV32&#160;&#160;&#160;0x5032</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PE32+ Machine type for RISC-V 32/64/128 </p>

</div>
</div>
<a class="anchor" id="a72e7ff8e9ddeb1eaa220830ccf754bea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_RISCV64&#160;&#160;&#160;0x5064</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a61026a2e21c3fb11c6a3169a983e220c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_TYPE_SUPPORTED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Machine</td><td>)</td>
          <td>&#160;&#160;&#160;((Machine) == <a class="el" href="_uefi_base_type_8h.html#a55e39adc4c4a1811ea266b92785c0e2e">EFI_IMAGE_MACHINE_IA32</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95dfa8a3d8b23ba3b20be0bf074d908b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_IMAGE_MACHINE_X64&#160;&#160;&#160;0x8664</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PE32+ Machine type for X64 UEFI images. </p>

</div>
</div>
<a class="anchor" id="a4fa4c301cde7ac51c6aff6fe7b0b7e9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_INCOMPATIBLE_VERSION&#160;&#160;&#160;<a class="el" href="_base_8h.html#a8d290bddbf9af1a5270263c24f492c73">RETURN_INCOMPATIBLE_VERSION</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a54e4bbbdaf5cd44a546a936923bea399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_INVALID_LANGUAGE&#160;&#160;&#160;<a class="el" href="_base_8h.html#a9459a5f64eedf90a5a28f2aa1288e7aa">RETURN_INVALID_LANGUAGE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a517555b4ca97418f0943e5c437382b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_INVALID_PARAMETER&#160;&#160;&#160;<a class="el" href="_base_8h.html#aeeb1ff83e608d2dcfeeb583c49a2c5ea">RETURN_INVALID_PARAMETER</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="aeb42b1a02667e462bd28de378dde7ea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_LOAD_ERROR&#160;&#160;&#160;<a class="el" href="_base_8h.html#a0c88292089ea9ff5d6be59a5ff156c0a">RETURN_LOAD_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a0f4a2606302f7c468419f2985abd5b1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_MEDIA_CHANGED&#160;&#160;&#160;<a class="el" href="_base_8h.html#a1ddc6ade8137edccb73bdc79bfbe0e7f">RETURN_MEDIA_CHANGED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="aaf4f3a7316e0f374c74d64361fde5412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_NETWORK_UNREACHABLE&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(100)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ICMP error definitions </p>

</div>
</div>
<a class="anchor" id="a0e6cc31078fe0bb82d562279a1409d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_NO_MAPPING&#160;&#160;&#160;<a class="el" href="_base_8h.html#a517cfbf7212898591120d27968fc8b73">RETURN_NO_MAPPING</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a6834fec7bb4610c77aa5ec4551bb55e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_NO_MEDIA&#160;&#160;&#160;<a class="el" href="_base_8h.html#a0620b8f8155fb34462cdb4afb53add5a">RETURN_NO_MEDIA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a4d8ce4398d594d5944f4fa97c2ae3389"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_NO_RESPONSE&#160;&#160;&#160;<a class="el" href="_base_8h.html#a8206ff02636d2146148a69db32f107ab">RETURN_NO_RESPONSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a7d71dcd8a1666b9119271a011763bf79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_NOT_FOUND&#160;&#160;&#160;<a class="el" href="_base_8h.html#a35ff45dff03ac67698cce11e17c46575">RETURN_NOT_FOUND</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a11b217b264b88fe2990003ffce0c285d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_NOT_READY&#160;&#160;&#160;<a class="el" href="_base_8h.html#a28de6be3117b8611e81dc2388f983272">RETURN_NOT_READY</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a6f338b4c2382d9daa5ce67fcf907d1af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_NOT_STARTED&#160;&#160;&#160;<a class="el" href="_base_8h.html#a34dbb98f960c6430df69b695aa37ee23">RETURN_NOT_STARTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="adf288f30572eb468a09ab95c76c00052"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_OUT_OF_RESOURCES&#160;&#160;&#160;<a class="el" href="_base_8h.html#a51df0ffd43dd9fee08a066c345d032a1">RETURN_OUT_OF_RESOURCES</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="ace83cb8fe7c059da5f93f59dc1a77a5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PAGE_MASK&#160;&#160;&#160;0xFFF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc02417bc3f15dd459be81b382242de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PAGE_SHIFT&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a13d050384cfdc94809913cfdec9571e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PAGE_SIZE&#160;&#160;&#160;<a class="el" href="_base_8h.html#a893d7f21ccd211aa54f16e4c259f04ff">SIZE_4KB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a44f58af333da95514989b36c7a9ebb52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PAGES_TO_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="_pi_pei_cis_8h.html#ac8b6ea5273cd31a4e83d009859537063">Pages</a></td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="_pi_pei_cis_8h.html#ac8b6ea5273cd31a4e83d009859537063">Pages</a>) &lt;&lt; <a class="el" href="_uefi_base_type_8h.html#abc02417bc3f15dd459be81b382242de0">EFI_PAGE_SHIFT</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro that converts a number of EFI_PAGEs to a size in bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pages</td><td>The number of EFI_PAGES. This parameter is assumed to be type UINTN. Passing in a parameter that is larger than UINTN may produce unexpected results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes associated with the number of EFI_PAGEs specified by Pages. </dd></dl>

</div>
</div>
<a class="anchor" id="a254df45a966676593ed3d8c9f0675d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PORT_UNREACHABLE&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(103)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ICMP error definitions </p>

</div>
</div>
<a class="anchor" id="a6712a7f85cab36770c273f477b5a2e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PROTOCOL_ERROR&#160;&#160;&#160;<a class="el" href="_base_8h.html#a139458b80fb4d47c2b6b8c2a42acb36a">RETURN_PROTOCOL_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a7d9ad9cefd25e7a2c3806377dbc0661b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_PROTOCOL_UNREACHABLE&#160;&#160;&#160;<a class="el" href="_uefi_base_type_8h.html#ae4575a8865019cd2a3065bb97eb08dbd">EFIERR</a>(102)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ICMP error definitions </p>

</div>
</div>
<a class="anchor" id="a3cd7733d7f3a62ab5d4c088e02ce094a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_SECURITY_VIOLATION&#160;&#160;&#160;<a class="el" href="_base_8h.html#a55745a0c30b4fa83edfc1c934f242bce">RETURN_SECURITY_VIOLATION</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="ae8f57c818fb20c4fd8385eff35e3cdcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_SIZE_TO_PAGES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="_erase_block_8h.html#a72bc0f4ec3949cb17265790875cbd0c4">Size</a></td><td>)</td>
          <td>&#160;&#160;&#160;(((<a class="el" href="_erase_block_8h.html#a72bc0f4ec3949cb17265790875cbd0c4">Size</a>) &gt;&gt; <a class="el" href="_uefi_base_type_8h.html#abc02417bc3f15dd459be81b382242de0">EFI_PAGE_SHIFT</a>) + (((<a class="el" href="_erase_block_8h.html#a72bc0f4ec3949cb17265790875cbd0c4">Size</a>) &amp; <a class="el" href="_uefi_base_type_8h.html#ace83cb8fe7c059da5f93f59dc1a77a5b">EFI_PAGE_MASK</a>) ? 1 : 0))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro that converts a size, in bytes, to a number of EFI_PAGESs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Size</td><td>A size in bytes. This parameter is assumed to be type UINTN. Passing in a parameter that is larger than UINTN may produce unexpected results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of EFI_PAGESs associated with the number of bytes specified by Size. </dd></dl>

</div>
</div>
<a class="anchor" id="afd2956ea230ac571679e90c1f7fdcf7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_SUCCESS&#160;&#160;&#160;<a class="el" href="_base_8h.html#a9d37d43ac2717b06ef7120784465e56f">RETURN_SUCCESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="acaec3033b0a20d8fce48953a9943c42f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_TFTP_ERROR&#160;&#160;&#160;<a class="el" href="_base_8h.html#abaa9b159de5eeebfbf53effca1b10c88">RETURN_TFTP_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="ad0a4ae73a61270c9cf93fce9b6963a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_TIMEOUT&#160;&#160;&#160;<a class="el" href="_base_8h.html#ab2c7e5f77fcca5e52861b30f36df54e3">RETURN_TIMEOUT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a33f9e7f3e8414d8c0f37b696fa87e98b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_UNSUPPORTED&#160;&#160;&#160;<a class="el" href="_base_8h.html#a4fb469b94f252b84d1d3b1fac1c2efe2">RETURN_UNSUPPORTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a799ac69ab99d97820d1ec5ed974aebe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_VOLUME_CORRUPTED&#160;&#160;&#160;<a class="el" href="_base_8h.html#aad3d483af5ba4d02d5d73f43342b829f">RETURN_VOLUME_CORRUPTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a2a810abe290057c835d5022294cf555f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_VOLUME_FULL&#160;&#160;&#160;<a class="el" href="_base_8h.html#a5e50c595373a03116bf3bf61f1265f33">RETURN_VOLUME_FULL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="af3efd8e4fe29febce3beca557b70133a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_WARN_BUFFER_TOO_SMALL&#160;&#160;&#160;<a class="el" href="_base_8h.html#abf95aa0124e33905264a9226420bfcc0">RETURN_WARN_BUFFER_TOO_SMALL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="af8f690347b49eb8950b3bf50fe237ddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_WARN_DELETE_FAILURE&#160;&#160;&#160;<a class="el" href="_base_8h.html#a46c3357a4bbb87378910161b389cf0e8">RETURN_WARN_DELETE_FAILURE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a620cdc16c505c9afaf99b28c14d73bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_WARN_FILE_SYSTEM&#160;&#160;&#160;<a class="el" href="_base_8h.html#a36fa5929061747e3fea70147e34a06a5">RETURN_WARN_FILE_SYSTEM</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="adc766fd140934736b5433af092bdc6ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_WARN_STALE_DATA&#160;&#160;&#160;<a class="el" href="_base_8h.html#ad7e0ddcd31f57266f3c5271da307f36e">RETURN_WARN_STALE_DATA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a0f0a434fc76962dd5dd6049c24cd3583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_WARN_UNKNOWN_GLYPH&#160;&#160;&#160;<a class="el" href="_base_8h.html#aae02058fe9dbb1892faad6ad7f85169d">RETURN_WARN_UNKNOWN_GLYPH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="abcb9624fb5aa51a0a853cf24a7be5b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_WARN_WRITE_FAILURE&#160;&#160;&#160;<a class="el" href="_base_8h.html#a62cc479511466c5a41b2ec4a170f27f4">RETURN_WARN_WRITE_FAILURE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="a622887a68e58c72b1ceccbf007fc0922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_WRITE_PROTECTED&#160;&#160;&#160;<a class="el" href="_base_8h.html#a1488a50c1a087b9f04e94d637842311f">RETURN_WRITE_PROTECTED</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI_STATUS. </p>

</div>
</div>
<a class="anchor" id="ae4575a8865019cd2a3065bb97eb08dbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFIERR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_a</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_base_8h.html#aded24a20d27f416cbf77c8fdb589a35f">ENCODE_ERROR</a>(_a)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define macro to encode the status code. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a7f3111de303d836d8d3711c39363f81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_shell_8h.html#aa8ff5bd3c2d6cb377b1dd3bbe3e0cfa8">VOID</a>* <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle to an event structure. </p>

</div>
</div>
<a class="anchor" id="ad87614428813f71edb2c2d802e9ce2af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_g_u_i_d.html">GUID</a> <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>128-bit buffer containing a unique identifier value. </p>

</div>
</div>
<a class="anchor" id="af943d518ce8a229e7e51ce3fed0e3122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_shell_8h.html#aa8ff5bd3c2d6cb377b1dd3bbe3e0cfa8">VOID</a>* <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collection of related interfaces. </p>

</div>
</div>
<a class="anchor" id="af4bb23c0a7f42c5d3d96436fd652cb0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_i_pv4___a_d_d_r_e_s_s.html">IPv4_ADDRESS</a> <a class="el" href="_uefi_base_type_8h.html#af4bb23c0a7f42c5d3d96436fd652cb0c">EFI_IPv4_ADDRESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>4-byte buffer. An IPv4 internet protocol address. </p>

</div>
</div>
<a class="anchor" id="a3bc920b25f29315e16fea42801730132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_i_pv6___a_d_d_r_e_s_s.html">IPv6_ADDRESS</a> <a class="el" href="_uefi_base_type_8h.html#a3bc920b25f29315e16fea42801730132">EFI_IPv6_ADDRESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>16-byte buffer. An IPv6 internet protocol address. </p>

</div>
</div>
<a class="anchor" id="a3495b0e526b2172f98d5bde00bf28b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> <a class="el" href="_uefi_base_type_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical block address. </p>

</div>
</div>
<a class="anchor" id="a31bc7e7faeab8d2940ee34f21d41cd04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>64-bit physical memory address. </p>

</div>
</div>
<a class="anchor" id="aa8fe0c70f8531326ad565427ea96c1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function return status for EFI API.</p>
<p>Retrieve additional information associated with a PCD token.</p>
<p>This includes information such as the type of value the TokenNumber is associated with as well as possible human readable name that is associated with the token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Guid</td><td>The 128-bit unique value that designates the namespace from which to extract the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TokenNumber</td><td>The PCD token number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PcdInfo</td><td>The returned information associated with the requested TokenNumber.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The PCD information was returned successfully </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The PCD service could not find the requested token number.</td></tr>
  </table>
  </dd>
</dl>
<p>Close I/O aperture.</p>
<p>This function closes a previously opened I/O aperture handle. If there are no more I/O aperture handles that refer to the hardware I/O aperture resource, then the hardware I/O aperture is closed. It may be possible that a single hardware aperture may be used for more than one device. This function tracks the number of times that each aperture is referenced, and does not close the hardware aperture (via CloseIoAperture()) until there are no more references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to this instance of the EFI_ISA_HC_PPI. </td></tr>
    <tr><td class="paramname">IoApertureHandle</td><td>The I/O aperture handle previously returned from a call to OpenIoAperture().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The I/O aperture was closed successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>The GraphicsPpiGetMode returns the mode information supported by the Graphics PEI Module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Mode</td><td>Pointer to <a class="el" href="struct_e_f_i___g_r_a_p_h_i_c_s___o_u_t_p_u_t___p_r_o_t_o_c_o_l___m_o_d_e.html">EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE</a> data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Valid mode information was returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The Mode parameter is not valid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A hardware error occurred trying to retrieve the video mode. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The Graphics Initialization is not competed and Mode information is not yet available.The platform code should call this again after the Graphics initialization is done.</td></tr>
  </table>
  </dd>
</dl>
<p>Clears any system state that was created in response to the Trigger() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PeiServices</td><td>General purpose services available to every PEIM. </td></tr>
    <tr><td class="paramname">This</td><td>The PEI_MM_CONTROL_PPI instance. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Optional parameter to repeat at this period one time or, if the Periodic Boolean is set, periodically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The MMI has been engendered. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The source could not be cleared. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The service did not support the Periodic input argument.</td></tr>
  </table>
  </dd>
</dl>
<p>Get information on a specific CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to this instance of the PPI. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>Pointer to the total number of logical processors in the system, including the BSP and disabled APs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ProcessorInfoBuffer</td><td>Number of processors in the system that are enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Processor information was returned. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorInfoBuffer is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist in the platform.</td></tr>
  </table>
  </dd>
</dl>
<p>Activate all of the application processors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on enabled APs of the system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SingleThread</td><td>If TRUE, then all the enabled APs execute the function specified by Procedure one by one, in ascending order of processor handle number. If FALSE, then all the enabled APs execute the function specified by Procedure simultaneously. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroSeconds</td><td>Indicates the time limit in microseconds for APs to return from Procedure, for blocking mode only. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. All enabled APs are available for next function assigned by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a5bf59487d69fe6aab87af0df6f7f2799">EFI_PEI_MP_SERVICES_PPI.StartupAllAPs()</a> or <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#aa34a5103be897862c002624b21ed3b33">EFI_PEI_MP_SERVICES_PPI.StartupThisAP()</a>. If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure for all APs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, all APs have finished before the timeout expired. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Caller processor is AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>No enabled APs exist in the system. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Any enabled APs are busy. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before all enabled APs have finished. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Activate a specific application processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on enabled APs of the system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a6bf539700302f5e11cf2e4b14b61bb7b">EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroSeconds</td><td>Indicates the time limit in microseconds for APs to return from Procedure, for blocking mode only. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. All enabled APs are available for next function assigned by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a5bf59487d69fe6aab87af0df6f7f2799">EFI_PEI_MP_SERVICES_PPI.StartupAllAPs()</a> or <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#aa34a5103be897862c002624b21ed3b33">EFI_PEI_MP_SERVICES_PPI.StartupThisAP()</a>. If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure for all APs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, specified AP finished before the timeout expires. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before the specified AP has finished. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the BSP or disabled AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Switch the boot strap processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a6bf539700302f5e11cf2e4b14b61bb7b">EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EnableOldBSP</td><td>If TRUE, then the old BSP will be listed as an enabled AP. Otherwise, it will be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>BSP successfully switched. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP is not supported. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the current BSP or a disabled AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The specified AP is busy.</td></tr>
  </table>
  </dd>
</dl>
<p>Enable or disable an application processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a6bf539700302f5e11cf2e4b14b61bb7b">EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EnableAP</td><td>Specifies the new state for the processor for enabled, FALSE for disabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HealthFlag</td><td>If not NULL, a pointer to a value that specifies the new health status of the AP. This flag corresponds to StatusFlag defined in <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a78f9140fb5a013111ea0fbc4420257cc">EFI_PEI_MP_SERVICES_PPI.GetProcessorInfo()</a>. Only the PROCESSOR_HEALTH_STATUS_BIT is used. All other bits are ignored. If it is NULL, this parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified AP was enabled or disabled successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Enabling or disabling an AP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Enabling or disabling an AP is not supported. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the BSP.</td></tr>
  </table>
  </dd>
</dl>
<p>Identify the currently executing processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PeiServices</td><td>An indirect pointer to the PEI Services Table published by the PEI Foundation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct___e_f_i___p_e_i___m_p___s_e_r_v_i_c_e_s___p_p_i.html#a6bf539700302f5e11cf2e4b14b61bb7b">EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The current processor handle number was returned in ProcessorNumber. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Reset the I2C controller and configure it for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to an EFI_PEI_I2C_MASTER_PPI structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The reset completed successfully. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The reset operation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>Start an I2C transaction on the host controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to an EFI_PEI_I2C_MASTER_PPI structure. </td></tr>
    <tr><td class="paramname">SlaveAddress</td><td>Address of the device on the I2C bus. Set the I2C_ADDRESSING_10_BIT when using 10-bit addresses, clear this bit for 7-bit addressing. Bits 0-6 are used for 7-bit I2C slave addresses and bits 0-9 are used for 10-bit I2C slave addresses. </td></tr>
    <tr><td class="paramname">RequestPacket</td><td>Pointer to an <a class="el" href="struct_e_f_i___i2_c___r_e_q_u_e_s_t___p_a_c_k_e_t.html">EFI_I2C_REQUEST_PACKET</a> structure describing the I2C transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The transaction completed successfully. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The RequestPacket-&gt;LengthInBytes value is too large. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>There was an I2C error (NACK) during the transaction. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RequestPacket is NULL </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>The I2C device is not responding to the slave address. EFI_DEVICE_ERROR will be returned if the controller cannot distinguish when the NACK occurred. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Reserved bit set in the SlaveAddress parameter </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory for I2C transaction </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The controller does not support the requested transaction.</td></tr>
  </table>
  </dd>
</dl>
<p>This function establish a connection with a Smart Card the protocol support.</p>
<p>In case of success the SCardHandle can be used.</p>
<p>If the ScardCsn is NULL the connection is established with the first Smart Card the protocol finds in its table of Smart Card present and supported. Else it establish context with the Smart Card whose CSN given by ScardCsn.</p>
<p>If ScardAid is not NULL the function returns the Smart Card AID the protocol supports. After a successful connect the SCardHandle will remain existing even in case Smart Card removed from Smart Card reader, but all function invoking this SCardHandle will fail. SCardHandle is released only on Disconnect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScardCsn</td><td>CSN of the Smart Card the connection has to be established. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ScardAid</td><td>AID of the Smart Card the connection has been established.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SCardHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>No Smart Card supported by protocol is present, Smart Card with CSN ScardCsn or Reader has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function releases a connection previously established by Connect.</p>
<p>The Disconnect function releases the connection previously established by a Connect. In case the Smart Card or the Smart Card reader has been removed before this call, this function returns EFI_SUCCESS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Smart Card serial number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Csn</td><td>The Card Serial number, 16 bytes array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the name of the Smart Card reader used for this connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ReaderNameLength</td><td>On input, a pointer to the variable that holds the maximal size, in bytes, of ReaderName. On output, the required size, in bytes, for ReaderName. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReaderName</td><td>A pointer to a NULL terminated string that will contain the reader name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ReaderNameLength is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function authenticates a Smart Card user by presenting a PIN code.</p>
<p>The VerifyPinfunction presents a PIN code to the Smart Card.</p>
<p>If Smart Card found the PIN code correct the user is considered authenticated to current application, and the function returns TRUE.</p>
<p>Negative or null PinSize value rejected if PinCodeis not NULL.</p>
<p>A NULL PinCodebuffer means the application didn't know the PIN, in that case:</p>
<ul>
<li>If PinSize value is negative the caller only wants to know if the current chain of the elements Smart Card Edge protocol, Smart Card Reader protocol and Smart Card Reader supports the Secure Pin Entry PCSC V2 functionality.</li>
<li>If PinSize value is positive or null the caller ask to perform the verify PIN using the Secure PIN Entry functionality.</li>
</ul>
<p>In PinCode buffer, the PIN value is always given in plaintext, in case of secure messaging the SMART_CARD_EDGE_PROTOCOL will be in charge of all intermediate treatments to build the correct Smart Card APDU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PinSize</td><td>PIN code buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PinCode</td><td>PIN code to present to the Smart Card. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PinResult</td><td>Result of PIN code presentation to the Smart Card. TRUE when Smard Card founds the PIN code correct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RemainingAttempts</td><td>Number of attempts still possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Pinsize &lt; 0 and Secure PIN Entry functionality not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Bad value for PinSize: value not supported by Smart Card or, negative with PinCode not null. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PinResult is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gives the remaining number of attempts for PIN code presentation.</p>
<p>The number of attempts to present a correct PIN is limited and depends on Smart Card and on PIN.</p>
<p>This function will retrieve the number of remaining possible attempts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RemainingAttempts</td><td>Number of attempts still possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RemainingAttempts is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a specific data from Smart Card.</p>
<p>The function is generic for any kind of data, but driver and application must share an EFI_GUID that identify the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataId</td><td>The type identifier of the data to get. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>On input, in bytes, the size of Data. On output, in bytes, the size of buffer required to store the specified data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Data</td><td>The data buffer in which the data is returned. The type of the data buffer is associated with the DataId. Ignored if *DataSize is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DataId is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DataSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Data is NULL, and *DataSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>DataId unknown for this driver. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of Data is too small for the specified data and the required size is returned in DataSize. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Operation not performed, conditions not fulfilled. PIN not verified. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieve credentials store into the Smart Card.</p>
<p>The function returns a series of items in TLV (Tag Length Value) format.</p>
<p>First TLV item is the header item that gives the number of following containers (0x00, 0x01, Nb containers).</p>
<p>All these containers are a series of 4 TLV items:</p>
<ul>
<li>The certificate item (0x01, certificate size, certificate)</li>
<li>The Key identifier item (0x02, 0x01, key index)</li>
<li>The key type item (0x03, 0x01, key type)</li>
<li>The key size item (0x04, 0x02, key size), key size in number of bits. Numeric multi-bytes values are on big endian format, most significant byte first:</li>
<li>The L field value for certificate (2 bytes)</li>
<li>The L field value for key size (2 bytes)</li>
<li>The value field for key size (2 bytes)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CredentialSize</td><td>On input, in bytes, the size of buffer to store the list of credential. On output, in bytes, the size of buffer required to store the entire list of credentials.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CredentialList</td><td>List of credentials stored into the Smart Card. A list of TLV (Tag Length Value) elements organized in containers array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CredentialSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CredentialList is NULL, if CredentialSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of CredentialList is too small for the specified data and the required size is returned in CredentialSize. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function signs an already hashed data with a Smart Card private key.</p>
<p>This function signs data, actually it is the hash of these data that is given to the function.</p>
<p>SignatureData buffer shall be big enough for signature. Signature size is function key size and key type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyId</td><td>Identifier of the key container, retrieved in a key index item of credentials. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyType</td><td>The key type, retrieved in a key type item of credentials.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HashAlgorithm</td><td>Hash algorithm used to hash the, one of:<ul>
<li>EFI_HASH_ALGORITHM_SHA1_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA256_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA384_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA512_GUID </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PaddingMethod</td><td>Padding method used jointly with hash algorithm, one of:<ul>
<li>EFI_PADDING_RSASSA_PKCS1V1P5_GUID</li>
<li>EFI_PADDING_RSASSA_PSS_GUID </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HashedData</td><td>Hash of the data to sign. Size is function of the HashAlgorithm.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SignatureData</td><td>Resulting signature with private key KeyId. Size is function of the KeyType and key size retrieved in the associated key size item of credentials.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyId is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyType is not valid or not corresponding to KeyId. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashAlgorithm is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashAlgorithm is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PaddingMethod is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PaddingMethod is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashedData is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SignatureData is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Operation not performed, conditions not fulfilled. PIN not verified. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function decrypts data with a PKI/RSA Smart Card private key.</p>
<p>The function decrypts some PKI/RSA encrypted data with private key securely stored into the Smart Card.</p>
<p>The KeyId must reference a key of type SC_EDGE_RSA_EXCHANGE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyId</td><td>Identifier of the key container, retrieved in a key index item of credentials. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HashAlgorithm</td><td>Hash algorithm used to hash the, one of:<ul>
<li>EFI_HASH_ALGORITHM_SHA1_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA256_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA384_GUID</li>
<li>EFI_HASH_ALGORITHM_SHA512_GUID </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PaddingMethod</td><td>Padding method used jointly with hash algorithm, one of:<ul>
<li>EFI_PADDING_NONE_GUID</li>
<li>EFI_PADDING_RSAES_PKCS1V1P5_GUID</li>
<li>EFI_PADDING_RSAES_OAEP_GUID </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EncryptedSize</td><td>Size of data to decrypt. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EncryptedData</td><td>Data to decrypt </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PlaintextSize</td><td>On input, in bytes, the size of buffer to store the decrypted data. On output, in bytes, the size of buffer required to store the decrypted data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PlaintextData</td><td>Buffer for decrypted data, padding removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyId is not valid or associated key not of type SC_EDGE_RSA_EXCHANGE. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashAlgorithm is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HashAlgorithm is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PaddingMethod is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PaddingMethod is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>EncryptedSize is 0. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>EncryptedData is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PlaintextSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PlaintextData is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Operation not performed, conditions not fulfilled. PIN not verified. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>PlaintextSize is too small for the plaintext data and the required size is returned in PlaintextSize. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a secret Diffie Hellman agreement calculation that would be used to derive a symmetric encryption / decryption key.</p>
<p>The function compute a DH agreement that should be diversified togenerate a symmetric key to proceed encryption or decryption.</p>
<p>The application and the Smart Card shall agree on the diversification process.</p>
<p>The KeyId must reference a key of one of the types: SC_EDGE_ECDH_256, SC_EDGE_ECDH_384 or SC_EDGE_ECDH_521.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCardHandle</td><td>Handle on Smart Card connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyId</td><td>Identifier of the key container, retrieved in a key index item of credentials. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataQx</td><td>Public key x coordinate. Size is the same as key size for KeyId. Stored in big endian format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataQy</td><td>Public key y coordinate. Size is the same as key size for KeyId. Stored in big endian format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DHAgreement</td><td>Buffer for DH agreement computed. Size must be bigger or equal to key size for KeyId.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>No connection for SCardHandle value. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>KeyId is not valid. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>dataQx is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>dataQy is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DHAgreement is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Operation not performed, conditions not fulfilled. PIN not verified. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>Smart Card or Reader of SCardHandle connection has been removed. A Disconnect should be performed.</td></tr>
  </table>
  </dd>
</dl>
<p>The GetServiceTime() function is an optional interface to obtain the current time from this REST service instance. If this REST service does not support retrieving the time, this function returns EFI_UNSUPPORTED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_REST_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Time</td><td>A pointer to storage to receive a snapshot of the current time of the REST service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation succeeded </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This or Time are NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The RESTful service does not support returning the time. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred.</td></tr>
  </table>
  </dd>
</dl>
<p>ProcessPacket() is called to Supplicant driver to encrypt or decrypt the data depending type of authentication type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_SUPPLICANT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FragmentTable</td><td>Pointer to a list of fragment. The caller will take responsible to handle the original FragmentTable while it may be reallocated in Supplicant driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FragmentCount</td><td>Number of fragment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CryptMode</td><td>Crypt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: FragmentTable is NULL. FragmentCount is NULL. CryptMode is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Current supplicant state is NOT Authenticated. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Something wrong decryption the message. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This API is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>Set Supplicant configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_SUPPLICANT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Pointer to the buffer to hold the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Pointer to the buffer size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The Supplicant configuration data is set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: Data is NULL. DataSize is 0. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Get Supplicant configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_SUPPLICANT_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Data</td><td>Pointer to the buffer to hold the data. Ignored if DataSize is 0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>Pointer to the buffer size in bytes. On input, it is the buffer size provided by the caller. On output, it is the buffer size in fact needed to contain the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The Supplicant configuration data is got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. DataSize is NULL. Data is NULL if *DataSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The Supplicant configuration data is not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of Data is too small for the specified configuration data and the required size is returned in DataSize.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the label data for the requested offset and length from within the Label Storage Area for the NVDIMM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_NVDIMM_LABEL_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">Offset</td><td>The byte offset within the Label Storage Area to read from. </td></tr>
    <tr><td class="paramname">TransferLength</td><td>Number of bytes to read from the Label Storage Area beginning at the byte Offset specified. A TransferLength of 0 reads no data. </td></tr>
    <tr><td class="paramname">LabelData</td><td>The return label data read at the requested offset and length from within the Label Storage Area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The label data from the Label Storage Area for the NVDIMM was read successfully at the specified Offset and TransferLength and LabelData contains valid data. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Any of the following are true:<ul>
<li>Offset &gt; SizeOfLabelStorageArea reported in the LabelStorageInformation return data.</li>
<li>Offset + TransferLength is &gt; SizeOfLabelStorageArea reported in the LabelStorageInformation return data.</li>
<li>TransferLength is &gt; MaxTransferLength reported in the LabelStorageInformation return data. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The Label Storage Area for the NVDIMM device is not currently accessible and labels cannot be read at this time. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A physical device error occurred and the data transfer failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the label data for the requested offset and length in to the Label Storage Area for the NVDIMM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_NVDIMM_LABEL_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">Offset</td><td>The byte offset within the Label Storage Area to write to. </td></tr>
    <tr><td class="paramname">TransferLength</td><td>Number of bytes to write to the Label Storage Area beginning at the byte Offset specified. A TransferLength of 0 writes no data. </td></tr>
    <tr><td class="paramname">LabelData</td><td>The return label data write at the requested offset and length from within the Label Storage Area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The label data from the Label Storage Area for the NVDIMM written read successfully at the specified Offset and TransferLength. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Any of the following are true:<ul>
<li>Offset &gt; SizeOfLabelStorageArea reported in the LabelStorageInformation return data.</li>
<li>Offset + TransferLength is &gt; SizeOfLabelStorageArea reported in the LabelStorageInformation return data.</li>
<li>TransferLength is &gt; MaxTransferLength reported in the LabelStorageInformation return data. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The Label Storage Area for the NVDIMM device is not currently accessible and labels cannot be written at this time. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>A physical device error occurred and the data transfer failed to complete.</td></tr>
  </table>
  </dd>
</dl>
<p>Unregister a RAM disk specified by DevicePath.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DevicePath</td><td>A pointer to the device path that describes a RAM Disk device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The RAM disk is unregistered successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The device specified by DevicePath is not a valid ramdisk device path and not supported by the driver. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The RAM disk pointed by DevicePath doesn't exist.</td></tr>
  </table>
  </dd>
</dl>
<p>Set up the clock generator to produce the correct clock frequency, phase and polarity for a SPI chip.</p>
<p>This routine is called at TPL_NOTIFY. This routine updates the clock generator to generate the correct frequency and polarity for the SPI clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_HC_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SpiPeripheral</td><td>Pointer to a EFI_SPI_PERIPHERAL data structure from which the routine can access the ClockParameter, ClockPhase and ClockPolarity fields. The routine also has access to the names for the SPI bus and chip which can be used during debugging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ClockHz</td><td>Pointer to the requested clock frequency. The SPI host controller will choose a supported clock frequency which is less then or equal to this value. Specify zero to turn the clock generator off. The actual clock frequency supported by the SPI host controller will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The clock was set up successfully </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The SPI controller was not able to support the frequency requested by ClockHz</td></tr>
  </table>
  </dd>
</dl>
<p>Perform the SPI transaction on the SPI peripheral using the SPI host controller.</p>
<p>This routine is called at TPL_NOTIFY. This routine synchronously returns EFI_SUCCESS indicating that the asynchronous SPI transaction was started. The routine then waits for completion of the SPI transaction prior to returning the final transaction status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_HC_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BusTransaction</td><td>Pointer to a EFI_SPI_BUS_ TRANSACTION containing the description of the SPI transaction to perform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The transaction completed successfully </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The BusTransaction-&gt;WriteBytes value is invalid, or the BusTransaction-&gt;ReadinBytes value is invalid </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The BusTransaction-&gt; Transaction Type is unsupported</td></tr>
  </table>
  </dd>
</dl>
<p>Get the capabilities of the underlying inline cryptographic interface.</p>
<p>The GetCapabilities() function determines whether pre-OS controllable inline crypto is supported by the system for the current disk and, if so, returns the capabilities of the crypto engine.</p>
<p>The caller is responsible for providing the Capabilities structure with a sufficient number of entries.</p>
<p>If the structure is too small, the EFI_BUFFER_TOO_SMALL error code is returned and the CapabilityCount field contains the number of entries needed to contain the capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Capabilities</td><td>Pointer to the <a class="el" href="struct_e_f_i___b_l_o_c_k___i_o___c_r_y_p_t_o___c_a_p_a_b_i_l_i_t_i_e_s.html">EFI_BLOCK_IO_CRYPTO_CAPABILITIES</a> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The ICI is ready for use. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The Capabilities structure was too small. The number of entries needed is returned in the CapabilityCount field of the structure. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>No response was received from the ICI. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the ICI. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Capabilities is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the configuration of the underlying inline cryptographic interface.</p>
<p>The SetConfiguration() function allows the user to set the current configuration of the inline cryptographic interface and should be called before attempting any crypto operations.</p>
<p>This configures the configuration table entries with algorithms, key sizes and keys. Each configured entry can later be referred to by index at the time of storage transaction.</p>
<p>The configuration table index will refer to the combination ofKeyOwnerGuid, Algorithm, and CryptoKey.</p>
<p>KeyOwnerGuid identifies the component taking ownership of the entry. It helps components to identify their own entries, cooperate with other owner components, and avoid conflicts. This Guid identifier is there to help coordination between cooperating components and not a security or synchronization feature. The Nil <a class="el" href="struct_g_u_i_d.html">GUID</a> can be used by a component to release use of entry owned. It is also used to identify potentially available entries (see GetConfiguration).</p>
<p>CryptoKey specifies algorithm-specific key material to use within parameters of selected crypto capability.</p>
<p>This function is called infrequently typically once, on device start, before IO starts. It can be called at later times in cases the number of keysused on the drive is higher than what can be configured at a time or a new key has to be added.</p>
<p>Components setting or changing an entry or entries for a given index or indices must ensure that IO referencing affected indices is temporarily blocked (run-down) at the time of change.</p>
<p>Indices parameters in each parameter table entry allow to set only a portion of the available table entries in the crypto module anywhere from single entry to entire table supported.</p>
<p>If corresponding table entry or entries being set are already in use by another owner the call should be failed and none of the entries should be modified. The interface implementation must enforce atomicity of this operation (should either succeed fully or fail completely without modifying state).</p>
<p>Note that components using GetConfiguration command to discover available entries should be prepared that by the time of calling SetConfiguration the previously available entry may have become occupied. Such components should be prepared to re-try the sequence of operations.</p>
<p>Alternatively EFI_BLOCK_IO_CRYPTO_INDEX_ANY can be used to have the implementation discover and allocate available,if any, indices atomically.</p>
<p>An optional ResultingTable pointer can be provided by the caller to receive the newly configured entries. The array provided by the caller must have at least ConfigurationCount of entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigurationCount</td><td>Number of entries being configured with this call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigurationTable</td><td>Pointer to a table used to populate the configuration table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ResultingTable</td><td>Optional pointer to a table that receives the newly configured entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The ICI is ready for use. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>No response was received from the ICI. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the ICI. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ConfigurationTable is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ConfigurationCount is 0. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not find the requested number of available entries in the configuration table.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the configuration of the underlying inline cryptographic interface.</p>
<p>The GetConfiguration() function allows the user to get the configuration of the inline cryptographic interface.</p>
<p>Retrieves, entirely or partially, the currently configured key table. Note that the keys themselves are not retrieved, but rather just indices, owner GUIDs and capabilities.</p>
<p>If fewer entries than specified by ConfigurationCount are returned, the Index field of the unused entries is set to EFI_BLOCK_IO_CRYPTO_INDEX_ANY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">StartIndex</td><td>Configuration table index at which to start the configuration query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigurationCount</td><td>Number of entries to return in the response table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyOwnerGuid</td><td>Optional parameter to filter response down to entries with a given owner. A pointer to the Nil value can be used to return available entries. Set to NULL when no owner filtering is required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ConfigurationTable</td><td>Table of configured configuration table entries (with no CryptoKey returned): configuration table index, KeyOwnerGuid, Capability. Should have sufficient space to store up to ConfigurationCount entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The ICI is ready for use. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>No response was received from the ICI. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the ICI. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Configuration table is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>StartIndex is out of bounds.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads the requested number of blocks from the device and optionally decrypts them inline.</p>
<p>TheReadExtended() function allows the caller to perform a storage device read operation. The function reads the requested number of blocks from the device and then if Index is specified decrypts them inline. All the blocks are read and decrypted (if decryption requested), or an error is returned.</p>
<p>If there is no media in the device, the function returns EFI_NO_MEDIA. If the MediaId is not the ID for the current media in the device, the function returns EFI_MEDIA_CHANGED.</p>
<p>If EFI_DEVICE_ERROR, EFI_NO_MEDIA, or EFI_MEDIA_CHANGED is returned and nonblocking I/O is being used, the Event associated with this request will not be signaled.</p>
<p>In addition to standard storage transaction parameters (LBA, IO size, and buffer), this command will also specify a configuration table Index and CryptoIvInput when data has to be decrypted inline by the controller after being read from the storage device. If an Index parameter is not specified, no decryption is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>The media ID that the read request is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LBA</td><td>The starting logical block address to read from on the device. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>The size of the Buffer in bytes. This must be a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A pointer to the destination buffer for the data. The caller is responsible for either having implicit or explicit ownership of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Index</td><td>A pointer to the configuration table index. This is optional. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CryptoIvInput</td><td>A pointer to a buffer that contains additional cryptographic parameters as required by the capability referenced by the configuration table index, such as cryptographic initialization vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The read request was queued if Token-&gt; Event is not NULL. The data was read correctly from the device if the Token-&gt;Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while attempting to perform the read operation and/or decryption operation. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The BufferSize parameter is not a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, or the read request contains LBAs that are not valid, or the buffer is not on proper alignment. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CryptoIvInput is incorrect. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Optionally encrypts a specified number of blocks inline and then writes to the device.</p>
<p>The WriteExtended() function allows the caller to perform a storage device write operation. The function encrypts the requested number of blocks inline if Index is specified and then writes them to the device. All the blocks are encrypted (if encryption requested) and written, or an error is returned.</p>
<p>If there is no media in the device, the function returns EFI_NO_MEDIA. If the MediaId is not the ID for the current media in the device, the function returns EFI_MEDIA_CHANGED.</p>
<p>If EFI_DEVICE_ERROR, EFI_NO_MEDIA, or EFI_MEDIA_CHANGED is returned and nonblocking I/O is being used, the Event associated with this request will not be signaled.</p>
<p>In addition to standard storage transaction parameters (LBA, IO size, and buffer), this command will also specify a configuration table Index and a CryptoIvInput when data has to be decrypted inline by the controller before being written to the storage device. If no Index parameter is specified, no encryption is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>The media ID that the read request is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LBA</td><td>The starting logical block address to read from on the device. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>The size of the Buffer in bytes. This must be a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>A pointer to the source buffer for the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Index</td><td>A pointer to the configuration table index. This is optional. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CryptoIvInput</td><td>A pointer to a buffer that contains additional cryptographic parameters as required by the capability referenced by the configuration table index, such as cryptographic initialization vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The request to encrypt (optionally) and write was queued if Event is not NULL. The data was encrypted (optionally) and written correctly to the device if the Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while attempting to encrypt blocks or to perform the write operation. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The BufferSize parameter is not a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, or the write request contains LBAs that are not valid, or the buffer is not on proper alignment. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CryptoIvInput is incorrect. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Flushes all modified data toa physical block device.</p>
<p>The FlushBlocks() function flushes all modified data to the physical block device. Any modified data that has to be encrypted must have been already encrypted as a part of WriteExtended() operation - inline crypto operation cannot be a part of flush operation.</p>
<p>All data written to the device prior to the flush must be physically written before returning EFI_SUCCESS from this function. This would include any cached data the driver may have cached, and cached data the device may have cached. A flush may cause a read request following the flush to force a device access.</p>
<p>If EFI_DEVICE_ERROR, EFI_NO_MEDIA, EFI_WRITE_PROTECTED or EFI_MEDIA_CHANGED is returned and non-blocking I/O is being used, the Event associated with this request will not be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLOCK_IO_CRYPTO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The flush request was queued if Event is not NULL. All outstanding data was written correctly to the device if the Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while attempting to write data. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Get TLS session data.</p>
<p>The GetSessionData() function return the TLS session information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_TLS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>TLS session data type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>Pointer to session data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>Total size of session data. On input, it means the size of Data buffer. On output, it means the size of copied Data buffer if EFI_SUCCESS, and means the size of desired Data buffer if EFI_BUFFER_TOO_SMALL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The TLS session data is got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. DataSize is NULL. Data is NULL if *DataSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The TLS session data is not found. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The DataType is not ready in current session state. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the data.</td></tr>
  </table>
  </dd>
</dl>
<p>Build response packet according to TLS state machine. This function is only valid for alert, handshake and change_cipher_spec content type.</p>
<p>The BuildResponsePacket() function builds TLS response packet in response to the TLS request packet specified by RequestBuffer and RequestSize. If RequestBuffer is NULL and RequestSize is 0, and TLS session status is EfiTlsSessionNotStarted, the TLS session will be initiated and the response packet needs to be ClientHello. If RequestBuffer is NULL and RequestSize is 0, and TLS session status is EfiTlsSessionClosing, the TLS session will be closed and response packet needs to be CloseNotify. If RequestBuffer is NULL and RequestSize is 0, and TLS session status is EfiTlsSessionError, the TLS session has errors and the response packet needs to be Alert message based on error type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_TLS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestBuffer</td><td>Pointer to the most recently received TLS packet. NULL means TLS need initiate the TLS session and response packet need to be ClientHello. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestSize</td><td>Packet size in bytes for the most recently received TLS packet. 0 is only valid when RequestBuffer is NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the buffer to hold the built packet. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferSize</td><td>Pointer to the buffer size in bytes. On input, it is the buffer size provided by the caller. On output, it is the buffer size in fact needed to contain the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The required TLS packet is built successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. RequestBuffer is NULL but RequestSize is NOT 0. RequestSize is 0 but RequestBuffer is NOT NULL. BufferSize is NULL. Buffer is NULL if *BufferSize is not zero. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>BufferSize is too small to hold the response packet. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Current TLS session state is NOT ready to build ResponsePacket. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Something wrong build response packet.</td></tr>
  </table>
  </dd>
</dl>
<p>Decrypt or encrypt TLS packet during session. This function is only valid after session connected and for application_data content type.</p>
<p>The ProcessPacket () function process each inbound or outbound TLS APP packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_TLS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FragmentTable</td><td>Pointer to a list of fragment. The caller will take responsible to handle the original FragmentTable while it may be reallocated in TLS driver. If CryptMode is EfiTlsEncrypt, on input these fragments contain the TLS header and plain text TLS APP payload; on output these fragments contain the TLS header and cipher text TLS APP payload. If CryptMode is EfiTlsDecrypt, on input these fragments contain the TLS header and cipher text TLS APP payload; on output these fragments contain the TLS header and plain text TLS APP payload. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FragmentCount</td><td>Number of fragment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CryptMode</td><td>Crypt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. FragmentTable is NULL. FragmentCount is NULL. CryptoMode is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Current TLS session state is NOT EfiTlsSessionDataTransferring. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Something wrong decryption the message. TLS session status will become EfiTlsSessionError. The caller need call BuildResponsePacket() to generate Error Alert message and send it out. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>No enough resource to finish the operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Clear the SPI protect range registers.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS uses this routine to set an initial condition on the SPI protect range registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_FLASH_PROTOCOL data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The registers were successfully cleared </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Not a legacy SPI host controller</td></tr>
  </table>
  </dd>
</dl>
<p>Set the next protect range register.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS sets the protect range register to prevent write and erase operations to a portion of the SPI NOR flash device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BiosAddress</td><td>Address within a 4 KiB block to start protecting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlocksToProtect</td><td>The number of 4 KiB blocks to protect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The register was successfully updated </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BiosAddress &lt; This-&gt;BiosBaseAddress, or </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BlocksToProtect * 4 KiB &gt; This-&gt;MaximumRangeBytes, or BiosAddress - This-&gt;BiosBaseAddress<ul>
<li>(BlocksToProtect * 4 KiB) &gt; This-&gt;MaximumRangeBytes </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>No protect range register available </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Call This-&gt;SetBaseAddress because the BIOS base address is not set Not a legacy SPI host controller</td></tr>
  </table>
  </dd>
</dl>
<p>Lock the SPI controller configuration.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine locks the SPI controller's configuration so that the software is no longer able to update: Prefix table Opcode menu Opcode type table BIOS base address Protect range registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_FLASH_PROTOCOL data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SPI controller was successfully locked </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The SPI controller was already locked </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Not a legacy SPI host controller</td></tr>
  </table>
  </dd>
</dl>
<p>Close I/O aperture.</p>
<p>This function closes a previously opened I/O aperture handle. If there are no more I/O aperture handles that refer to the hardware I/O aperture resource, then the hardware I/O aperture is closed. It may be possible that a single hardware aperture may be used for more than one device. This function tracks the number of times that each aperture is referenced, and does not close the hardware aperture (via CloseIoAperture()) until there are no more references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to this instance of the EFI_ISA_HC_PROTOCOL. </td></tr>
    <tr><td class="paramname">IoApertureHandle</td><td>The I/O aperture handle previously returned from a call to OpenIoAperture().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The IO aperture was closed successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>This service allows the caller to invoke a procedure one of the application processors (AP). This function uses an optional token parameter to support blocking and non-blocking modes. If the token is passed into the call, the function will operate in a non-blocking fashion and the caller can check for completion with CheckOnProcedure or WaitForProcedure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the procedure to be run on the designated target AP of the system. Type EFI_AP_PROCEDURE2 is defined below in related definitions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CpuNumber</td><td>The zero-based index of the processor number of the target AP, on which the code stream is supposed to run. If the number points to the calling processor then it will not run the supplied code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroseconds</td><td>Indicates the time limit in microseconds for this AP to finish execution of Procedure, either for blocking or non-blocking mode. Zero means infinity. If the timeout expires before this AP returns from Procedure, then Procedure on the AP is terminated. If the timeout expires in blocking mode, the call returns EFI_TIMEOUT. If the timeout expires in non-blocking mode, the timeout determined can be through CheckOnProcedure or WaitForProcedure. Note that timeout support is optional. Whether an implementation supports this feature, can be determined via the Attributes data member. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ProcedureArguments</td><td>Allows the caller to pass a list of parameters to the code that is run by the AP. It is an optional common mailbox between APs and the caller to share information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>This is parameter is broken into two components: 1.Token-&gt;Completion is an optional parameter that allows the caller to execute the procedure in a blocking or non-blocking fashion. If it is NULL the call is blocking, and the call will not return until the AP has completed the procedure. If the token is not NULL, the call will return immediately. The caller can check whether the procedure has completed with CheckOnProcedure or WaitForProcedure. 2.Token-&gt;Status The implementation updates the address pointed at by this variable with the status code returned by Procedure when it completes execution on the target AP, or with EFI_TIMEOUT if the Procedure fails to complete within the optional timeout. The implementation will update this variable with EFI_NOT_READY prior to starting Procedure on the target AP. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CPUStatus</td><td>This optional pointer may be used to get the status code returned by Procedure when it completes execution on the target AP, or with EFI_TIMEOUT if the Procedure fails to complete within the optional timeout. The implementation will update this variable with EFI_NOT_READY prior to starting Procedure on the target AP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In the blocking case, this indicates that Procedure has completed execution on the target AP. In the non-blocking case this indicates that the procedure has been successfully scheduled for execution on the target AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The input arguments are out of range. Either the target AP is the caller of the function, or the Procedure or Token is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>If the target AP is busy executing another procedure </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>Token is already in use for another procedure </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before the specified AP has finished</td></tr>
  </table>
  </dd>
</dl>
<p>This service allows the caller to invoke a procedure on all running application processors (AP) except the caller. This function uses an optional token parameter to support blocking and nonblocking modes. If the token is passed into the call, the function will operate in a non-blocking fashion and the caller can check for completion with CheckOnProcedure or WaitForProcedure.</p>
<p>It is not necessary for the implementation to run the procedure on every processor on the platform. Processors that are powered down in such a way that they cannot respond to interrupts, may be excluded from the broadcast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the code stream to be run on the APs that have entered MM. Type EFI_AP_PROCEDURE is defined below in related definitions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroseconds</td><td>Indicates the time limit in microseconds for the APs to finish execution of Procedure, either for blocking or non-blocking mode. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. If the timeout expires in blocking mode, the call returns EFI_TIMEOUT. If the timeout expires in non-blocking mode, the timeout determined can be through CheckOnProcedure or WaitForProcedure. Note that timeout support is optional. Whether an implementation supports this feature can be determined via the Attributes data member. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ProcedureArguments</td><td>Allows the caller to pass a list of parameters to the code that is run by the AP. It is an optional common mailbox between APs and the caller to share information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>This is parameter is broken into two components: 1.Token-&gt;Completion is an optional parameter that allows the caller to execute the procedure in a blocking or non-blocking fashion. If it is NULL the call is blocking, and the call will not return until the AP has completed the procedure. If the token is not NULL, the call will return immediately. The caller can check whether the procedure has completed with CheckOnProcedure or WaitForProcedure. 2.Token-&gt;Status The implementation updates the address pointed at by this variable with the status code returned by Procedure when it completes execution on the target AP, or with EFI_TIMEOUT if the Procedure fails to complete within the optional timeout. The implementation will update this variable with EFI_NOT_READY prior to starting Procedure on the target AP </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CPUStatus</td><td>This optional pointer may be used to get the individual status returned by every AP that participated in the broadcast. This parameter if used provides the base address of an array to hold the EFI_STATUS value of each AP in the system. The size of the array can be ascertained by the GetNumberOfProcessors function. As mentioned above, the broadcast may not include every processor in the system. Some implementations may exclude processors that have been powered down in such a way that they are not responsive to interrupts. Additionally the broadcast excludes the processor which is making the BroadcastProcedure call. For every excluded processor, the array entry must contain a value of EFI_NOT_STARTED</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In the blocking case, this indicates that Procedure has completed execution on the APs. In the non-blocking case this indicates that the procedure has been successfully scheduled for execution on the APs. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure or Token is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>If a target AP is busy executing another procedure. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before all enabled APs have finished. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>Before the AP procedure associated with the Token is finished, the same Token cannot be used to dispatch or broadcast another procedure.</td></tr>
  </table>
  </dd>
</dl>
<p>This service allows the caller to set a startup procedure that will be executed when an AP powers up from a state where core configuration and context is lost. The procedure is execution has the following properties:</p>
<ol type="1">
<li>The procedure executes before the processor is handed over to the operating system.</li>
<li>All processors execute the same startup procedure.</li>
<li>The procedure may run in parallel with other procedures invoked through the functions in this protocol, or with processors that are executing an MM handler or running in the operating system.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the code stream to be run on the designated target AP of the system. Type EFI_AP_PROCEDURE is defined below in Volume 2 with the related definitions of <a class="el" href="struct___e_f_i___m_p___s_e_r_v_i_c_e_s___p_r_o_t_o_c_o_l.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs</a>. If caller may pass a value of NULL to deregister any existing startup procedure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ProcedureArguments</td><td>Allows the caller to pass a list of parameters to the code that is run by the AP. It is an optional common mailbox between APs and the caller to share information</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The Procedure has been set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>When non-blocking execution of a procedure on an AP is invoked with DispatchProcedure, via the use of a token, this function can be used to check for completion of the procedure on the AP. The function takes the token that was passed into the DispatchProcedure call. If the procedure is complete, and therefore it is now possible to run another procedure on the same AP, this function returns EFI_SUCESS. In this case the status returned by the procedure that executed on the AP is returned in the token's Status field. If the procedure has not yet completed, then this function returns EFI_NOT_READY.</p>
<p>When a non-blocking execution of a procedure is invoked with BroadcastProcedure, via the use of a token, this function can be used to check for completion of the procedure on all the broadcast APs. The function takes the token that was passed into the BroadcastProcedure call. If the procedure is complete on all broadcast APs this function returns EFI_SUCESS. In this case the Status field in the token passed into the function reflects the overall result of the invocation, which may be EFI_SUCCESS, if all executions succeeded, or the first observed failure. If the procedure has not yet completed on the broadcast APs, the function returns EFI_NOT_READY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>This parameter describes the token that was passed into DispatchProcedure or BroadcastProcedure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Procedure has completed. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The Procedure has not completed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Token or Token-&gt;Completion is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Token is not currently in use for a non-blocking call</td></tr>
  </table>
  </dd>
</dl>
<p>When a non-blocking execution of a procedure on an AP is invoked via DispatchProcedure, this function will block the caller until the remote procedure has completed on the designated AP. The non-blocking procedure invocation is identified by the Token parameter, which must match the token that used when DispatchProcedure was called. Upon completion the status returned by the procedure that executed on the AP is used to update the token's Status field.</p>
<p>When a non-blocking execution of a procedure on an AP is invoked via BroadcastProcedure this function will block the caller until the remote procedure has completed on all of the APs that entered MM. The non-blocking procedure invocation is identified by the Token parameter, which must match the token that used when BroadcastProcedure was called. Upon completion the overall status returned by the procedures that executed on the broadcast AP is used to update the token's Status field. The overall status may be EFI_SUCCESS, if all executions succeeded, or the first observed failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The EFI_MM_MP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>This parameter describes the token that was passed into DispatchProcedure or BroadcastProcedure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Procedure has completed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Token or Token-&gt;Completion is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Token is not currently in use for a non-blocking call</td></tr>
  </table>
  </dd>
</dl>
<p>Configures endpoints based on supplied device and configuration descriptors.</p>
<p>Assuming that the hardware has already been initialized, this function configures the endpoints using the device information supplied by DeviceInfo, activates the port, and starts receiving USB events.</p>
<p>This function must ignore the bMaxPacketSize0field of the Standard Device Descriptor and the wMaxPacketSize field of the Standard Endpoint Descriptor that are made available through DeviceInfo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DeviceInfo</td><td>A pointer to EFI_USBFN_DEVICE_INFO instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the maximum packet size of the specified endpoint type for the supplied bus speed.</p>
<p>If the BusSpeed is UsbBusSpeedUnknown, the maximum speed the underlying controller supports is assumed.</p>
<p>This protocol currently does not support isochronous or interrupt transfers. Future revisions of this protocol may eventually support it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOLinstance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointType</td><td>Endpoint type as defined as EFI_USB_ENDPOINT_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BusSpeed</td><td>Bus speed as defined as EFI_USB_BUS_SPEED. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MaxPacketSize</td><td>The maximum packet size, in bytes, of the specified endpoint type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns device specific information based on the supplied identifier as a Unicode string.</p>
<p>If the supplied Buffer isn't large enough, or is NULL, the method fails with EFI_BUFFER_TOO_SMALL and the required size is returned through BufferSize. All returned strings are in Unicode format.</p>
<p>An Id of EfiUsbDeviceInfoUnknown is treated as an invalid parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOLinstance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Id</td><td>The requested information id.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>On input, the size of the Buffer in bytes. On output, the amount of data returned in Buffer in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A pointer to a buffer to returnthe requested information as a Unicode string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: BufferSize is NULL. BufferSize is not 0 and Buffer is NULL. Id in invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the buffer. BufferSize has been updated with the size needed to hold the request string.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the vendor-id and product-id of the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Vid</td><td>Returned vendor-id of the device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Pid</td><td>Returned product-id of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Unable to return the vendor-id or the product-id.</td></tr>
  </table>
  </dd>
</dl>
<p>Aborts the transfer on the specified endpoint.</p>
<p>This function should fail with EFI_INVALID_PARAMETER if the specified direction is incorrect for the endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the endpoint on which the ongoing transfer needs to be canceled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the stall state on the specified endpoint.</p>
<p>This function should fail with EFI_INVALID_PARAMETER if the specified direction is incorrect for the endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">State</td><td>Boolean, true value indicates that the endpoint is in a stalled state, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets or clears the stall state on the specified endpoint.</p>
<p>This function should fail with EFI_INVALID_PARAMETER if the specified direction is incorrect for the endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">State</td><td>Requested stall state on the specified endpoint. True value causes the endpoint to stall; false value clears an existing stall.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called repeatedly to get information on USB bus states, receive-completion and transmit-completion events on the endpoints, and notification on setup packet on endpoint 0.</p>
<p>A class driver must call <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a27b79b326e4146b395d8bc8b8f704b69">EFI_USBFN_IO_PROTOCOL.EventHandler()</a>repeatedly to receive updates on the transfer status and number of bytes transferred on various endpoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Message</td><td>Indicates the event that initiated this notification. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">PayloadSize</td><td>On input, the size of the memory pointed by Payload. On output, the amount ofdata returned in Payload. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Payload</td><td>A pointer to EFI_USBFN_MESSAGE_PAYLOAD instance to return additional payload for current message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The Supplied buffer is not large enough to hold the message payload.</td></tr>
  </table>
  </dd>
</dl>
<p>This function handles transferring data to or from the host on the specified endpoint, depending on the direction specified.</p>
<p>A class driver must call <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a27b79b326e4146b395d8bc8b8f704b69">EFI_USBFN_IO_PROTOCOL.EventHandler()</a> repeatedly to receive updates on the transfer status and the number of bytes transferred on various endpoints. Upon an update of the transfer status, the Buffer field of the EFI_USBFN_TRANSFER_RESULT structure (as described in the function description for <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a27b79b326e4146b395d8bc8b8f704b69">EFI_USBFN_IO_PROTOCOL.EventHandler()</a>) must be initialized with the Buffer pointer that was supplied to this method.</p>
<p>The overview of the call sequence is illustrated in the Figure 54.</p>
<p>This function should fail with EFI_INVALID_PARAMETER if the specified direction is incorrect for the endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the endpoint on which TX or RX transfer needs to take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferSize</td><td>If Direction is EfiUsbEndpointDirectionDeviceRx: On input, the size of the Bufferin bytes. On output, the amount of data returned in Buffer in bytes. If Direction is EfiUsbEndpointDirectionDeviceTx: On input, the size of the Bufferin bytes. On output, the amount of data transmitted in bytes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Buffer</td><td>If Direction is EfiUsbEndpointDirectionDeviceRx: The Buffer to return the received data. If Directionis EfiUsbEndpointDirectionDeviceTx: The Buffer that contains the data to be transmitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the maximum supported transfer size.</p>
<p>Returns the maximum number of bytes that the underlying controller can accommodate in a single transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MaxTransferSize</td><td>The maximum supported transfer size, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The physical device is busy or not ready to process this request.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates a transfer buffer of the specified sizethat satisfies the controller requirements.</p>
<p>The AllocateTransferBuffer() function allocates a memory region of Size bytes and returns the address of the allocated memory that satisfies the underlying controller requirements in the location referenced by Buffer.</p>
<p>The allocated transfer buffer must be freed using a matching call to <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#ad957c3237a95273701e8c335494bf906">EFI_USBFN_IO_PROTOCOL.FreeTransferBuffer()</a>function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Size</td><td>The number of bytes to allocate for the transfer buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The requested transfer buffer could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Deallocates the memory allocated for the transfer buffer by the <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a4861402e6f8b48c020747af38fe31477">EFI_USBFN_IO_PROTOCOL.AllocateTransferBuffer()</a> function.</p>
<p>The <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#ad957c3237a95273701e8c335494bf906">EFI_USBFN_IO_PROTOCOL.FreeTransferBuffer()</a> function deallocates the memory specified by Buffer. The Buffer that is freed must have been allocated by <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a4861402e6f8b48c020747af38fe31477">EFI_USBFN_IO_PROTOCOL.AllocateTransferBuffer()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>A pointer to the transfer buffer to deallocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>This function supplies power to the USB controller if needed and initializes the hardware and the internal data structures. The port must not be activated by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error.</td></tr>
  </table>
  </dd>
</dl>
<p>This function stops the USB hardware device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the configuration policy for the specified non-control endpoint.</p>
<p>This function can only be called before <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#ab8e3afdcd981ebd3bc9e11901121254f">EFI_USBFN_IO_PROTOCOL.StartController()</a> or after <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a190c410d7a8d667a41cc34d5e35e5e52">EFI_USBFN_IO_PROTOCOL.StopController()</a> has been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the non-control endpoint for which the policy needs to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PolicyType</td><td>Policy type the user is trying to set for the specified non-control endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>The size of the Bufferin bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>The new value for the policy parameter that PolicyType specifies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The physical device reported an error. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Changing this policy value is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the configuration policy for the specified non-control endpoint.</p>
<p>This function can only be called before <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#ab8e3afdcd981ebd3bc9e11901121254f">EFI_USBFN_IO_PROTOCOL.StartController()</a> or after <a class="el" href="struct___e_f_i___u_s_b_f_n___i_o___p_r_o_t_o_c_o_l.html#a190c410d7a8d667a41cc34d5e35e5e52">EFI_USBFN_IO_PROTOCOL.StopController()</a> has been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointIndex</td><td>Indicates the non-control endpoint for which the policy needs to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Direction of the endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PolicyType</td><td>Policy type the user is trying to retrieve for the specified non-control endpoint. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferSize</td><td>On input, the size of Bufferin bytes. On output, the amount of data returned in Bufferin bytes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Buffer</td><td>A pointer to a buffer to return requested endpoint policy value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>A parameter is invalid. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The specified policy value is not supported. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>Supplied buffer is not large enough to hold requested policy value.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads a specified number of bytes from a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to be read. </td></tr>
    <tr><td class="paramname">Offset</td><td>The starting byte offset on the logical block I/O device to read from. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. If this field is NULL, synchronous/blocking IO is performed. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>The size in bytes of Buffer. The number of bytes to read from the device. </td></tr>
    <tr><td class="paramname">Buffer</td><td>A pointer to the destination buffer for the data. The caller is responsible either having implicit or explicit ownership of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was read correctly from the device. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. Event will be signaled upon completion. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the write. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no medium in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHNAGED</td><td>The MediaId is not for the current medium. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The read request contains device addresses that are not valid for the device. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes a specified number of bytes to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to be written. </td></tr>
    <tr><td class="paramname">Offset</td><td>The starting byte offset on the logical block I/O device to write to. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. If this field is NULL, synchronous/blocking IO is performed. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>The size in bytes of Buffer. The number of bytes to write to the device. </td></tr>
    <tr><td class="paramname">Buffer</td><td>A pointer to the buffer containing the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was written correctly to the device. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. Event will be signaled upon completion. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the write operation. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no medium in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHNAGED</td><td>The MediaId is not for the current medium. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The write request contains device addresses that are not valid for the device. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Flushes all modified data to the physical device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to be written. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. If this field is NULL, synchronous/blocking IO is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was flushed successfully to the device. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. Event will be signaled upon completion. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the write operation. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no medium in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHNAGED</td><td>The MediaId is not for the current medium. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Get EAP configuration data.</p>
<p>The GetData() function gets EAP configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_EAP_CONFIGURATION_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EapType</td><td>EAP type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>Pointer to configuration data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>Total size of configuration data. On input, it means the size of Data buffer. On output, it means the size of copied Data buffer if EFI_SUCCESS, and means the size of desired Data buffer if EFI_BUFFER_TOO_SMALL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The EAP configuration data is got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: Data is NULL. DataSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The EapType or DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The EAP configuration data is not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Processes a buffer containing binary DER-encoded detached PKCS7 signature. The hash of the signed data content is calculated and passed by the caller. Function verifies the signature of the content is valid and signing certificate was not revoked and is contained within a list of trusted signers.</p>
<p>Note: because this function uses hashes and the specification contains a variety of hash choices, you should be aware that the check against the RevokedDb list will improperly succeed if the signature is revoked using a different hash algorithm. For this reason, you should either cycle through all UEFI supported hashes to see if one is forbidden, or rely on a single hash choice only if the UEFI signature authority only signs and revokes with a single hash (at time of writing, this hash choice is SHA256).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_PKCS7_VERIFY_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Signature</td><td>Points to buffer containing ASN.1 DER-encoded PKCS detached signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SignatureSize</td><td>The size of Signature buffer in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InHash</td><td>InHash points to buffer containing the caller calculated hash of the data. The parameter may not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InHashSize</td><td>The size in bytes of InHash buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AllowedDb</td><td>Pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. The <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures contain lists of X.509 certificates of approved signers. Function recognizes signer certificates of type EFI_CERT_X509_GUID. Any hash certificate in AllowedDb list is ignored by this function. Function returns success if signer of the buffer is within this list (and not within RevokedDb). This parameter is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RevokedDb</td><td>Optional pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. List of X.509 certificates of revoked signers and revoked file hashes. Signature verification will always fail if the signer of the file or the hash of the data component of the buffer is in RevokedDb list. This parameter is optional and caller may pass Null if not required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeStampDb</td><td>Optional pointer to a list of pointers to <a class="el" href="struct_e_f_i___s_i_g_n_a_t_u_r_e___l_i_s_t.html">EFI_SIGNATURE_LIST</a> structures. The list is terminated by a null pointer. This parameter can be used to pass a list of X.509 certificates of trusted time stamp counter-signers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Signed hash was verified against caller-provided hash of content, the signer's certificate was not found in RevokedDb, and was found in AllowedDb or if in signer is found in both AllowedDb and RevokedDb, the signing was allowed by reference to TimeStampDb as described above, and no hash matching content hash was found in RevokedDb. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The SignedData buffer was correctly formatted but signer was in RevokedDb or not in AllowedDb. Also returned if matching content hash found in RevokedDb. </td></tr>
    <tr><td class="paramname">EFI_COMPROMISED_DATA</td><td>Caller provided hash differs from signed hash. Or, caller and encrypted hash are different sizes. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Signature is NULL or SignatureSize is zero. InHash is NULL or InHashSize is zero. AllowedDb is NULL. </td></tr>
    <tr><td class="paramname">EFI_ABORTED</td><td>Unsupported or invalid format in TimeStampDb, RevokedDb or AllowedDb list contents was detected. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The Signature buffer was not correctly formatted for processing by the function.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="_tcg2_protocol_8h.html#a412aad19df2dd28f58da0fdef8f7ad02">Response()</a> function queues an HTTP response to this HTTP instance, similar to <a class="el" href="_supplicant_8h.html#ad64984a28acf10f8bb9dd4ef2843635ca5a54306f6db7e247a7746d8d5ff701e9">Receive()</a> function in the EFI TCP driver. When the HTTP Response is received successfully, or if there is an error, Status in token will be updated and Event will be signaled.</p>
<p>The HTTP driver will queue a receive token to the underlying TCP instance. When data is received in the underlying TCP instance, the data will be parsed and Token will be populated with the response data. If the data received from the remote host contains an incomplete or invalid HTTP header, the HTTP driver will continue waiting (asynchronously) for more data to be sent from the remote host before signaling Event in Token.</p>
<p>It is the responsibility of the caller to allocate a buffer for Body and specify the size in BodyLength. If the remote host provides a response that contains a content body, up to BodyLength bytes will be copied from the receive buffer into Body and BodyLength will be updated with the amount of bytes received and copied to Body. This allows the client to download a large file in chunks instead of into one contiguous block of memory. Similar to HTTP request, if Body is not NULL and BodyLength is non-zero and all other fields are NULL or 0, the HTTP driver will queue a receive token to underlying TCP instance. If data arrives in the receive buffer, up to BodyLength bytes of data will be copied to Body. The HTTP driver will then update BodyLength with the amount of bytes received and copied to Body.</p>
<p>If the HTTP driver does not have an open underlying TCP connection with the host specified in the response URL, Request() will return EFI_ACCESS_DENIED. This is consistent with RFC 2616 recommendation that HTTP clients should attempt to maintain an open TCP connection between client and host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_HTTP_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to storage containing HTTP response token.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Allocation succeeded. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI HTTP Protocol instance has not been initialized. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token-&gt;Message-&gt;Headers is NULL. Token-&gt;Message is NULL. Token-&gt;Message-&gt;Body is not NULL, Token-&gt;Message-&gt;BodyLength is non-zero, and Token-&gt;Message-&gt;Data is NULL, but a previous call to <a class="el" href="_tcg2_protocol_8h.html#a412aad19df2dd28f58da0fdef8f7ad02">Response()</a> has not been completed successfully. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate enough system resources. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>An open TCP connection is not present with the host specified by response URL.</td></tr>
  </table>
  </dd>
</dl>
<p>The Poll() function can be used by network drivers and applications to increase the rate that data packets are moved between the communication devices and the transmit and receive queues.</p>
<p>In some systems, the periodic timer event in the managed network driver may not poll the underlying communications device fast enough to transmit and/or receive all data packets without missing incoming packets or dropping outgoing packets. Drivers and applications that are experiencing packet loss should try calling the Poll() function more often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_HTTP_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed.. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>No incoming or outgoing data is processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI HTTP Protocol instance has not been started.</td></tr>
  </table>
  </dd>
</dl>
<p>Read or write specified flag of a UFS device.</p>
<p>The service is used to read/write UFS flag descriptors. The consumer of this API is responsible for allocating the buffer pointed by Flag. The buffer size is 1 byte as UFS flag descriptor is just a single Boolean value that represents a TRUE or FALSE, '0' or '1', ON or OFF type of value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_UFS_DEVICE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Read</td><td>The boolean variable to show r/w direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlagId</td><td>The ID of flag to be read or written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Flag</td><td>The buffer to set or clear flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The flag descriptor is set/clear successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Flag is NULL. FlagId is an invalid UFS flag ID. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The flag is not set/clear successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Read or write specified attribute of a UFS device.</p>
<p>The service is used to read/write UFS attributes. The consumer of this API is responsible for allocating the data buffer pointed by Attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The pointer to the EFI_UFS_DEVICE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Read</td><td>The boolean variable to show r/w direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AttrId</td><td>The ID of Attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Index</td><td>The Index of Attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Selector</td><td>The Selector of Attribute. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Attribute</td><td>The buffer of Attribute to be read or written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">AttrSize</td><td>The size of Attribute buffer. On input, the size, in bytes, of the data buffer specified by Attribute. On output, the number of bytes that were actually transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The attribute is read/written successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Attribute is NULL or AttrSize is NULL. AttrId, Index and Selector are invalid combination to point to a type of UFS attribute. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The attribute is not read/written successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Unregister a notification function.</p>
<p>The UnregisterResetNotify() function removes the previously registered notification using RegisterResetNotify().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_RESET_NOTIFICATION_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ResetFunction</td><td>The pointer to the ResetFunction being unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The reset notification function was unregistered. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ResetFunction is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The reset notification function specified by ResetFunction was not previously registered using RegisterResetNotify().</td></tr>
  </table>
  </dd>
</dl>
<p>Get the requested I2C bus frequency for a specified bus configuration.</p>
<p>This function returns the requested I2C bus clock frequency for the I2cBusConfiguration. This routine is provided for diagnostic purposes and is meant to be called after calling Enumerate to get the I2cBusConfiguration value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_ENUMERATE_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I2cBusConfiguration</td><td>I2C bus configuration to access the I2C device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*BusClockHertz</td><td>Pointer to a buffer to receive the I2C bus clock frequency in Hertz</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The I2C bus frequency was returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BusClockHertz was NULL </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>Invalid I2cBusConfiguration value</td></tr>
  </table>
  </dd>
</dl>
<p>Connect a wireless network specified by a particular SSID, BSS type and Security type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_WIRELESS_MAC_CONNECTION_II_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to the token for connecting wireless network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation started successfully. Results will be notified eventually. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>One or more of the input parameters are not supported by this implementation. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The connection process is already started. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified wireless network is not found. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Request a disconnection with current connected wireless network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_WIRELESS_MAC_CONNECTION_II_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to the token for disconnecting wireless network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation started successfully. Results will be notified eventually. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>One or more of the input parameters are not supported by this implementation. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Not connected to a wireless network. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Read data from the SPI flash.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine reads data from the SPI part in the buffer provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlashAddress</td><td>Address in the flash to start reading </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthInBytes</td><td>Read length in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Address of a buffer to receive the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The data was read successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Buffer is NULL, or FlashAddress &gt;= This-&gt;FlashSize, or LengthInBytes &gt; This-&gt;FlashSize - FlashAddress</td></tr>
  </table>
  </dd>
</dl>
<p>Read the flash status register.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine reads the flash part status register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthInBytes</td><td>Number of status bytes to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FlashStatus</td><td>Pointer to a buffer to receive the flash status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The status register was read successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Write the flash status register.</p>
<p>This routine must be called at or below TPL_N OTIFY. This routine writes the flash part status register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthInBytes</td><td>Number of status bytes to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlashStatus</td><td>Pointer to a buffer containing the new status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The status write was successful. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate the write buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Write data to the SPI flash.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine breaks up the write operation as necessary to write the data to the SPI part.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlashAddress</td><td>Address in the flash to start writing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthInBytes</td><td>Write length in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Address of a buffer containing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The data was written successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Buffer is NULL, or FlashAddress &gt;= This-&gt;FlashSize, or LengthInBytes &gt; This-&gt;FlashSize - FlashAddress </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory to copy buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Efficiently erases one or more 4KiB regions in the SPI flash.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine uses a combination of 4 KiB and larger blocks to erase the specified area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_NOR_FLASH_PROTOCOL data structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FlashAddress</td><td>Address within a 4 KiB block to start erasing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockCount</td><td>Number of 4 KiB blocks to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The erase was completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>FlashAddress &gt;= This-&gt;FlashSize, or BlockCount * 4 KiB &gt; This-&gt;FlashSize - FlashAddress</td></tr>
  </table>
  </dd>
</dl>
<p>Host address to host name translation.</p>
<p>The IpToHostName () function is used to translate the host address to host name. A type PTR query is used to get the primary name of the host. Implementation can choose to support this function or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IpAddress</td><td>Ip Address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to translate host address to host name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. IpAddress is not valid IP address. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides capability to retrieve arbitrary information from the DNS server.</p>
<p>This GeneralLookup() function retrieves arbitrary information from the DNS. The caller supplies a QNAME, QTYPE, and QCLASS, and all of the matching RRs are returned. All RR content (e.g., TTL) was returned. The caller need parse the returned RR to get required information. The function is optional. Implementation can choose to support it or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QName</td><td>Pointer to Query Name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QType</td><td>Query Type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QClass</td><td>Query Name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to retrieve arbitrary information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported. Or the requested QType is not supported </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. QName is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is to update the DNS Cache.</p>
<p>The UpdateDnsCache() function is used to add/delete/modify DNS cache entry. DNS cache can be normally dynamically updated after the DNS resolve succeeds. This function provided capability to manually add/delete/modify the DNS cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeleteFlag</td><td>If FALSE, this function is to add one entry to the DNS Cahce. If TRUE, this function will delete matching DNS Cache entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Override</td><td>If TRUE, the maching DNS cache entry will be overwritten with the supplied parameter. If FALSE, EFI_ACCESS_DENIED will be returned if the entry to be added is already existed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DnsCacheEntry</td><td>Pointer to DNS Cache entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. DnsCacheEntry.HostName is NULL. DnsCacheEntry.IpAddress is NULL. DnsCacheEntry.Timeout is zero. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The DNS cache entry already exists and Override is not TRUE. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCE</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Polls for incoming data packets and processes outgoing data packets.</p>
<p>The Poll() function can be used by network drivers and applications to increase the rate that data packets are moved between the communications device and the transmit and receive queues.</p>
<p>In some systems, the periodic timer event in the managed network driver may not poll the underlying communications device fast enough to transmit and/or receive all data packets without missing incoming packets or dropping outgoing packets. Drivers and applications that are experiencing packet loss should try calling the Poll() function more often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI DNS Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There is no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Data was dropped out of the transmit and/or receive queue. Consider increasing the polling rate.</td></tr>
  </table>
  </dd>
</dl>
<p>Abort an asynchronous DNS operation, including translation between IP and Host, and general look up behavior.</p>
<p>The Cancel() function is used to abort a pending resolution request. After calling this function, Token.Status will be set to EFI_ABORTED and then Token.Event will be signaled. If the token is not in one of the queues, which usually means that the asynchronous operation has completed, this function will not signal the token and EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS6_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to a token that has been issued by <a class="el" href="struct___e_f_i___d_n_s6___p_r_o_t_o_c_o_l.html#a821ea81654cc7f3057dd792d10e81dfe">EFI_DNS6_PROTOCOL.HostNameToIp</a> (), <a class="el" href="struct___e_f_i___d_n_s6___p_r_o_t_o_c_o_l.html#a00c7ed8daa23d4752ddd102b97f169f8">EFI_DNS6_PROTOCOL.IpToHostName()</a> or EFI_DNS6_PROTOCOL.GeneralLookup(). If NULL, all pending tokens are aborted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI DNS6 Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>When Token is not NULL, and the asynchronous DNS operation was not found in the transmit queue. It was either completed or was not issued by HostNameToIp(), IpToHostName() or GeneralLookup().</td></tr>
  </table>
  </dd>
</dl>
<p>Send a "REQUEST" or "COMMAND" message to remote server and receive a "RESPONSE" message for "REQUEST" from remote server according to Bluetooth attribute protocol data unit(PDU).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_ATTRIBUTE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Data of a REQUEST or COMMAND message. The first byte is the attribute PDU related opcode, followed by opcode specific fields. See Bluetooth specification, Vol 3, Part F, Attribute Protocol. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>The length of Data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Callback function to notify the RESPONSE is received to the caller, with the response buffer. Caller must check the response buffer content to know if the request action is success or fail. It may be NULL if the data is a COMMAND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. It is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The request is sent successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more parameters are invalid due to following conditions:<ul>
<li>The Buffer is NULL.</li>
<li>The BufferLength is 0.</li>
<li>The opcode in Buffer is not a valid OPCODE according to Bluetooth specification.</li>
<li>The Callback is NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Sending the request failed due to the host controller or the device error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>A GATT operation is already underway for this device. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The attribute does not support the corresponding operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Get BluetoothLE configuration data.</p>
<p>The GetData() function returns BluetoothLE configuration data. For remote BluetoothLE device configuration data, please use GetRemoteData() function with valid BD_ADDR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>On input, indicates the size, in bytes, of the data buffer specified by Data. On output, indicates the amount of data actually returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The BluetoothLE configuration data is returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE:<ul>
<li>DataSize is NULL.</li>
<li>*DataSize is 0.</li>
<li>Data is NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The DataType is not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Set BluetoothLE configuration data.</p>
<p>The SetData() function sets local BluetoothLE device configuration data. Not all DataType can be set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Indicates the size, in bytes, of the data buffer specified by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The BluetoothLE configuration data is set successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE:<ul>
<li>DataSize is 0.</li>
<li>Data is NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>Cannot set configuration data.</td></tr>
  </table>
  </dd>
</dl>
<p>Get remove BluetoothLE device configuration data.</p>
<p>The GetRemoteData() function returns remote BluetoothLE device configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Configuration data type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>On input, indicates the size, in bytes, of the data buffer specified by Data. On output, indicates the amount of data actually returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The remote BluetoothLE device configuration data is returned successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE:<ul>
<li>DataSize is NULL.</li>
<li>*DataSize is 0.</li>
<li>Data is NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The DataType is unsupported. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The DataType is not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The buffer is too small to hold the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function for SMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into callback function. This is optional parameter and may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EventDataType</td><td>Event data type in EFI_BLUETOOTH_LE_SMP_EVENT_DATA_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Indicates the size, in bytes, of the data buffer specified by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register Security Manager Protocol callback function for user authentication/authorization.</p>
<p>The RegisterSmpAuthCallback() function register Security Manager Protocol callback function for user authentication/authorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Callback function for user authentication/authorization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMP callback function is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A callback function is already registered on the same attribute opcode and attribute handle, when the Callback is not NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>A callback function is not registered on the same attribute opcode and attribute handle, when the Callback is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Send user authentication/authorization to remote device.</p>
<p>The SendSmpAuthData() function sends user authentication/authorization to remote device. It should be used to send these information after the caller gets the request data from the callback function by RegisterSmpAuthCallback().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EventDataType</td><td>Event data type in EFI_BLUETOOTH_LE_SMP_EVENT_DATA_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>The size of Data in bytes, of the data buffer specified by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be sent. The data format depends on the type of SMP event data being responded to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMP authorization data is sent successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>SMP is not in the correct state to receive the auth data.</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function to get SMP data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into callback function. This is optional parameter and may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. For Local device setting, it should be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Data type in EFI_BLUETOOTH_LE_SMP_DATA_TYPE. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DataSize</td><td>On input, indicates the size, in bytes, of the data buffer specified by Data. On output, indicates the amount of data actually returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Data</td><td>A pointer to the buffer of data that will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a callback function to get SMP related data.</p>
<p>The RegisterSmpGetDataCallback() function registers a callback function to get SMP related data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Callback function for SMP get data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMP get data callback function is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A callback function is already registered on the same attribute opcode and attribute handle, when the Callback is not NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>A callback function is not registered on the same attribute opcode and attribute handle, when the Callback is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function to set SMP data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into callback function. This is optional parameter and may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>Data type in EFI_BLUETOOTH_LE_SMP_DATA_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSize</td><td>Indicates the size, in bytes, of the data buffer specified by Data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>A pointer to the buffer of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a callback function to set SMP related data.</p>
<p>The RegisterSmpSetDataCallback() function registers a callback function to set SMP related data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Callback function for SMP set data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SMP set data callback function is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A callback function is already registered on the same attribute opcode and attribute handle, when the Callback is not NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>A callback function is not registered on the same attribute opcode and attribute handle, when the Callback is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>The callback function to hook connect complete event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into callback function. This is optional parameter and may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CallbackType</td><td>The value defined in EFI_BLUETOOTH_CONNECT_COMPLETE_CALLBACK_TYPE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BDAddr</td><td>Remote BluetoothLE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputBuffer</td><td>A pointer to the buffer of data that is input from callback caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputBufferSize</td><td>Indicates the size, in bytes, of the data buffer specified by InputBuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Register link connect complete callback function.</p>
<p>The RegisterLinkConnectCompleteCallback() function registers Bluetooth link connect complete callback function. The Bluetooth Configuration driver may call RegisterLinkConnectCompleteCallback() to register a callback function. During pairing, Bluetooth bus driver must trigger this callback function to report device state, if it is registered. Then Bluetooth Configuration driver will get information on device connection, according to CallbackType defined by EFI_BLUETOOTH_CONNECT_COMPLETE_CALLBACK_TYPE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_LE_CONFIG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>The callback function. NULL means unregister. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The link connect complete callback function is registered successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>A callback function is already registered on the same attribute opcode and attribute handle, when the Callback is not NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>A callback function is not registered on the same attribute opcode and attribute handle, when the Callback is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Configure this DNS instance.</p>
<p>This function is used to configure DNS mode data for this DNS instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DnsConfigData</td><td>Point to the Configuration data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The designated protocol is not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. The StationIp address provided in DnsConfigData is not a valid unicast. DnsServerList is NULL while DnsServerListCount is not ZERO. DnsServerListCount is ZERO while DnsServerList is not NULL </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The DNS instance data or required space could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred. The EFI DNSv4 Protocol instance is not configured. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>Second call to Configure() with DnsConfigData. To reconfigure the instance the caller must call Configure() with NULL first to return driver to unconfigured state.</td></tr>
  </table>
  </dd>
</dl>
<p>Host name to host address translation.</p>
<p>The HostNameToIp () function is used to translate the host name to host IP address. A type A query is used to get the one or more IP addresses for this host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HostName</td><td>Host name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to translate host name to host address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. HostName is NULL. HostName string is unsupported format. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This instance has not been started.</td></tr>
  </table>
  </dd>
</dl>
<p>IPv4 address to host name translation also known as Reverse DNS lookup.</p>
<p>The IpToHostName() function is used to translate the host address to host name. A type PTR query is used to get the primary name of the host. Support of this function is optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IpAddress</td><td>Ip Address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to translate host address to host name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. IpAddress is not valid IP address . </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>This Token is being used in another DNS session. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve arbitrary information from the DNS server.</p>
<p>This GeneralLookup() function retrieves arbitrary information from the DNS. The caller supplies a QNAME, QTYPE, and QCLASS, and all of the matching RRs are returned. All RR content (e.g., TTL) was returned. The caller need parse the returned RR to get required information. The function is optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QName</td><td>Pointer to Query Name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QType</td><td>Query Type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QClass</td><td>Query Name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Point to the completion token to retrieve arbitrary information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported. Or the requested QType is not supported </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. Token is NULL. Token.Event is NULL. QName is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>There's no source address is available for use. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>This Token is being used in another DNS session. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Failed to allocate needed resources.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is to update the DNS Cache.</p>
<p>The UpdateDnsCache() function is used to add/delete/modify DNS cache entry. DNS cache can be normally dynamically updated after the DNS resolve succeeds. This function provided capability to manually add/delete/modify the DNS cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeleteFlag</td><td>If FALSE, this function is to add one entry to the DNS Cahce. If TRUE, this function will delete matching DNS Cache entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Override</td><td>If TRUE, the maching DNS cache entry will be overwritten with the supplied parameter. If FALSE, EFI_ACCESS_DENIED will be returned if the entry to be added is already existed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DnsCacheEntry</td><td>Pointer to DNS Cache entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. DnsCacheEntry.HostName is NULL. DnsCacheEntry.IpAddress is NULL. DnsCacheEntry.Timeout is zero. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The DNS cache entry already exists and Override is not TRUE.</td></tr>
  </table>
  </dd>
</dl>
<p>Polls for incoming data packets and processes outgoing data packets.</p>
<p>The Poll() function can be used by network drivers and applications to increase the rate that data packets are moved between the communications device and the transmit and receive queues. In some systems, the periodic timer event in the managed network driver may not poll the underlying communications device fast enough to transmit and/or receive all data packets without missing incoming packets or dropping outgoing packets. Drivers and applications that are experiencing packet loss should try calling the Poll() function more often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI DNS Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system or network error occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Data was dropped out of the transmit and/or receive queue. Consider increasing the polling rate.</td></tr>
  </table>
  </dd>
</dl>
<p>Abort an asynchronous DNS operation, including translation between IP and Host, and general look up behavior.</p>
<p>The Cancel() function is used to abort a pending resolution request. After calling this function, Token.Status will be set to EFI_ABORTED and then Token.Event will be signaled. If the token is not in one of the queues, which usually means that the asynchronous operation has completed, this function will not signal the token and EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_DNS4_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Token</td><td>Pointer to a token that has been issued by <a class="el" href="struct___e_f_i___d_n_s4___p_r_o_t_o_c_o_l.html#a0922b5b85674f5c86fc525a93a8df9db">EFI_DNS4_PROTOCOL.HostNameToIp</a> (), <a class="el" href="struct___e_f_i___d_n_s4___p_r_o_t_o_c_o_l.html#a393fbab3879d778d66acd1a095158653">EFI_DNS4_PROTOCOL.IpToHostName()</a> or EFI_DNS4_PROTOCOL.GeneralLookup(). If NULL, all pending tokens are aborted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Incoming or outgoing data was processed. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI DNS4 Protocol instance has not been started. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>When Token is not NULL, and the asynchronous DNS operation was not found in the transmit queue. It was either completed or was not issued by HostNameToIp(), IpToHostName() or GeneralLookup().</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TREE_PROTOCOL Get Event Log function call allows a caller to retrieve the address of a given event log and its last entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EventLogFormat</td><td>The type of the event log for which the information is requested. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogLocation</td><td>A pointer to the memory address of the event log. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogLastEntry</td><td>If the Event Log contains more than one entry, this is a pointer to the address of the start of the last entry in the event log in memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogTruncated</td><td>If the Event Log is missing at least one entry because an event would have exceeded the area allocated for events, this value is set to TRUE. Otherwise, the value will be FALSE and the Event Log will be complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect (e.g. asking for an event log whose format is not supported).</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TREE_PROTOCOL HashLogExtendEvent function call provides callers with an opportunity to extend and optionally log events without requiring knowledge of actual TPM commands. The extend operation will occur even if this function cannot create an event log entry (e.g. due to the event log being full).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Bitmap providing additional information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataToHash</td><td>Physical address of the start of the data buffer to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataToHashLen</td><td>The length in bytes of the buffer referenced by DataToHash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>Pointer to data buffer containing information about the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was unsuccessful. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The extend operation occurred, but the event could not be written to one or more event logs. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The PE/COFF image type is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>This service enables the sending of commands to the TrEE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputParameterBlockSize</td><td>Size of the TrEE input parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputParameterBlock</td><td>Pointer to the TrEE input parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputParameterBlockSize</td><td>Size of the TrEE output parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputParameterBlock</td><td>Pointer to the TrEE output parameter block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The command byte stream was successfully sent to the device and a response was successfully received. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was not successfully sent to the device or a response was not successfully received from the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The output parameter block is too small.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes data to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_FILE_PROTOCOL instance that is the file handle to write data to. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was read successfully. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Writes to open directory files are not supported. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no medium. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An attempt was made to write to a deleted file. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The file or medium is write-protected. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file was opened read only. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The volume is full. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Unable to queue the request due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Flushes all modified data associated with a file to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_FILE_PROTOCOL instance that is the file handle to flush. </td></tr>
    <tr><td class="paramname">Token</td><td>A pointer to the token associated with the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Event is NULL (blocking I/O): The data was read successfully. If Event is not NULL (asynchronous I/O): The request was successfully queued for processing. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no medium. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The file or medium is write-protected. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The file was opened read-only. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The volume is full. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Unable to queue the request due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the configuration data for the EFI IPv4 network stack running on the communication device this EFI IPv4 Configuration II Protocol instance manages.</p>
<p>This function returns the configuration data of type DataType for the EFI IPv4 network stack running on the communication device this EFI IPv4 Configuration II Protocol instance manages. The caller is responsible for allocating the buffer usedto return the specified configuration data and the required size will be returned to the caller if the size of the buffer is too small. EFI_NOT_READY is returned if the specified configuration data is not ready due to an already in progress asynchronous configuration process. The caller can call RegisterDataNotify() to register an event on the specified configuration data. Once the asynchronous configuration process is finished, the event will be signaled and a subsequent GetData() call will return the specified configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IP4_CONFIG2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data to get. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DataSize</td><td>On input, in bytes, the size of Data. On output, in bytes, the size of buffer required to store the specified configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>The data buffer in which the configuration data is returned. The type of the data buffer is associated with the DataType. Ignored if DataSize is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified configuration data is got successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the followings are TRUE: This is NULL. DataSize is NULL. Data is NULL if *DataSizeis not zero. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The size of Data is too small for the specified configuration data and the required size is returned in DataSize. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The specified configuration data is not ready due to an already in progress asynchronous configuration process. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified configuration data is not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Register an event that is to be signaled whenever a configuration process on the specified configuration data is done.</p>
<p>This function registers an event that is to be signaled whenever a configuration process on the specified configuration data is done. An event can be registered for different DataType simultaneously and the caller is responsible for determining which type of configuration data causes the signaling of the event in such case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IP4_CONFIG2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data to unregister the event for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>The event to register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The notification event for the specified configuration data is registered. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The configuration data type specified by DataType is not supported. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The Event is already registered for the DataType.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove a previously registered event for the specified configuration data.</p>
<p>This function removes a previously registeredevent for the specified configuration data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_IP4_CONFIG2_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataType</td><td>The type of data to remove the previously registered event for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>The event to unregister.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event registered for the specified configuration data is removed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL or Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The Eventhas not been registered for the specified DataType.</td></tr>
  </table>
  </dd>
</dl>
<p>This function accepts a &lt;MultiKeywordRequest&gt; formatted string, finds the underlying keyword owners, creates a &lt;MultiConfigRequest&gt; string from it and forwards it to the EFI_HII_ROUTING_PROTOCOL.ExtractConfig function.</p>
<p>If there is an issue in resolving the contents of the KeywordString, then the function returns an EFI_INVALID_PARAMETER and also set the Progress and ProgressErr with the appropriate information about where the issue occurred and additional data about the nature of the issue.</p>
<p>In the case when KeywordString is NULL, or contains multiple keywords, or when EFI_NOT_FOUND is generated while processing the keyword elements, the Results string contains values returned for all keywords processed prior to the keyword generating the error but no values for the keyword with error or any following keywords.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Pointer to the EFI_KEYWORD_HANDLER _PROTOCOL instance.</td></tr>
    <tr><td class="paramname">NameSpaceId</td><td>A null-terminated string containing the platform configuration language to search through in the system. If a NULL is passed in, then it is assumed that any platform configuration language with the prefix of "x-UEFI-" are searched.</td></tr>
    <tr><td class="paramname">KeywordString</td><td>A null-terminated string in &lt;MultiKeywordRequest&gt; format. If a NULL is passed in the KeywordString field, all of the known keywords in the system for the NameSpaceId specified are returned in the Results field.</td></tr>
    <tr><td class="paramname">Progress</td><td>On return, points to a character in the KeywordString. Points to the string's NULL terminator if the request was successful. Points to the most recent '&amp;' before the first failing name / value pair (or the beginning of the string if the failure is in the first name / value pair) if the request was not successful.</td></tr>
    <tr><td class="paramname">ProgressErr</td><td>If during the processing of the KeywordString there was a failure, this parameter gives additional information about the possible source of the problem. See the definitions in SetData() for valid value definitions.</td></tr>
    <tr><td class="paramname">Results</td><td>A null-terminated string in &lt;MultiKeywordResp&gt; format is returned which has all the values filled in for the keywords in the KeywordString. This is a callee-allocated field, and must be freed by the caller after being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified action was completed successfully.</td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following are TRUE: 1.Progress, ProgressErr, or Results is NULL. 2.Parsing of the KeywordString resulted in an error. See Progress and ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>An element of the KeywordString was not found. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The NamespaceId specified was not found. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required system resources could not be allocated. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The action violated system policy. See ProgressErr for more data.</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An unexpected system error occurred. See ProgressErr for more data.</td></tr>
  </table>
  </dd>
</dl>
<p>Produces and returns an RNG value using either the default or specified RNG algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_RNG_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RNGAlgorithm</td><td>A pointer to the EFI_RNG_ALGORITHM that identifies the RNG algorithm to use. May be NULL in which case the function will use its default RNG algorithm. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RNGValueLength</td><td>The length in bytes of the memory buffer pointed to by RNGValue. The driver shall return exactly this numbers of bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RNGValue</td><td>A caller-allocated memory buffer filled by the driver with the resulting RNG value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The RNG value was returned successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The algorithm specified by RNGAlgorithm is not supported by this driver. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An RNG value could not be retrieved due to a hardware or firmware error. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>There is not enough random data available to satisfy the length requested by RNGValueLength. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RNGValue is NULL or RNGValueLength is zero.</td></tr>
  </table>
  </dd>
</dl>
<p>This function releases a connection previously taken by SCardConnect.</p>
<p>The SCardDisconnect function releases the lock previously taken by SCardConnect. In case the smart card has been removed before this call, thisfunction returns EFI_SUCCESS. If there is no previous call to SCardConnect, this function returns EFI_SUCCESS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CardAction</td><td>Codes for card action.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CardAction value is unknown. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Reader does not support Eject card feature (disconnect was not performed). </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves some basic information about the smart card and reader.</p>
<p>The SCardStatusfunction retrieves basic reader and card information.</p>
<p>If ReaderName, State, CardProtocolor Atris NULL, the function does not fail but does not fill in such variables.</p>
<p>If EFI_SUCCESS is not returned, ReaderName and Atr contents shall not be considered as valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReaderName</td><td>A pointer to a NULL terminated string that will contain the reader name. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ReaderNameLength</td><td>On input, a pointer to the variablethat holds the maximal size, in bytes,of ReaderName. On output, the required size, in bytes, for ReaderName. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">State</td><td>Current state of the smart card reader. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CardProtocol</td><td>Current protocol used to communicate with the smart card. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Atr</td><td>A pointer to retrieve the ATR of the smart card. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">AtrLength</td><td>On input, a pointer to hold the maximum size, in bytes, of Atr(usually 33). On output, the required size, inbytes, for the smart card ATR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ReaderName is not NULL but ReaderNameLength is NULL </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Atr is not NULL but AtrLength is NULL </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>ReaderNameLength is not big enough to hold the reader name. ReaderNameLength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>AtrLength is not big enough to hold the ATR. AtrLength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sends a command to the card or reader and returns its response.</p>
<p>The protocol to use to communicate with the smart card has been selected through SCardConnectcall.</p>
<p>In case RAPDULength indicates a buffer too small to holdthe response APDU, the function fails with EFI_BUFFER_TOO_SMALL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_USBFN_IO_PROTOCOLinstance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CAPDU</td><td>A pointer to a byte array thatcontains the Command APDU to send to the smart card or reader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CAPDULength</td><td>Command APDU size, in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RAPDU</td><td>A pointer to a byte array that will contain the Response APDU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">RAPDULength</td><td>On input, the maximum size, inbytes, of the Response APDU. On output, the size, in bytes, of the Response APDU.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CAPDU is NULL or CAPDULength is 0. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>RAPDULength is not big enough to hold the response APDU. RAPDULength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no card in the reader. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Card is not powered. </td></tr>
    <tr><td class="paramname">EFI_PROTOCOL_ERROR</td><td>A protocol error has occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>The reader did not respond. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>A communication with the reader/card is already pending. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides direct access to the reader.</p>
<p>This function gives direct control to send commands to the driver or the reader. The ControlCode to use is vendor dependant; the only standard code defined is the one to get PC/SC part 10 features.</p>
<p>InBuffer and Outbuffer may be NULL when ControlCode operation does not require them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControlCode</td><td>The control code for the operation to perform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InBuffer</td><td>A pointer to the input parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InBufferLength</td><td>Size, in bytes, of input parameters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OutBuffer</td><td>A pointer to the output parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutBufferLength</td><td>On input, maximal size, in bytes, to store output parameters. On output, the size, in bytes, of output parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ControlCode requires input parameters but: InBuffer is NULL or InBufferLenth is NULL or InBuffer is not NULL but InBufferLenth is less than expected. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>OutBuffer is not NULL but OutBufferLength is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>ControlCode is not supported. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>OutBufferLength is not big enough to hold the output parameters. OutBufferLength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no card in the reader and the control code specified requires one. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>ControlCode requires a powered card to operate. </td></tr>
    <tr><td class="paramname">EFI_PROTOCOL_ERROR</td><td>A protocol error has occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>The reader did not respond. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>A communication with the reader/card is already pending. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves a reader or smart card attribute.</p>
<p>Possibly supported attrib values are listed in "PC/SC specification, Part 3:
Requirements for PC-Connected Interface Devices".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Attrib</td><td>Identifier for the attribute to retrieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OutBuffer</td><td>A pointer to a buffer that will contain attribute data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutBufferLength</td><td>On input, maximal size, in bytes, to store attribute data. On output, the size, in bytes, of attribute data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>OutBuffer is NULL or OutBufferLength is 0. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>OutBufferLength is not big enough to hold the output parameters. OutBufferLength has been updated to the required value. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Attribis not supported </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no card in the reader and Attrib value requires one. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Attrib requires a powered card to operate. </td></tr>
    <tr><td class="paramname">EFI_PROTOCOL_ERROR</td><td>A protocol error has occurred. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>The reader did not respond. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Any other error condition, typically a reader removal.</td></tr>
  </table>
  </dd>
</dl>
<p>Update the SPI peripheral associated with this SPI 10 instance.</p>
<p>Support socketed SPI parts by allowing the SPI peripheral driver to replace the SPI peripheral after the connection is made. An example use is socketed SPI NOR flash parts, where the size and parameters change depending upon device is in the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_SPI_IO_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SpiPeripheral</td><td>Pointer to an EFI_SPI_PERIPHERAL structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SPI peripheral was updated successfully </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The SpiPeripheral value is NULL, or the SpiPeripheral-&gt;SpiBus is NULL, or the SpiP eripheral - &gt;SpiBus pointing at wrong bus, or the SpiP eripheral - &gt;SpiPart is NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Read BufferSize bytes from Lba into Buffer.</p>
<p>This function reads the requested number of blocks from the device. All the blocks are read, or an error is returned. If EFI_DEVICE_ERROR, EFI_NO_MEDIA,_or EFI_MEDIA_CHANGED is returned and non-blocking I/O is being used, the Event associated with this request will not be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>Id of the media, changes every time the media is replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Lba</td><td>The starting Logical Block Address to read from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>Size of Buffer, must be a multiple of device block size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A pointer to the destination buffer for the data. The caller is responsible for either having implicit or explicit ownership of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The read request was queued if Token-&gt;Event is not NULL.The data was read correctly from the device if the Token-&gt;Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the read. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The BufferSize parameter is not a multiple of the intrinsic block size of the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The read request contains LBAs that are not valid, or the buffer is not on proper alignment. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Write BufferSize bytes from Lba into Buffer.</p>
<p>This function writes the requested number of blocks to the device. All blocks are written, or an error is returned.If EFI_DEVICE_ERROR, EFI_NO_MEDIA, EFI_WRITE_PROTECTED or EFI_MEDIA_CHANGED is returned and non-blocking I/O is being used, the Event associated with this request will not be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MediaId</td><td>The media ID that the write request is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Lba</td><td>The starting logical block address to be written. The caller is responsible for writing to only legitimate locations. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferSize</td><td>Size of Buffer, must be a multiple of device block size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>A pointer to the source buffer for the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The write request was queued if Event is not NULL. The data was written correctly to the device if the Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device can not be written to. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHNAGED</td><td>The MediaId does not matched the current device. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while performing the write. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The Buffer was not a multiple of the block size of the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The write request contains LBAs that are not valid, or the buffer is not on proper alignment. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Flush the Block Device.</p>
<p>If EFI_DEVICE_ERROR, EFI_NO_MEDIA,_EFI_WRITE_PROTECTED or EFI_MEDIA_CHANGED is returned and non-blocking I/O is being used, the Event associated with this request will not be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Token</td><td>A pointer to the token associated with the transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The flush request was queued if Event is not NULL. All outstanding data was written correctly to the device if the Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error while writting back the data. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The device cannot be written to. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Receive HCI event packet in non-blocking way.</p>
<p>The AsyncReceiveEvent() function receives HCI event packet in non-blocking way. Data in Callback function holds the whole HCI event packet, including EventCode, parameter length, and parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_HC_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IsNewTransfer</td><td>If TRUE, a new transfer will be submitted. If FALSE, the request is deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PollingInterval</td><td>Indicates the periodic rate, in milliseconds, that the transfer is to be executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>Specifies the length, in bytes, of the data to be received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>The callback function. This function is called if the asynchronous transfer is completed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The HCI asynchronous receive request is submitted successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: DataLength is 0. If IsNewTransfer is TRUE, and an asynchronous receive request already exists.</td></tr>
  </table>
  </dd>
</dl>
<p>Receive HCI ACL data packet in non-blocking way.</p>
<p>The AsyncReceiveACLData() function receives HCI ACL data packet in non-blocking way. Data in Callback holds the whole HCI ACL data packet, including Handle, PB flag, BC flag, data length, and data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_HC_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IsNewTransfer</td><td>If TRUE, a new transfer will be submitted. If FALSE, the request is deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PollingInterval</td><td>Indicates the periodic rate, in milliseconds, that the transfer is to be executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>Specifies the length, in bytes, of the data to be received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>The callback function. This function is called if the asynchronous transfer is completed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The HCI asynchronous receive request is submitted successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: DataLength is 0. If IsNewTransfer is TRUE, and an asynchronous receive request already exists.</td></tr>
  </table>
  </dd>
</dl>
<p>Receive HCI SCO data packet in non-blocking way.</p>
<p>The AsyncReceiveSCOData() function receives HCI SCO data packet in non-blocking way. Data in Callback holds the whole HCI SCO data packet, including ConnectionHandle, PacketStatus flag, data length, and data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_BLUETOOTH_HC_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IsNewTransfer</td><td>If TRUE, a new transfer will be submitted. If FALSE, the request is deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PollingInterval</td><td>Indicates the periodic rate, in milliseconds, that the transfer is to be executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>Specifies the length, in bytes, of the data to be received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>The callback function. This function is called if the asynchronous transfer is completed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Data passed into Callback function. This is optional parameter and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The HCI asynchronous receive request is submitted successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: DataLength is 0. If IsNewTransfer is TRUE, and an asynchronous receive request already exists.</td></tr>
  </table>
  </dd>
</dl>
<p>Register client information with the supported KMS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The client information has been accepted by the KMS. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>No connection to the KMS is available. </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>There was no response from the device or the key server. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the KMS. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required resources were not available to perform the function. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The KMS does not support the use of client identifiers.</td></tr>
  </table>
  </dd>
</dl>
<p>Request that the KMS generate one or more new keys and associate them with key identifiers. The key value(s) is returned to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors to be processed by this operation. On return, this number will be updated with the number of key descriptors successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys to be generated. On input, the KeyIdentifierSize and the KeyIdentifier may specify an identifier to be used for the key, but this is not required. The KeyFormat field must specify a key format <a class="el" href="struct_g_u_i_d.html">GUID</a> reported as supported by the KeyFormats field of the EFI_KMS_PROTOCOL. The value for this field in the first key descriptor will be considered the default value for subsequent key descriptors requested in this operation if those key descriptors have a NULL <a class="el" href="struct_g_u_i_d.html">GUID</a> in the key format field. On output, the KeyIdentifierSize and KeyIdentifier fields will specify an identifier for the key which will be either the original identifier if one was provided, or an identifier generated either by the KMS or the KMS protocol implementation. The KeyFormat field will be updated with the <a class="el" href="struct_g_u_i_d.html">GUID</a> used to generate the key if it was a NULL <a class="el" href="struct_g_u_i_d.html">GUID</a>, and the KeyValue field will contain a pointer to memory containing the key value for the generated key. Memory for both the KeyIdentifier and the KeyValue fields will be allocated with the BOOT_SERVICES_DATA type and must be freed by the caller when it is no longer needed. Also, the KeyStatus field must reflect the result of the request relative to that key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully generated and retrieved all requested keys. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>This function is not supported by the KMS. &ndash;OR&ndash; One (or more) of the key requests submitted is not supported by the KMS. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Required resources were not available to perform the function. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either no id was provided or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>An error occurred when attempting to access the KMS. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or Keys is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures could not be processed properly. KeyDescriptorCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve an existing key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors to be processed by this operation. On return, this number will be updated with the number of key descriptors successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys to be retrieved from the KMS. On input, the KeyIdentifierSize and the KeyIdentifier must specify an identifier to be used to retrieve a specific key. All other fields in the descriptor should be NULL. On output, the KeyIdentifierSize and KeyIdentifier fields will be unchanged, while the KeyFormat and KeyValue fields will be updated values associated with this key identifier. Memory for the KeyValue field will be allocated with the BOOT_SERVICES_DATA type and must be freed by the caller when it is no longer needed. Also, the KeyStatus field will reflect the result of the request relative to the individual key descriptor. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully retrieved all requested keys. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate resources for the method processing. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple keys are associated with a single identifier, and the KeyValue buffer does not contain enough structures (KeyDescriptorCount) to contain all the key data, then the available structures will be filled and KeyDescriptorCount will be updated to indicate the number of keys which could not be processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or Keys is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures could not be processed properly. KeyDescriptorCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Add a new key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors to be processed by this operation. On normal return, this number will be updated with the number of key descriptors successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys to be added. On input, the KeyId field for first key must contain valid identifier data to be used for adding a key to the KMS. The values for these fields in this key definition will be considered default values for subsequent keys requested in this operation. A value of 0 in any subsequent KeyId field will be replaced with the current default value. The KeyFormat and KeyValue fields for each key to be added must contain consistent values to be associated with the given KeyId. On return, the KeyStatus field will reflect the result of the operation for each key request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully added all requested keys. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple keys are associated with a single identifier, and the KeyValue buffer does not contain enough structures (KeyDescriptorCount) to contain all the key data, then the available structures will be filled and KeyDescriptorCount will be updated to indicate the number of keys which could not be processed </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or Keys is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures could not be processed properly. KeyDescriptorCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete an existing key from the KMS database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors to be processed by this operation. On normal return, this number will be updated with the number of key descriptors successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys to be deleted. On input, the KeyId field for first key must contain valid identifier data to be used for adding a key to the KMS. The values for these fields in this key definition will be considered default values for subsequent keys requested in this operation. A value of 0 in any subsequent KeyId field will be replaced with the current default value. The KeyFormat and KeyValue fields are ignored, but should be 0. On return, the KeyStatus field will reflect the result of the operation for each key request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully deleted all requested keys. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or Keys is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures could not be processed properly. KeyDescriptorCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Get one or more attributes associated with a specified key identifier. If none are found, the returned attributes count contains a value of zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifierSize</td><td>Pointer to the size in bytes of the KeyIdentifier variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifier</td><td>Pointer to the key identifier associated with this key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributesCount</td><td>Pointer to the number of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures associated with the Key identifier. If none are found, the count value is zero on return. On input this value reflects the number of KeyAttributes that may be returned. On output, the value reflects the number of completed KeyAttributes structures found. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributes</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures associated with the Key Identifier. On input, the fields in the structure should be NULL. On output, the attribute fields will have updated values for attributes associated with this key identifier. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully retrieved all key attributes. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate resources for the method processing. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key attribute request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple key attributes are associated with a single identifier, and the KeyAttributes buffer does not contain enough structures (KeyAttributesCount) to contain all the key attributes data, then the available structures will be filled and KeyAttributesCount will be updated to indicate the number of key attributes which could not be processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key attribute request(s) (i.e. key attribute status for each) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyIdentifierSize is NULL , or KeyIdentifier is NULL, or KeyAttributes is NULL, or KeyAttributesSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The KeyIdentifier could not be found. KeyAttributesCount contains zero. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Add one or more attributes to a key specified by a key identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifierSize</td><td>Pointer to the size in bytes of the KeyIdentifier variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifier</td><td>Pointer to the key identifier associated with this key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributesCount</td><td>Pointer to the number of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures to associate with the Key. On normal returns, this number will be updated with the number of key attributes successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributes</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures providing the attribute information to associate with the key. On input, the values for the fields in the structure are completely filled in. On return the KeyAttributeStatus field will reflect the result of the operation for each key attribute request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully added all requested key attributes. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key attribute request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple keys attributes are associated with a single key identifier, and the attributes buffer does not contain enough structures (KeyAttributesCount) to contain all the data, then the available structures will be filled and KeyAttributesCount will be updated to indicate the number of key attributes which could not be processed. The status of each key attribute is also updated indicating success or failure for that attribute in case there are other errors for those attributes that could be processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key attribute request(s) (i.e. key attribute status for each) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyAttributesCount is NULL, or KeyAttributes is NULL, or KeyIdentifierSize is NULL, or KeyIdentifer is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The KeyIdentifier could not be found. On return the KeyAttributesCount contains the number of attributes processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete attributes to a key specified by a key identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifierSize</td><td>Pointer to the size in bytes of the KeyIdentifier variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KeyIdentifier</td><td>Pointer to the key identifier associated with this key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributesCount</td><td>Pointer to the number of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures to associate with the Key. On input, the count value is one or more. On normal returns, this number will be updated with the number of key attributes successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributes</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures providing the attribute information to associate with the key. On input, the values for the fields in the structure are completely filled in. On return the KeyAttributeStatus field will reflect the result of the operation for each key attribute request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully deleted all requested key attributes. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key attribute request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key attribute request(s) (i.e. key attribute status for each) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyAttributesCount is NULL, or KeyAttributes is NULL, or KeyIdentifierSize is NULL, or KeyIdentifer is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The KeyIdentifier could not be found or the attribute could not be found. On return the KeyAttributesCount contains the number of attributes processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve one or more key that has matched all of the specified key attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to the EFI_KMS_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Client</td><td>Pointer to a valid <a class="el" href="struct_e_f_i___k_m_s___c_l_i_e_n_t___i_n_f_o.html">EFI_KMS_CLIENT_INFO</a> structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributesCount</td><td>Pointer to a count of the number of key attribute structures that must be matched for each returned key descriptor. On input the count value is one or more. On normal returns, this number will be updated with the number of key attributes successfully processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyAttributes</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structure to search for. On input, the values for the fields in the structure are completely filled in. On return the KeyAttributeStatus field will reflect the result of the operation for each key attribute request. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptorCount</td><td>Pointer to a count of the number of key descriptors matched by this operation. On entry, this number will be zero. On return, this number will be updated to the number of key descriptors successfully found. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">KeyDescriptors</td><td>Pointer to an array of <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structures which describe the keys from the KMS having the KeyAttribute(s) specified. On input, this pointer will be NULL. On output, the array will contain an <a class="el" href="struct_e_f_i___k_m_s___k_e_y___d_e_s_c_r_i_p_t_o_r.html">EFI_KMS_KEY_DESCRIPTOR</a> structure for each key meeting the search criteria. Memory for the array and all KeyValue fields will be allocated with the EfiBootServicesData type and must be freed by the caller when it is no longer needed. Also, the KeyStatus field of each descriptor will reflect the result of the request relative to that key descriptor. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientDataSize</td><td>Pointer to the size, in bytes, of an arbitrary block of data specified by the ClientData parameter. This parameter may be NULL, in which case the ClientData parameter will be ignored and no data will be transferred to or from the KMS. If the parameter is not NULL, then ClientData must be a valid pointer. If the value pointed to is 0, no data will be transferred to the KMS, but data may be returned by the KMS. For all non-zero values *ClientData will be transferred to the KMS, which may also return data to the caller. In all cases, the value upon return to the caller will be the size of the data block returned to the caller, which will be zero if no data is returned from the KMS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ClientData</td><td>Pointer to a pointer to an arbitrary block of data of ClientDataSize that is to be passed directly to the KMS if it supports the use of client data. This parameter may be NULL if and only if the ClientDataSize parameter is also NULL. Upon return to the caller, *ClientData points to a block of data of ClientDataSize that was returned from the KMS. If the returned value for *ClientDataSize is zero, then the returned value for *ClientData must be NULL and should be ignored by the caller. The KMS protocol consumer is responsible for freeing all valid buffers used for client data regardless of whether they are allocated by the caller for input to the function or by the implementation for output back to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Successfully retrieved all requested keys. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Could not allocate required resources. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>Timed out waiting for device or key server. Check individual key attribute request(s) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If multiple keys are associated with the attribute(s), and the KeyValue buffer does not contain enough structures (KeyDescriptorCount) to contain all the key data, then the available structures will be filled and KeyDescriptorCount will be updated to indicate the number of keys which could not be processed. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Access was denied by the device or the key server; OR a ClientId is required by the server and either none or an invalid id was provided. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Device or key server error. Check individual key attribute request(s) (i.e. key attribute status for each) to see which ones may have been processed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>This is NULL, ClientId is required but it is NULL, KeyDescriptorCount is NULL, or KeyDescriptors is NULL or KeyAttributes is NULL, or KeyAttributesCount is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>One or more <a class="el" href="struct_e_f_i___k_m_s___k_e_y___a_t_t_r_i_b_u_t_e.html">EFI_KMS_KEY_ATTRIBUTE</a> structures could not be processed properly. KeyAttributeCount contains the number of structures which were successfully processed. Individual structures will reflect the status of the processing for that structure. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The implementation/KMS does not support this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees the file list.</p>
<p>This function cleans up the file list and any related data structures. It has no impact on the files themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileList</td><td>The file list to free. Type <a class="el" href="struct_e_f_i___s_h_e_l_l___f_i_l_e___i_n_f_o.html">EFI_SHELL_FILE_INFO</a> is defined in OpenFileList().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Free the file list successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the name of the device specified by the device handle.</p>
<p>This function gets the user-readable name of the device specified by the device handle. If no user-readable name could be generated, then *BestDeviceName will be NULL and EFI_NOT_FOUND will be returned.</p>
<p>If EFI_DEVICE_NAME_USE_COMPONENT_NAME is set, then the function will return the device's name using the EFI_COMPONENT_NAME2_PROTOCOL, if present on DeviceHandle.</p>
<p>If EFI_DEVICE_NAME_USE_DEVICE_PATH is set, then the function will return the device's name using the <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a>, if present on DeviceHandle. If both EFI_DEVICE_NAME_USE_COMPONENT_NAME and EFI_DEVICE_NAME_USE_DEVICE_PATH are set, then EFI_DEVICE_NAME_USE_COMPONENT_NAME will have higher priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceHandle</td><td>The handle of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Determines the possible sources of component names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Language</td><td>A pointer to the language specified for the device name, in the same format as described in the UEFI specification, Appendix M. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BestDeviceName</td><td>On return, points to the callee-allocated NULL- terminated name of the device. If no device name could be found, points to NULL. The name must be freed by the caller...</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Get the name successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Fail to get the device name.</td></tr>
  </table>
  </dd>
</dl>
<p>Return help information about a specific command.</p>
<p>This function returns the help information for the specified command. The help text can be internal to the shell or can be from a UEFI Shell manual page.</p>
<p>If Sections is specified, then each section name listed will be compared in a casesensitive manner, to the section names described in Appendix B. If the section exists, it will be appended to the returned help text. If the section does not exist, no information will be returned. If Sections is NULL, then all help text information available will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Command</td><td>Points to the NULL-terminated UEFI Shell command name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Sections</td><td>Points to the NULL-terminated comma-delimited section names to return. If NULL, then all sections will be returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HelpText</td><td>On return, points to a callee-allocated buffer containing all specified help text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The help text was returned. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The necessary buffer could not be allocated to hold the returned help text. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HelpText is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There is no help text available for Command.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens a file or a directory by file name.</p>
<p>This function opens the specified file in the specified OpenMode and returns a file handle. If the file name begins with '&gt;v', then the file handle which is returned refers to the shell environment variable with the specified name. If the shell environment variable exists, is non-volatile and the OpenMode indicates EFI_FILE_MODE_WRITE, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file name is '&gt;i', then the file handle which is returned refers to the standard input. If the OpenMode indicates EFI_FILE_MODE_WRITE, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file name is '&gt;o', then the file handle which is returned refers to the standard output. If the OpenMode indicates EFI_FILE_MODE_READ, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file name is '&gt;e', then the file handle which is returned refers to the standard error. If the OpenMode indicates EFI_FILE_MODE_READ, then EFI_INVALID_PARAMETER is returned.</p>
<p>If the file name is 'NUL', then the file handle that is returned refers to the standard NUL file. If the OpenMode indicates EFI_FILE_MODE_READ, then EFI_INVALID_PARAMETER is returned.</p>
<p>If return EFI_SUCCESS, the FileHandle is the opened file's handle, else, the FileHandle is NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileName</td><td>Points to the NULL-terminated UCS-2 encoded file name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FileHandle</td><td>On return, points to the file handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OpenMode</td><td>File open mode. Either EFI_FILE_MODE_READ or EFI_FILE_MODE_WRITE from section 12.4 of the UEFI Specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The file was opened. FileHandle has the opened file's handle. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One of the parameters has an invalid value. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Could not open the file path. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The specified file could not be found on the device or the file system could not be found on the device. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no medium. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The device has a different medium in it or the medium is no longer supported. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error or can't get the file path according the FileName. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>An attempt was made to create a file, or open a file for write when the media is write-protected. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The service denied access to the file. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Not enough resources were available to open the file. FileHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The volume is full. FileHandle is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens the files that match the path specified.</p>
<p>This function opens all of the files specified by Path. Wildcards are processed according to the rules specified in UEFI Shell 2.0 spec section 3.7.1. Each matching file has an <a class="el" href="struct_e_f_i___s_h_e_l_l___f_i_l_e___i_n_f_o.html">EFI_SHELL_FILE_INFO</a> structure created in a linked list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Path</td><td>A pointer to the path string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OpenMode</td><td>Specifies the mode used to open each file, EFI_FILE_MODE_READ or EFI_FILE_MODE_WRITE. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FileList</td><td>Points to the start of a list of files opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Create the file list successfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Can't create the file list.</dd></dl>
<p>Reads data from the file.</p>
<p>If FileHandle is not a directory, the function reads the requested number of bytes from the file at the file's current position and returns them in Buffer. If the read goes beyond the end of the file, the read length is truncated to the end of the file. The file's current position is increased by the number of bytes returned. If FileHandle is a directory, then an error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileHandle</td><td>The opened file handle for read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ReadSize</td><td>On input, the size of Buffer, in bytes. On output, the amount of data read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Buffer</td><td>The buffer in which data is read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Data was read. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>The device has no media. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device reported an error. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_CORRUPTED</td><td>The file system structures are corrupted. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TO_SMALL</td><td>Buffer is too small. ReadSize contains required size.</td></tr>
  </table>
  </dd>
</dl>
<p>Deletes the duplicate file names files in the given file list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileList</td><td>A pointer to the first entry in the file list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Always success.</td></tr>
  </table>
  </dd>
</dl>
<p>Changes the current directory on the specified device.</p>
<p>If the FileSystem is NULL, and the directory Dir does not contain a file system's mapped name, this function changes the current working directory. If FileSystem is NULL and the directory Dir contains a mapped name, then the current file system and the current directory on that file system are changed.</p>
<p>If FileSystem is not NULL, and Dir is NULL, then this changes the current working file system.</p>
<p>If FileSystem is not NULL and Dir is not NULL, then this function changes the current directory on the specified file system.</p>
<p>If the current working directory or the current working file system is changed then the cwd% environment variable will be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FileSystem</td><td>A pointer to the file system's mapped name. If NULL, then the current working directory is changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dir</td><td>Points to the NULL-terminated directory on the device specified by FileSystem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>Current directory does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current directory.</dd></dl>
<p>Sets the environment variable.</p>
<p>This function changes the current value of the specified environment variable. If the environment variable exists and the Value is an empty string, then the environment variable is deleted. If the environment variable exists and the Value is not an empty string, then the value of the environment variable is changed. If the environment variable does not exist and the Value is an empty string, there is no action. If the environment variable does not exist and the Value is a non-empty string, then the environment variable is created and assigned the specified value.</p>
<p>For a description of volatile and non-volatile environment variables, see UEFI Shell 2.0 specification section 3.6.1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Name</td><td>Points to the NULL-terminated environment variable name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Value</td><td>Points to the NULL-terminated environment variable value. If the value is an empty string then the environment variable is deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Volatile</td><td>Indicates whether the variable is non-volatile (FALSE) or volatile (TRUE).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The environment variable was successfully updated.</td></tr>
  </table>
  </dd>
</dl>
<p>Set up the clock generator to produce the correct clock frequency, phase and polarity for a SPI chip.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine updates the clock generator to generate the correct frequency and polarity for the SPI clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SpiPeripheral</td><td>Pointer to a EFI_SPI_PERIPHERAL data structure from which the routine can access the ClockParameter, ClockPhase and ClockPolarity fields. The routine also has access to the names for the SPI bus and chip which can be used during debugging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ClockHz</td><td>Pointer to the requested clock frequency. The clock generator will choose a supported clock frequency which is less then or equal to this value. Specify zero to turn the clock generator off. The actual clock frequency supported by the clock generator will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The clock was set up successfully </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The SPI controller was not able to support the frequency requested by CLockHz</td></tr>
  </table>
  </dd>
</dl>
<p>Checks if the input string matches to the regular expression pattern.</p>
<p>This A pointer to the EFI_REGULAR_EXPRESSION_PROTOCOL instance. Type EFI_REGULAR_EXPRESSION_PROTOCOL is defined in Section XYZ.</p>
<p>String A pointer to a NULL terminated string to match against the regular expression string specified by Pattern.</p>
<p>Pattern A pointer to a NULL terminated string that represents the regular expression.</p>
<p>SyntaxType A pointer to the EFI_REGEX_SYNTAX_TYPE that identifies the regular expression syntax type to use. May be NULL in which case the function will use its default regular expression syntax type.</p>
<p>Result On return, points to TRUE if String fully matches against the regular expression Pattern using the regular expression SyntaxType. Otherwise, points to FALSE.</p>
<p>Captures A Pointer to an array of <a class="el" href="struct_e_f_i___r_e_g_e_x___c_a_p_t_u_r_e.html">EFI_REGEX_CAPTURE</a> objects to receive the captured groups in the event of a match. The full sub-string match is put in Captures[0], and the results of N capturing groups are put in Captures[1:N]. If Captures is NULL, then this function doesn't allocate the memory for the array and does not build up the elements. It only returns the number of matching patterns in CapturesCount. If Captures is not NULL, this function returns a pointer to an array and builds up the elements in the array. CapturesCount is also updated to the number of matching patterns found. It is the caller's responsibility to free the memory pool in Captures and in each CapturePtr in the array elements.</p>
<p>CapturesCount On output, CapturesCount is the number of matching patterns found in String. Zero means no matching patterns were found in the string.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The regular expression string matching completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The regular expression syntax specified by SyntaxTypeis not supported by this driver. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The regular expression string matching failed due to a hardware or firmware error. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>String, Pattern, Result, or CapturesCountis NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function, it is called when asynchronous transfer is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Data received via asynchronous transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataLength</td><td>The length of Data in bytes, received via asynchronous transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Context passed from asynchronous transfer request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The callback function complete successfully.</td></tr>
  </table>
  </dd>
</dl>
<p>Parses HTTP header and produces an array of key/value pairs.</p>
<p>The Parse() function is used to transform data stored in HttpHeader into a list of fields paired with their corresponding values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to EFI_HTTP_UTILITIES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HttpMessage</td><td>Contains raw unformatted HTTP header string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HttpMessageSize</td><td>Size of HTTP header. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HeaderFields</td><td>Array of key/value header pairs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FieldCount</td><td>Number of headers in HeaderFields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Allocation succeeded. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>This EFI HTTP Protocol instance has not been initialized. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the following conditions is TRUE: This is NULL. HttpMessage is NULL. HeaderFields is NULL. FieldCount is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Reset the I2C controller and configure it for use</p>
<p>This routine must be called at or below TPL_NOTIFY.</p>
<p>The I2C controller is reset. The caller must call SetBusFrequench() after calling Reset().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_MASTER_PROTOCOL structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The reset completed successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The controller is busy with another transaction. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The reset operation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>Start an I2C transaction on the host controller.</p>
<p>This routine must be called at or below TPL_NOTIFY. For synchronous requests this routine must be called at or below TPL_CALLBACK.</p>
<p>This function initiates an I2C transaction on the controller. To enable proper error handling by the I2C protocol stack, the I2C master protocol does not support queuing but instead only manages one I2C transaction at a time. This API requires that the I2C bus is in the correct configuration for the I2C transaction.</p>
<p>The transaction is performed by sending a start-bit and selecting the I2C device with the specified I2C slave address and then performing the specified I2C operations. When multiple operations are requested they are separated with a repeated start bit and the slave address. The transaction is terminated with a stop bit.</p>
<p>When Event is NULL, StartRequest operates synchronously and returns the I2C completion status as its return value.</p>
<p>When Event is not NULL, StartRequest synchronously returns EFI_SUCCESS indicating that the I2C transaction was started asynchronously. The transaction status value is returned in the buffer pointed to by I2cStatus upon the completion of the I2C transaction when I2cStatus is not NULL. After the transaction status is returned the Event is signaled.</p>
<p>Note: The typical consumer of this API is the I2C host protocol. Extreme care must be taken by other consumers of this API to prevent confusing the third party I2C drivers due to a state change at the I2C device which the third party I2C drivers did not initiate. I2C platform specific code may use this API within these guidelines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_MASTER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SlaveAddress</td><td>Address of the device on the I2C bus. Set the I2C_ADDRESSING_10_BIT when using 10-bit addresses, clear this bit for 7-bit addressing. Bits 0-6 are used for 7-bit I2C slave addresses and bits 0-9 are used for 10-bit I2C slave addresses. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RequestPacket</td><td>Pointer to an <a class="el" href="struct_e_f_i___i2_c___r_e_q_u_e_s_t___p_a_c_k_e_t.html">EFI_I2C_REQUEST_PACKET</a> structure describing the I2C transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>Event to signal for asynchronous transactions, NULL for asynchronous transactions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I2cStatus</td><td>Optional buffer to receive the I2C transaction completion status</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The asynchronous transaction was successfully started when Event is not NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The transaction completed successfully when Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The controller is busy with another transaction. </td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The RequestPacket-&gt;LengthInBytes value is too large. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>There was an I2C error (NACK) during the transaction. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>RequestPacket is NULL </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Reserved bit set in the SlaveAddress parameter </td></tr>
    <tr><td class="paramname">EFI_NO_RESPONSE</td><td>The I2C device is not responding to the slave address. EFI_DEVICE_ERROR will be returned if the controller cannot distinguish when the NACK occurred. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Insufficient memory for I2C transaction </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The controller does not support the requested transaction.</td></tr>
  </table>
  </dd>
</dl>
<p>Used to retrieve next slot numbers supported by the SD controller. The function returns information about all available slots (populated or not-populated).</p>
<p>The GetNextSlot() function retrieves the next slot number on an SD controller. If on input Slot is 0xFF, then the slot number of the first slot on the SD controller is returned.</p>
<p>If Slot is a slot number that was returned on a previous call to GetNextSlot(), then the slot number of the next slot on the SD controller is returned.</p>
<p>If Slot is not 0xFF and Slot was not returned on a previous call to GetNextSlot(), EFI_INVALID_PARAMETER is returned.</p>
<p>If Slot is the slot number of the last slot on the SD controller, then EFI_NOT_FOUND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Slot</td><td>On input, a pointer to a slot number on the SD controller. On output, a pointer to the next slot number on the SD controller. An input value of 0xFF retrieves the first slot number on the SD controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The next slot number on the SD controller was returned in Slot. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>There are no more slots on this SD controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Slot is not 0xFF and Slot was not returned on a previous call to GetNextSlot().</td></tr>
  </table>
  </dd>
</dl>
<p>Used to allocate and build a device path node for an SD card on the SD controller.</p>
<p>The BuildDevicePath() function allocates and builds a single device node for the SD card specified by Slot.</p>
<p>If the SD card specified by Slot is not present on the SD controller, then EFI_NOT_FOUND is returned.</p>
<p>If DevicePath is NULL, then EFI_INVALID_PARAMETER is returned.</p>
<p>If there are not enough resources to allocate the device path node, then EFI_OUT_OF_RESOURCES is returned.</p>
<p>Otherwise, DevicePath is allocated with the boot service <a class="el" href="_memory_allocation_lib_8h.html#a646c0f82c2a35557dda175dbfcd26e96">AllocatePool()</a>, the contents of DevicePath are initialized to describe the SD card specified by Slot, and EFI_SUCCESS is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>Specifies the slot number of the SD card for which a device path node is to be allocated and built. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DevicePath</td><td>A pointer to a single device path node that describes the SD card specified by Slot. This function is responsible for allocating the buffer DevicePath with the boot service <a class="el" href="_memory_allocation_lib_8h.html#a646c0f82c2a35557dda175dbfcd26e96">AllocatePool()</a>. It is the caller's responsibility to free DevicePath when the caller is finished with DevicePath.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device path node that describes the SD card specified by Slot was allocated and returned in DevicePath. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The SD card specified by Slot does not exist on the SD controller. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There are not enough resources to allocate DevicePath.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves an SD card slot number based on the input device path.</p>
<p>The GetSlotNumber() function retrieves slot number for the SD card specified by the DevicePath node. If DevicePath is NULL, EFI_INVALID_PARAMETER is returned.</p>
<p>If DevicePath is not a device path node type that the SD Pass Thru driver supports, EFI_UNSUPPORTED is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DevicePath</td><td>A pointer to the device path node that describes a SD card on the SD controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Slot</td><td>On return, points to the slot number of an SD card on the SD controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>SD card slot number is returned in Slot. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Slot or DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>DevicePath is not a device path node type that the SD Pass Thru driver supports.</td></tr>
  </table>
  </dd>
</dl>
<p>Resets an SD card that is connected to the SD controller.</p>
<p>The ResetDevice() function resets the SD card specified by Slot.</p>
<p>If this SD controller does not support a device reset operation, EFI_UNSUPPORTED is returned.</p>
<p>If Slot is not in a valid slot number for this SD controller, EFI_INVALID_PARAMETER is returned.</p>
<p>If the device reset operation is completed, EFI_SUCCESS is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SD_MMC_PASS_THRU_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Slot</td><td>Specifies the slot number of the SD card to be reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SD card specified by Slot was reset. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The SD controller does not support a device reset operation. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Slot number is invalid. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>SD Device not present in the Slot. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The reset command failed due to a device error</td></tr>
  </table>
  </dd>
</dl>
<p>Set the write status prefix opcode.</p>
<p>This routine must be called at or below TPL_NOTIFY. The prefix table contains SPI transaction write prefix opcodes which are accessible after the legacy SPI flash controller's configuration is locked. The board layer specifies the write status prefix opcode for the SPI NOR flash part. The SPI NOR flash peripheral driver uses this API to load the opcode into the prefix table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WriteStatusPrefix</td><td>Prefix opcode for the write status command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The prefix table was updated </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked</td></tr>
  </table>
  </dd>
</dl>
<p>Set the BIOS base address.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS base address works with the protect range registers to protect portions of the SPI NOR flash from erase and write operat ions. The BIOS calls this API prior to passing control to the OS loader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BiosBaseAddress</td><td>The BIOS base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The BIOS base address was properly set </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The BIOS base address is greater than This-&gt;Maxi.mumOffset </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The BIOS base address was already set</td></tr>
  </table>
  </dd>
</dl>
<p>Clear the SPI protect range registers.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS uses this routine to set an initial condition on the SPI protect range registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The registers were successfully cleared </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked</td></tr>
  </table>
  </dd>
</dl>
<p>Set the next protect range register.</p>
<p>This routine must be called at or below TPL_NOTIFY. The BIOS sets the protect range register to prevent write and erase operations to a portion of the SPI NOR flash device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BiosAddress</td><td>Address within a 4 KiB block to start protecting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlocksToProtect</td><td>The number of 4 KiB blocks to protect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The register was successfully updated </td></tr>
    <tr><td class="paramname">EFI_ACCESS_ERROR</td><td>The SPI controller is locked </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BiosAddress &lt; This-&gt;BiosBaseAddress, or BlocksToProtect * 4 KiB &gt; This-&gt;MaximumRangeBytes, or BiosAddress - This-&gt;BiosBaseAddress<ul>
<li>(BlocksToProtect * 4 KiB) &gt; This-&gt;MaximumRangeBytes </li>
</ul>
</td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>No protect range register available </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Call This-&gt;SetBaseAddress because the BIOS base address is not set</td></tr>
  </table>
  </dd>
</dl>
<p>Lock the SPI controller configuration.</p>
<p>This routine must be called at or below TPL_NOTIFY. This routine locks the SPI controller's configuration so that the software is no longer able to update: Prefix table Opcode menu Opcode type table BIOS base address Protect range registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_LEGACY_SPI_CONTROLLER_PROTOCOL structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The SPI controller was successfully locked </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The SPI controller was already locked</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TCG2_PROTOCOL Get Event Log function call allows a caller to retrieve the address of a given event log and its last entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EventLogFormat</td><td>The type of the event log for which the information is requested. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogLocation</td><td>A pointer to the memory address of the event log. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogLastEntry</td><td>If the Event Log contains more than one entry, this is a pointer to the address of the start of the last entry in the event log in memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EventLogTruncated</td><td>If the Event Log is missing at least one entry because an event would have exceeded the area allocated for events, this value is set to TRUE. Otherwise, the value will be FALSE and the Event Log will be complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect (e.g. asking for an event log whose format is not supported).</td></tr>
  </table>
  </dd>
</dl>
<p>The EFI_TCG2_PROTOCOL HashLogExtendEvent function call provides callers with an opportunity to extend and optionally log events without requiring knowledge of actual TPM commands. The extend operation will occur even if this function cannot create an event log entry (e.g. due to the event log being full).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>Bitmap providing additional information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataToHash</td><td>Physical address of the start of the data buffer to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataToHashLen</td><td>The length in bytes of the buffer referenced by DataToHash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EfiTcgEvent</td><td>Pointer to data buffer containing information about the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was unsuccessful. </td></tr>
    <tr><td class="paramname">EFI_VOLUME_FULL</td><td>The extend operation occurred, but the event could not be written to one or more event logs. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The PE/COFF image type is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>This service enables the sending of commands to the TPM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputParameterBlockSize</td><td>Size of the TPM input parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputParameterBlock</td><td>Pointer to the TPM input parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputParameterBlockSize</td><td>Size of the TPM output parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputParameterBlock</td><td>Pointer to the TPM output parameter block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The command byte stream was successfully sent to the device and a response was successfully received. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The command was not successfully sent to the device or a response was not successfully received from the device. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The output parameter block is too small.</td></tr>
  </table>
  </dd>
</dl>
<p>This service returns the currently active PCR banks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ActivePcrBanks</td><td>Pointer to the variable receiving the bitmap of currently active PCR banks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The bitmap of active PCR banks was stored in the ActivePcrBanks parameter. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect.</td></tr>
  </table>
  </dd>
</dl>
<p>This service sets the currently active PCR banks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ActivePcrBanks</td><td>Bitmap of the requested active PCR banks. At least one bit SHALL be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The bitmap in ActivePcrBank parameter is already active. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect.</td></tr>
  </table>
  </dd>
</dl>
<p>This service retrieves the result of a previous invocation of SetActivePcrBanks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Indicates the calling context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OperationPresent</td><td>Non-zero value to indicate a SetActivePcrBank operation was invoked during the last boot. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Response</td><td>The response from the SetActivePcrBank request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The result value could be returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the parameters are incorrect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab998e5f7da4a664eaa86252ab16e459a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Task priority level. </p>

</div>
</div>
<a class="anchor" id="a353ea2e3d6220a4e32c5f1eb39a1ed6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_ia32_2_processor_bind_8h.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> <a class="el" href="_uefi_base_type_8h.html#a353ea2e3d6220a4e32c5f1eb39a1ed6a">EFI_VIRTUAL_ADDRESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>64-bit virtual memory address. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ee16cea0340e4558b8b17c3b12ae3d0b.html">MdePkg</a></li><li class="navelem"><a class="el" href="dir_43dbc6def9233b1fec759bd8d9ab8e67.html">Include</a></li><li class="navelem"><a class="el" href="dir_aafcf413d091d5d86eb6b53ca64bf6b8.html">Uefi</a></li><li class="navelem"><a class="el" href="_uefi_base_type_8h.html">UefiBaseType.h</a></li>
    <li class="footer">Generated on Sun Dec 5 2021 03:41:14 for MdePkg[all] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
