<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MdePkg[all]: MdePkg/Include/Protocol/FirmwareVolumeBlock.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MdePkg[all]
   &#160;<span id="projectnumber">1.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_firmware_volume_block_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">FirmwareVolumeBlock.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___e_f_i___f_i_r_m_w_a_r_e___v_o_l_u_m_e___b_l_o_c_k___p_r_o_t_o_c_o_l.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a634425d0868cfc81406f3ab7eb75c63a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#a634425d0868cfc81406f3ab7eb75c63a">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID</a>&#160;&#160;&#160;{ 0x8f644fa9, 0xe850, 0x4db1, {0x9c, 0xe2, 0xb, 0x44, 0x69, 0x8e, 0x8d, 0xa4 } }</td></tr>
<tr class="separator:a634425d0868cfc81406f3ab7eb75c63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ea3da9db7f3e97b9420ae698511df9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#a63ea3da9db7f3e97b9420ae698511df9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL_GUID</a>&#160;&#160;&#160;{ 0x8f644fa9, 0xe850, 0x4db1, {0x9c, 0xe2, 0xb, 0x44, 0x69, 0x8e, 0x8d, 0xa4 } }</td></tr>
<tr class="separator:a63ea3da9db7f3e97b9420ae698511df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41686b428702e1162e8d16507b2c7048"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#a41686b428702e1162e8d16507b2c7048">EFI_LBA_LIST_TERMINATOR</a>&#160;&#160;&#160;0xFFFFFFFFFFFFFFFFULL</td></tr>
<tr class="separator:a41686b428702e1162e8d16507b2c7048"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad7a8ba0805473947f20ff7ca832b884e"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct___e_f_i___f_i_r_m_w_a_r_e___v_o_l_u_m_e___b_l_o_c_k___p_r_o_t_o_c_o_l.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#ad7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a></td></tr>
<tr class="separator:ad7a8ba0805473947f20ff7ca832b884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c242031b5d358c39d06cbe0e92b7a9"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="_firmware_volume_block_8h.html#ad7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a></td></tr>
<tr class="separator:ad3c242031b5d358c39d06cbe0e92b7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb158956d4fbffceeedd1d8b0b561d08"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#acb158956d4fbffceeedd1d8b0b561d08">EFI_FVB_GET_ATTRIBUTES</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pi_firmware_volume_8h.html#a9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td></tr>
<tr class="separator:acb158956d4fbffceeedd1d8b0b561d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57513c3161f4e534371b2b9fc48745e7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#a57513c3161f4e534371b2b9fc48745e7">EFI_FVB_SET_ATTRIBUTES</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pi_firmware_volume_8h.html#a9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td></tr>
<tr class="separator:a57513c3161f4e534371b2b9fc48745e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cc2e5e956b455338f556ad82c0542d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#a85cc2e5e956b455338f556ad82c0542d">EFI_FVB_GET_PHYSICAL_ADDRESS</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> *Address)</td></tr>
<tr class="separator:a85cc2e5e956b455338f556ad82c0542d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9d3b5c28613c16d59ed4753ae4d1fe"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#a6c9d3b5c28613c16d59ed4753ae4d1fe">EFI_FVB_GET_BLOCK_SIZE</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_uefi_base_type_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *BlockSize, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *NumberOfBlocks)</td></tr>
<tr class="separator:a6c9d3b5c28613c16d59ed4753ae4d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea138515e3f1b4a2e451d5ae40727d6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#afea138515e3f1b4a2e451d5ae40727d6">EFI_FVB_READ</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_uefi_base_type_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> <a class="el" href="_nvdimm_label_8h.html#ad04b4cf9d43efe6a83b6433a360dc735">Offset</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *NumBytes, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *<a class="el" href="_supplicant_8h.html#ac67e1217dfc7830023855fe9cade358e">Buffer</a>)</td></tr>
<tr class="separator:afea138515e3f1b4a2e451d5ae40727d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cd9da63363d8161410b05ff14bc0d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#a43cd9da63363d8161410b05ff14bc0d9">EFI_FVB_WRITE</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_uefi_base_type_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> <a class="el" href="_nvdimm_label_8h.html#ad04b4cf9d43efe6a83b6433a360dc735">Offset</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *NumBytes, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *<a class="el" href="_supplicant_8h.html#ac67e1217dfc7830023855fe9cade358e">Buffer</a>)</td></tr>
<tr class="separator:a43cd9da63363d8161410b05ff14bc0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf86fe087876476a2baabcef3d06222"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#aacf86fe087876476a2baabcef3d06222">EFI_FVB_ERASE_BLOCKS</a> )(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>,...)</td></tr>
<tr class="separator:aacf86fe087876476a2baabcef3d06222"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac7dd22180e12651e972004706585ac43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#ac7dd22180e12651e972004706585ac43">gEfiFirmwareVolumeBlockProtocolGuid</a></td></tr>
<tr class="separator:ac7dd22180e12651e972004706585ac43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64e73c07c4186a5d85bb74fe2ac0884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_firmware_volume_block_8h.html#ad64e73c07c4186a5d85bb74fe2ac0884">gEfiFirmwareVolumeBlock2ProtocolGuid</a></td></tr>
<tr class="separator:ad64e73c07c4186a5d85bb74fe2ac0884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides control over block-oriented firmware devices.</p>
<p>Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<br/>
 SPDX-License-Identifier: BSD-2-Clause-Patent</p>
<dl class="section user"><dt>Revision Reference: PI</dt><dd>Version 1.0 and 1.2. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a63ea3da9db7f3e97b9420ae698511df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL_GUID&#160;&#160;&#160;{ 0x8f644fa9, 0xe850, 0x4db1, {0x9c, 0xe2, 0xb, 0x44, 0x69, 0x8e, 0x8d, 0xa4 } }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a634425d0868cfc81406f3ab7eb75c63a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID&#160;&#160;&#160;{ 0x8f644fa9, 0xe850, 0x4db1, {0x9c, 0xe2, 0xb, 0x44, 0x69, 0x8e, 0x8d, 0xa4 } }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a41686b428702e1162e8d16507b2c7048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_LBA_LIST_TERMINATOR&#160;&#160;&#160;0xFFFFFFFFFFFFFFFFULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EFI_LBA_LIST_TERMINATOR </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ad3c242031b5d358c39d06cbe0e92b7a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_firmware_volume_block_8h.html#ad7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7a8ba0805473947f20ff7ca832b884e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___e_f_i___f_i_r_m_w_a_r_e___v_o_l_u_m_e___b_l_o_c_k___p_r_o_t_o_c_o_l.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> <a class="el" href="_firmware_volume_block_8h.html#ad7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aacf86fe087876476a2baabcef3d06222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_ERASE_BLOCKS)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>,...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases and initializes a firmware volume block.</p>
<p>The EraseBlocks() function erases one or more blocks as denoted by the variable argument list. The entire parameter list of blocks must be verified before erasing any blocks. If a block is requested that does not exist within the associated firmware volume (it has a larger index than the last block of the firmware volume), the EraseBlocks() function must return the status code EFI_INVALID_PARAMETER without modifying the contents of the firmware volume. Implementations should be mindful that the firmware volume might be in the WriteDisabled state. If it is in this state, the EraseBlocks() function must return the status code EFI_ACCESS_DENIED without modifying the contents of the firmware volume. All calls to EraseBlocks() must be fully flushed to the hardware before the EraseBlocks() service returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">...</td><td>The variable argument list is a list of tuples. Each tuple describes a range of LBAs to erase and consists of the following:<ul>
<li>An EFI_LBA that indicates the starting LBA</li>
<li>A UINTN that indicates the number of blocks to erase.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The list is terminated with an EFI_LBA_LIST_TERMINATOR. For example, the following indicates that two ranges of blocks (5-7 and 10-11) are to be erased: EraseBlocks (This, 5, 3, 10, 2, EFI_LBA_LIST_TERMINATOR);</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The erase request successfully completed.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The firmware volume is in the WriteDisabled state. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The block device is not functioning correctly and could not be written. The firmware device may have been partially erased. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the LBAs listed in the variable argument list do not exist in the firmware volume. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb158956d4fbffceeedd1d8b0b561d08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_GET_ATTRIBUTES)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pi_firmware_volume_8h.html#a9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GetAttributes() function retrieves the attributes and current settings of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Attributes</td><td>Pointer to EFI_FVB_ATTRIBUTES_2 in which the attributes and current settings are returned. Type EFI_FVB_ATTRIBUTES_2 is defined in <a class="el" href="struct_e_f_i___f_i_r_m_w_a_r_e___v_o_l_u_m_e___h_e_a_d_e_r.html">EFI_FIRMWARE_VOLUME_HEADER</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume attributes were returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c9d3b5c28613c16d59ed4753ae4d1fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_GET_BLOCK_SIZE)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_uefi_base_type_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *BlockSize, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *NumberOfBlocks)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GetBlockSize() function retrieves the size of the requested block. It also returns the number of additional blocks with the identical size. The GetBlockSize() function is used to retrieve the block map (see <a class="el" href="struct_e_f_i___f_i_r_m_w_a_r_e___v_o_l_u_m_e___h_e_a_d_e_r.html">EFI_FIRMWARE_VOLUME_HEADER</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Lba</td><td>Indicates the block for which to return the size.</td></tr>
    <tr><td class="paramname">BlockSize</td><td>Pointer to a caller-allocated UINTN in which the size of the block is returned.</td></tr>
    <tr><td class="paramname">NumberOfBlocks</td><td>Pointer to a caller-allocated UINTN in which the number of consecutive blocks, starting with Lba, is returned. All blocks in this range have a size of BlockSize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume base address was returned.</td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The requested LBA is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85cc2e5e956b455338f556ad82c0542d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_GET_PHYSICAL_ADDRESS)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> *Address)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GetPhysicalAddress() function retrieves the base address of a memory-mapped firmware volume. This function should be called only for memory-mapped firmware volumes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Address</td><td>Pointer to a caller-allocated EFI_PHYSICAL_ADDRESS that, on successful return from GetPhysicalAddress(), contains the base address of the firmware volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume base address was returned.</td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The firmware volume is not memory mapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afea138515e3f1b4a2e451d5ae40727d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_READ)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_uefi_base_type_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> <a class="el" href="_nvdimm_label_8h.html#ad04b4cf9d43efe6a83b6433a360dc735">Offset</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *NumBytes, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *<a class="el" href="_supplicant_8h.html#ac67e1217dfc7830023855fe9cade358e">Buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the specified number of bytes into a buffer from the specified block.</p>
<p>The <a class="el" href="_ufs_device_config_8h.html#a17ea7fbb9903bd241b29b2aebc8a371c">Read()</a> function reads the requested number of bytes from the requested block and stores them in the provided buffer. Implementations should be mindful that the firmware volume might be in the ReadDisabled state. If it is in this state, the <a class="el" href="_ufs_device_config_8h.html#a17ea7fbb9903bd241b29b2aebc8a371c">Read()</a> function must return the status code EFI_ACCESS_DENIED without modifying the contents of the buffer. The <a class="el" href="_ufs_device_config_8h.html#a17ea7fbb9903bd241b29b2aebc8a371c">Read()</a> function must also prevent spanning block boundaries. If a read is requested that would span a block boundary, the read must read up to the boundary but not beyond. The output parameter NumBytes must be set to correctly indicate the number of bytes actually read. The caller must be aware that a read may be partially completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Lba</td><td>The starting logical block index from which to read.</td></tr>
    <tr><td class="paramname">Offset</td><td>Offset into the block at which to begin reading.</td></tr>
    <tr><td class="paramname">NumBytes</td><td>Pointer to a UINTN. At entry, *NumBytes contains the total size of the buffer. At exit, *NumBytes contains the total number of bytes read.</td></tr>
    <tr><td class="paramname">Buffer</td><td>Pointer to a caller-allocated buffer that will be used to hold the data that is read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume was read successfully, and contents are in Buffer.</td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>Read attempted across an LBA boundary. On output, NumBytes contains the total number of bytes returned in Buffer.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The firmware volume is in the ReadDisabled state.</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The block device is not functioning correctly and could not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57513c3161f4e534371b2b9fc48745e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_SET_ATTRIBUTES)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_pi_firmware_volume_8h.html#a9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The SetAttributes() function sets configurable firmware volume attributes and returns the new settings of the firmware volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Attributes</td><td>On input, Attributes is a pointer to EFI_FVB_ATTRIBUTES_2 that contains the desired firmware volume settings. On successful return, it contains the new settings of the firmware volume. Type EFI_FVB_ATTRIBUTES_2 is defined in <a class="el" href="struct_e_f_i___f_i_r_m_w_a_r_e___v_o_l_u_m_e___h_e_a_d_e_r.html">EFI_FIRMWARE_VOLUME_HEADER</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume attributes were returned.</td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The attributes requested are in conflict with the capabilities as declared in the firmware volume header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43cd9da63363d8161410b05ff14bc0d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#aa8fe0c70f8531326ad565427ea96c1f4">EFI_STATUS</a>(<a class="el" href="_ebc_2_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_WRITE)(<a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="_firmware_volume_block_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *<a class="el" href="_ppi_2_mm_control_8h.html#a9b72b028448e2d973a9f4fa637b71951">This</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_uefi_base_type_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> <a class="el" href="_nvdimm_label_8h.html#ad04b4cf9d43efe6a83b6433a360dc735">Offset</a>, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *NumBytes, <a class="el" href="_base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="_ia32_2_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *<a class="el" href="_supplicant_8h.html#ac67e1217dfc7830023855fe9cade358e">Buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the specified number of bytes from the input buffer to the block.</p>
<p>The Write() function writes the specified number of bytes from the provided buffer to the specified block and offset. If the firmware volume is sticky write, the caller must ensure that all the bits of the specified range to write are in the EFI_FVB_ERASE_POLARITY state before calling the Write() function, or else the result will be unpredictable. This unpredictability arises because, for a sticky-write firmware volume, a write may negate a bit in the EFI_FVB_ERASE_POLARITY state but cannot flip it back again. Before calling the Write() function, it is recommended for the caller to first call the EraseBlocks() function to erase the specified block to write. A block erase cycle will transition bits from the (NOT)EFI_FVB_ERASE_POLARITY state back to the EFI_FVB_ERASE_POLARITY state. Implementations should be mindful that the firmware volume might be in the WriteDisabled state. If it is in this state, the Write() function must return the status code EFI_ACCESS_DENIED without modifying the contents of the firmware volume. The Write() function must also prevent spanning block boundaries. If a write is requested that spans a block boundary, the write must store up to the boundary but not beyond. The output parameter NumBytes must be set to correctly indicate the number of bytes actually written. The caller must be aware that a write may be partially completed. All writes, partial or otherwise, must be fully flushed to the hardware before the Write() service returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Lba</td><td>The starting logical block index to write to.</td></tr>
    <tr><td class="paramname">Offset</td><td>Offset into the block at which to begin writing.</td></tr>
    <tr><td class="paramname">NumBytes</td><td>The pointer to a UINTN. At entry, *NumBytes contains the total size of the buffer. At exit, *NumBytes contains the total number of bytes actually written.</td></tr>
    <tr><td class="paramname">Buffer</td><td>The pointer to a caller-allocated buffer that contains the source for the write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume was written successfully.</td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The write was attempted across an LBA boundary. On output, NumBytes contains the total number of bytes actually written.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The firmware volume is in the WriteDisabled state.</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The block device is malfunctioning and could not be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ad64e73c07c4186a5d85bb74fe2ac0884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiFirmwareVolumeBlock2ProtocolGuid</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7dd22180e12651e972004706585ac43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiFirmwareVolumeBlockProtocolGuid</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_c048fdeadf06364e9318d2cbb3390051.html">MdePkg</a></li><li class="navelem"><a class="el" href="dir_525332e2e2b2ed96fb8f8316b580bf1e.html">Include</a></li><li class="navelem"><a class="el" href="dir_c891243080d8325efd53abbaaf181a0e.html">Protocol</a></li><li class="navelem"><a class="el" href="_firmware_volume_block_8h.html">FirmwareVolumeBlock.h</a></li>
    <li class="footer">Generated on Sun Dec 5 2021 00:12:47 for MdePkg[all] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
