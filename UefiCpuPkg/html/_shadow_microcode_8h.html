<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>UefiCpuPkg[all]: UefiCpuPkg/Include/Ppi/ShadowMicrocode.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">UefiCpuPkg[all]
   &#160;<span id="projectnumber">0.90</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_microcode_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ShadowMicrocode.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_d_k_i_i___p_e_i___m_i_c_r_o_c_o_d_e___c_p_u___i_d.html">EDKII_PEI_MICROCODE_CPU_ID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___e_d_k_i_i___p_e_i___s_h_a_d_o_w___m_i_c_r_o_c_o_d_e___p_p_i.html">_EDKII_PEI_SHADOW_MICROCODE_PPI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab2dd0cdf725bb624242d08942c0b942f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_shadow_microcode_8h.html#ab2dd0cdf725bb624242d08942c0b942f">EDKII_PEI_SHADOW_MICROCODE_PPI_GUID</a></td></tr>
<tr class="separator:ab2dd0cdf725bb624242d08942c0b942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a351f8410131f01c8a7184de67a238971"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct___e_d_k_i_i___p_e_i___s_h_a_d_o_w___m_i_c_r_o_c_o_d_e___p_p_i.html">_EDKII_PEI_SHADOW_MICROCODE_PPI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_shadow_microcode_8h.html#a351f8410131f01c8a7184de67a238971">EDKII_PEI_SHADOW_MICROCODE_PPI</a></td></tr>
<tr class="separator:a351f8410131f01c8a7184de67a238971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b2e730974a541df134e30a3b9ad822"><td class="memItemLeft" align="right" valign="top">typedef IN UINTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_shadow_microcode_8h.html#ac5b2e730974a541df134e30a3b9ad822">CpuIdCount</a></td></tr>
<tr class="separator:ac5b2e730974a541df134e30a3b9ad822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94df9c4f7de87adcebbe229058871ff"><td class="memItemLeft" align="right" valign="top">typedef IN UINTN IN <br class="typebreak"/>
<a class="el" href="struct_e_d_k_i_i___p_e_i___m_i_c_r_o_c_o_d_e___c_p_u___i_d.html">EDKII_PEI_MICROCODE_CPU_ID</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_shadow_microcode_8h.html#aa94df9c4f7de87adcebbe229058871ff">MicrocodeCpuId</a></td></tr>
<tr class="separator:aa94df9c4f7de87adcebbe229058871ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2f566aae4b57be976ccf98954d1147"><td class="memItemLeft" align="right" valign="top">typedef IN UINTN IN <br class="typebreak"/>
<a class="el" href="struct_e_d_k_i_i___p_e_i___m_i_c_r_o_c_o_d_e___c_p_u___i_d.html">EDKII_PEI_MICROCODE_CPU_ID</a> OUT <br class="typebreak"/>
UINTN *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_shadow_microcode_8h.html#a2a2f566aae4b57be976ccf98954d1147">BufferSize</a></td></tr>
<tr class="separator:a2a2f566aae4b57be976ccf98954d1147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661f7f953e552d561f26e001f153ac27"><td class="memItemLeft" align="right" valign="top">typedef IN UINTN IN <br class="typebreak"/>
<a class="el" href="struct_e_d_k_i_i___p_e_i___m_i_c_r_o_c_o_d_e___c_p_u___i_d.html">EDKII_PEI_MICROCODE_CPU_ID</a> OUT <br class="typebreak"/>
UINTN OUT VOID **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_shadow_microcode_8h.html#a661f7f953e552d561f26e001f153ac27">Buffer</a></td></tr>
<tr class="separator:a661f7f953e552d561f26e001f153ac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abbffd8604d977e1e93969a6e1dc90b20"><td class="memItemLeft" align="right" valign="top">typedef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_shadow_microcode_8h.html#abbffd8604d977e1e93969a6e1dc90b20">EFI_STATUS</a> (EFIAPI *EDKII_PEI_SHADOW_MICROCODE)(IN <a class="el" href="_shadow_microcode_8h.html#a351f8410131f01c8a7184de67a238971">EDKII_PEI_SHADOW_MICROCODE_PPI</a> *This</td></tr>
<tr class="separator:abbffd8604d977e1e93969a6e1dc90b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4b06633aa07c3b014703653b7adf0689"><td class="memItemLeft" align="right" valign="top">EFI_GUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_shadow_microcode_8h.html#a4b06633aa07c3b014703653b7adf0689">gEdkiiPeiShadowMicrocodePpiGuid</a></td></tr>
<tr class="separator:a4b06633aa07c3b014703653b7adf0689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file declares EDKII Shadow Microcode PPI.</p>
<p>Copyright (c) 2020, Intel Corporation. All rights reserved.<br/>
 SPDX-License-Identifier: BSD-2-Clause-Patent </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ab2dd0cdf725bb624242d08942c0b942f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EDKII_PEI_SHADOW_MICROCODE_PPI_GUID</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">    0x430f6965, 0x9a69, 0x41c5, { 0x93, 0xed, 0x8b, 0xf0, 0x64, 0x35, 0xc1, 0xc6 } \</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a661f7f953e552d561f26e001f153ac27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IN UINTN IN <a class="el" href="struct_e_d_k_i_i___p_e_i___m_i_c_r_o_c_o_d_e___c_p_u___i_d.html">EDKII_PEI_MICROCODE_CPU_ID</a> OUT UINTN OUT VOID** <a class="el" href="_shadow_microcode_8h.html#a661f7f953e552d561f26e001f153ac27">Buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a2f566aae4b57be976ccf98954d1147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IN UINTN IN <a class="el" href="struct_e_d_k_i_i___p_e_i___m_i_c_r_o_c_o_d_e___c_p_u___i_d.html">EDKII_PEI_MICROCODE_CPU_ID</a> OUT UINTN* <a class="el" href="_shadow_microcode_8h.html#a2a2f566aae4b57be976ccf98954d1147">BufferSize</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5b2e730974a541df134e30a3b9ad822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IN UINTN <a class="el" href="_shadow_microcode_8h.html#ac5b2e730974a541df134e30a3b9ad822">CpuIdCount</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a351f8410131f01c8a7184de67a238971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___e_d_k_i_i___p_e_i___s_h_a_d_o_w___m_i_c_r_o_c_o_d_e___p_p_i.html">_EDKII_PEI_SHADOW_MICROCODE_PPI</a> <a class="el" href="_shadow_microcode_8h.html#a351f8410131f01c8a7184de67a238971">EDKII_PEI_SHADOW_MICROCODE_PPI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa94df9c4f7de87adcebbe229058871ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IN UINTN IN <a class="el" href="struct_e_d_k_i_i___p_e_i___m_i_c_r_o_c_o_d_e___c_p_u___i_d.html">EDKII_PEI_MICROCODE_CPU_ID</a>* <a class="el" href="_shadow_microcode_8h.html#aa94df9c4f7de87adcebbe229058871ff">MicrocodeCpuId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abbffd8604d977e1e93969a6e1dc90b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EFI_STATUS </td>
          <td>(</td>
          <td class="paramtype">EFIAPI *&#160;</td>
          <td class="paramname"><em>EFI_SMM_REGISTER_EXCEPTION_HANDLER</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shadow microcode update patches to memory.</p>
<p>The function is used for shadowing microcode update patches to a continuous memory. It shall allocate memory buffer and only shadow the microcode patches for those processors specified by MicrocodeCpuId array. The checksum verification may be skiped in this function so the caller must perform checksum verification before using the microcode patches in returned memory buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>The PPI instance pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CpuIdCount</td><td>Number of elements in MicrocodeCpuId array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MicrocodeCpuId</td><td>A pointer to an array of <a class="el" href="struct_e_d_k_i_i___p_e_i___m_i_c_r_o_c_o_d_e___c_p_u___i_d.html">EDKII_PEI_MICROCODE_CPU_ID</a> structures. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BufferSize</td><td>Pointer to receive the total size of Buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to receive address of allocated memory with microcode patches data in it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The microcode has been shadowed to memory. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The operation fails due to lack of resources.</td></tr>
  </table>
  </dd>
</dl>
<p>Get information on a specific CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to this instance of the PPI. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>Pointer to the total number of logical processors in the system, including the BSP and disabled APs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ProcessorInfoBuffer</td><td>Number of processors in the system that are enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Processor information was returned. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorInfoBuffer is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist in the platform.</td></tr>
  </table>
  </dd>
</dl>
<p>Activate all of the application proessors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on enabled APs of the system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SingleThread</td><td>If TRUE, then all the enabled APs execute the function specified by Procedure one by one, in ascending order of processor handle number. If FALSE, then all the enabled APs execute the function specified by Procedure simultaneously. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroSeconds</td><td>Indicates the time limit in microseconds for APs to return from Procedure, for blocking mode only. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. All enabled APs are available for next function assigned by EFI_PEI_MP_SERVICES_PPI.StartupAllAPs() or EFI_PEI_MP_SERVICES_PPI.StartupThisAP(). If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure for all APs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, all APs have finished before the timeout expired. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Caller processor is AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>No enabled APs exist in the system. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Any enabled APs are busy. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before all enabled APs have finished. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Activate a specific application processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on enabled APs of the system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroSeconds</td><td>Indicates the time limit in microseconds for APs to return from Procedure, for blocking mode only. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. All enabled APs are available for next function assigned by EFI_PEI_MP_SERVICES_PPI.StartupAllAPs() or EFI_PEI_MP_SERVICES_PPI.StartupThisAP(). If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure for all APs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, specified AP finished before the timeout expires. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before the specified AP has finished. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the BSP or disabled AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Switch the boot strap processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EnableOldBSP</td><td>If TRUE, then the old BSP will be listed as an enabled AP. Otherwise, it will be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>BSP successfully switched. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP is not supported. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the current BSP or a disabled AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The specified AP is busy.</td></tr>
  </table>
  </dd>
</dl>
<p>Enable or disable an application processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EnableAP</td><td>Specifies the new state for the processor for enabled, FALSE for disabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HealthFlag</td><td>If not NULL, a pointer to a value that specifies the new health status of the AP. This flag corresponds to StatusFlag defined in EFI_PEI_MP_SERVICES_PPI.GetProcessorInfo(). Only the PROCESSOR_HEALTH_STATUS_BIT is used. All other bits are ignored. If it is NULL, this parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified AP was enabled or disabled successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Enabling or disabling an AP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Enabling or disabling an AP is not supported. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the BSP.</td></tr>
  </table>
  </dd>
</dl>
<p>Identify the currently executing processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_PEI_MP_SERVICES_PPI instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by EFI_PEI_MP_SERVICES_PPI.GetNumberOfProcessors().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The current processor handle number was returned in ProcessorNumber. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Activate all of the application proessors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EDKII_PEI_MP_SERVICES2_PPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on enabled APs of the system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicroSeconds</td><td>Indicates the time limit in microseconds for APs to return from Procedure, for blocking mode only. Zero means infinity. If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure for all CPUs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, all APs have finished before the timeout expired. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Caller processor is AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Any enabled APs are busy. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before all enabled APs have finished. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Add resources in list to database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ResourceList</td><td>A pointer to resource list to be added </td></tr>
    <tr><td class="paramname">NumEntries</td><td>Optional number of entries. If 0, list must be terminated by END_OF_RESOURCES.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If resources are added </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>If nested procedure detected resource failer </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>If nested procedure returned it and we cannot allocate more areas.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete resources in list to database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ResourceList</td><td>A pointer to resource list to be deleted NULL means delete all resources. </td></tr>
    <tr><td class="paramname">NumEntries</td><td>Optional number of entries. If 0, list must be terminated by END_OF_RESOURCES.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If resources are deleted </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>If nested procedure detected resource failer</td></tr>
  </table>
  </dd>
</dl>
<p>Get BIOS resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ResourceList</td><td>A pointer to resource list to be filled </td></tr>
    <tr><td class="paramname">ResourceSize</td><td>On input it means size of resource list input. On output it means size of resource list filled, or the size of resource list to be filled if size of too small.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If resources are returned. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>If resource list buffer is too small to hold the whole resources.</td></tr>
  </table>
  </dd>
</dl>
<p>This service switches the requested AP to be the BSP from that point onward. This service changes the BSP for all purposes. This call can only be performed by the current BSP.</p>
<p>This service switches the requested AP to be the BSP from that point onward. This service changes the BSP for all purposes. The new BSP can take over the execution of the old BSP and continue seamlessly from where the old one left off.</p>
<p>If the BSP cannot be switched prior to the return from this service, then EFI_UNSUPPORTED must be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SMM_CPU_SERVICE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of AP that is to become the new BSP. The range is from 0 to the total number of logical processors minus 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>BSP successfully switched. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP is not supported. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the current BSP or a disabled AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The specified AP is busy.</td></tr>
  </table>
  </dd>
</dl>
<p>Notify that a new processor has been added to the system.</p>
<p>The SMM CPU driver should add the processor to the SMM CPU list.</p>
<p>If the processor is disabled it won't participate any SMI handler during subsequent SMIs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_SMM_CPU_SERVICE_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">ProcessorId</td><td>The hardware ID of the processor. </td></tr>
    <tr><td class="paramname">ProcessorNumber</td><td>The handle number of processor. </td></tr>
    <tr><td class="paramname">ProcessorResource</td><td>A pointer to EFI_SMM_PROCESSOR_RESOURCE which holds the assigned resources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>Processor already present. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Space for a new handle could not be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p>Notify that a processor is hot-removed.</p>
<p>Remove a processor from the CPU list of the SMM CPU driver. After this API is called, the removed processor must not respond to SMIs in the coherence domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the EFI_SMM_CPU_SERVICE_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">ProcessorId</td><td>The hardware ID of the processor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Processor with the hardware ID specified by ProcessorId does not exist. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Specified AP is busy.</td></tr>
  </table>
  </dd>
</dl>
<p>This return the handle number for the calling processor. This service may be called from the BSP and APs.</p>
<p>This service returns the processor handle number for the calling processor. The returned value is in the range from 0 to the total number of logical processors minus 1. This service may be called from the BSP and APs. If ProcessorNumber is NULL, then EFI_INVALID_PARAMETER is returned. Otherwise, the current processors handle number is returned in ProcessorNumber, and EFI_SUCCESS is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_SMM_CPU_SERVICE_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of AP that is to become the new BSP. The range is from 0 to the total number of logical processors minus 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The current processor handle number was returned in ProcessorNumber. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Register exception handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>A pointer to the SMM_CPU_SERVICE_PROTOCOL instance. </td></tr>
    <tr><td class="paramname">ExceptionType</td><td>Defines which interrupt or exception to hook. Type EFI_EXCEPTION_TYPE and the valid values for this parameter are defined in EFI_DEBUG_SUPPORT_PROTOCOL of the UEFI 2.0 specification. </td></tr>
    <tr><td class="paramname">InterruptHandler</td><td>A pointer to a function of type EFI_CPU_INTERRUPT_HANDLER that is called when a processor interrupt occurs. If this parameter is NULL, then the handler will be uninstalled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The handler for the processor interrupt was successfully installed or uninstalled. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>InterruptHandler is not NULL, and a handler for InterruptType was previously installed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>InterruptHandler is NULL, and a handler for InterruptType was not previously installed. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The interrupt specified by InterruptType is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a4b06633aa07c3b014703653b7adf0689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EFI_GUID gEdkiiPeiShadowMicrocodePpiGuid</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_bf5121888dfe870556fe9875eb4b3269.html">UefiCpuPkg</a></li><li class="navelem"><a class="el" href="dir_e701b125b1179e59bad921214df48aa3.html">Include</a></li><li class="navelem"><a class="el" href="dir_a480a768ea145b23f2ba619c1c6c2de1.html">Ppi</a></li><li class="navelem"><a class="el" href="_shadow_microcode_8h.html">ShadowMicrocode.h</a></li>
    <li class="footer">Generated on Sun Dec 5 2021 02:59:47 for UefiCpuPkg[all] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
